<pre class="metadata">
Title: CSS Device Adaptation Module Level 1
Level: 1
Shortname: css-device-adapt
Group: CSSWG
Status: ED
Work Status: Exploring
TR: http://www.w3.org/TR/css-device-adapt-1/
ED: https://drafts.csswg.org/css-device-adapt/
Previous Version: http://www.w3.org/TR/2016/WD-css-device-adapt-1-20160329/
Editor: Florian Rivoal, Invited Expert, https://florian.rivoal.net, w3cid 43241
Editor: Matt Rakow, Microsoft, w3cid 62267
Former Editor: Rune Lillesveen, Opera Software, rune@opera.com
Former Editor: Ryan Betts, Adobe Systems, rbetts@adobe.com
Former Editor: Øyvind Stenhaug, Opera Software, oyvinds@opera.com
Abstract: This specification provides a way for an author to specify, in CSS, the size, zoom factor, and orientation of the viewport that is used as the base for the initial containing block.
Issue Tracking: Bugzilla https://www.w3.org/Bugs/Public/buglist.cgi?component=Device%20Adaptation&list_id=52675&product=CSS&resolution=---
Ignored Vars: <viewport-length>
</pre>


<h2 id="intro">
Introduction</h2>

<div class=non-normative>
<em>This section is not normative.</em>

CSS 2.1 [[!CSS21]] specifies an
<a href="https://www.w3.org/TR/CSS21/visudet.html#containing-block-details">
initial containing block</a> for [=continuous media=] that has the dimensions
of the <a href="https://www.w3.org/TR/CSS21/visuren.html#viewport">
viewport</a>. Since the viewport is generally no larger than the display,
devices with smaller displays such as phones or tablets typically present
a smaller viewport than larger devices like desktop or laptops.

Unfortunately, many documents have historically been designed against larger
viewports and exhibit a variety of bugs when viewed in smaller viewports.
These include unintended layout wrapping, clipped content, awkward scrollable
bounds, and script errors. To avoid these issues, mobile browsers generally
use a fixed initial containing block width that mimics common desktop browser
window size (typically 980-1024px). The resulting layout is then scaled down
to fit in the available screen space.

Although this approach mitigates the issues mentioned above, the downscaling
means the CSS pixel size will be smaller than
<a href="https://www.w3.org/TR/CSS21/syndata.html#length-units">recommended</a>
by CSS 2.1. Users will likely need to zoom on the content to view it
comfortably.

This mitigation is unnecessary for sites that have been designed to work
well on small viewports.  This specification describes the CSS
<code class=css>@viewport</code> rule which allows authors to control and
opt-out of this behavior.

Issue: This specification is written from an implementation-centric point of view,
making it arguably difficult to read.
Significant editorial work may be needed
to make it more understandable to different audiences.
It also should clarify which viewport is referred to by various js APIs.
See <a href="http://www.quirksmode.org/blog/archives/2015/09/a_new_device_ad.html">this blog post by ppk</a>
for a good discussion of these issues.

Issue: Various issues about this specification and related specifications
are listed in <a href="https://www.w3.org/Graphics/SVG/WG/wiki/Proposals/Investigation_of_APIs_for_Level_of_detail#The_issues_on_existing_APIs">this report</a>.
</div>

<h2 id="scenarios">
Motivating Scenarios</h2>

<div class="example">
    In this example, the document can be rendered without issue with any
    size viewport. The author indicates this using the
    <code class=css>@viewport</code> rule.

    <pre class="lang-html">
        &lt;!doctype html>
        &lt;html>
        &lt;head>
        &lt;title>My Site&lt;/title>
        &lt;style>
            @viewport { width: auto; }
        &lt;/style>
        &lt;/head>
        &lt;body>
            Since this document is just some simple text, it can be rendered
            at any width without issue.  The text will just re-wrap as needed
            when viewed in a smaller viewport.
        &lt;/body>
        &lt;/html>
    </pre>
</div>

<div class="example">
    In this example, the document can be rendered without issue for viewports
    down to 384px, but smaller sizes would clip the diagram. The author
    indicates this using the <code class=css>@viewport</code> rule in
    combination with a media query. When the viewport would be smaller than
    384px, the user agent will select 384px as the initial containing block
    size and scale the resulting layout down to fit the available space.

    <pre class="lang-html">
        &lt;!doctype html>
        &lt;html>
        &lt;head>
        &lt;style>
            @viewport { width: auto; }
            @media (max-width: 384px) {
                @viewport { width: 384px; }
            }
            body {
                margin: 0;
            }
            img {
                min-width: 384px;
            }
        &lt;/style>
        &lt;title>My Other Site&lt;/title>
        &lt;/head>
        &lt;body>
            &lt;img src="diagram.png">
        &lt;/body>
        &lt;/html>
    </pre>
</div>

<h2 id="values">
Values</h2>

This specification follows
the <a href="https://www.w3.org/TR/css3-syntax/#property-defs">CSS
property definition conventions</a> from [[!CSS3SYN]].

Value types are defined in [[!CSS3VAL]].


<h2 id="the-viewport">
The viewport</h2>

In CSS 2.1 a <a href="https://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
is a feature of a user agent for [=continuous media=] and used to
establish the initial containing block for [=continuous media=].
For [=paged media=], the initial containing block is based on the page area.
The page area can be set through ''@page'' rules.
Hence, ''@viewport'' applies to [=continuous media=],
and ''@page'' to [=paged media=],
and they will not interact or conflict.

This specification introduces a way of overriding the size of the viewport
provided by the user agent (UA). Because of this, we need to introduce the
difference between the ''initial viewport'' and the ''actual viewport''.

<dl>
    <dt><dfn>initial viewport</dfn></dt>
    <dd>
        This refers to the viewport before any UA or author styles have
        overridden the viewport given by the window or viewing area of the UA.
        Note that the ''initial viewport'' size will change with the
        size of the window or viewing area.</dd>
    <dt><dfn>actual viewport</dfn></dt>
    <dd>
        This is the viewport you get after the cascaded viewport descriptors,
        and the following <a href="#constraining-procedure">constraining procedure</a>
        have been applied.
    </dd>
</dl>

When the ''actual viewport'' cannot fit inside the window or
viewing area, either because the ''actual viewport'' is
larger than the ''initial viewport'' or the zoom factor
causes only parts of the ''actual viewport'' to be visible,
the UA should offer a scrolling or panning mechanism.

It is recommended that initially the upper-left corners of the
''actual viewport'' and the window or viewing area are aligned if the
base direction of the document is ltr. Similarly, that the upper-right
corners are aligned when the base direction is rtl. The base direction
for a document is defined as the computed value of the 'direction'
property for the first <code class=html>&lt;BODY&gt;</code> element of
an HTML or XHTML document. For other document types, it is the
computed 'direction' for the root element.

<p class=issue>"dbaron: The question is, what does this do on the desktop
browser? (And what's a desktop browser)". Need to say that a "desktop"
browser typically have no UA styles, as opposed to the
<a href="#ua-stylesheet">UA stylesheet</a> outlined for current mobile
behavior, and that no UA styles for ''@viewport'' will give "desktop"
behavior per default (actual viewport is initial viewport).</p>


<h2 id="atviewport-rule">
The <dfn at-rule>@viewport</dfn> rule</h2>

<div class=note>
<strong class="advisement">UA vendors implementing this specification
are strongly encouraged to do so both for their mobile and desktop browsers.
The ''@viewport'' mechanism is designed to be usable and useful
on all browsers, not only mobile ones.
However, if support is only available on mobile browsers for a significant time,
there is a risk that authors would write ''@viewport'' rules that work on mobile
but do the wrong if applied by a desktop browser.
This would make it difficult to later add support for ''@viewport'' in desktop browsers.</strong>
<p>An example of such misguided use would be to write <code highlight="css">@viewport { width: 320px; }</code>
instead of <code highlight="css">@viewport { width: auto; }</code>
to make a document “mobile friendly”.
</div>

The ''@viewport'' <a href="https://www.w3.org/TR/CSS21/syndata.html#at-rules">at-rule</a>
consists of the @-keyword followed by a block of descriptors
describing the viewport.

The descriptors inside an ''@viewport'' rule are per document and
there is no inheritance involved. Hence declarations using the
''inherit'' keyword will be dropped. They work similarly
to ''@page'' descriptors and follow the cascading order of CSS. Hence,
descriptors in ''@viewport'' rules will override descriptors from
preceding rules. The declarations allow !important which will affect
cascading of descriptors accordingly.

''@viewport'' rules apply to top level documents only.

<div class=example>
    This example sets the viewport to at least 320px, but otherwise match
    window width if it is wider than 320px. Note that it is enough to set
    the width as the height will be resolved from the width when auto.

    <pre>
        @viewport {
            width: 320px auto;
        }
    </pre>
</div>

<h3 id="syntax">
Syntax</h3>

The syntax for the ''@viewport'' rule is as follows (using the
notation from
the <a href="https://www.w3.org/TR/CSS21/grammar.html">Grammar
appendix</a> of CSS 2.1 [[!CSS21]]):

<pre>
    viewport
      : VIEWPORT_SYM S* '{' S* declaration? [ ';' S* declaration? ]* '}' S*
      ;
</pre>

with the new token:

<pre>@{V}{I}{E}{W}{P}{O}{R}{T} {return VIEWPORT_SYM;}</pre>

where:

<pre>
V    v|\\0{0,4}(56|76)(\r\n|[ \t\r\n\f])?|\\v
W    w|\\0{0,4}(57|77)(\r\n|[ \t\r\n\f])?|\\w
</pre>

The <code>viewport</code> non-terminal is added to the
<code>stylesheet</code> production along with the
<code>ruleset</code>, <code>media</code>, and <code>page</code>
non-terminals:

<pre>
    stylesheet
      : [ CHARSET_SYM STRING ';' ]?
        [S|CDO|CDC]* [ import [ CDO S* | CDC S* ]* ]*
        [ [ ruleset | media | page | viewport ] [ CDO S* | CDC S* ]* ]*
      ;
</pre>

It is also added to the <a spec="css-conditional">nested_statement</a> production defined in [[!CSS3-CONDITIONAL]]
to allow ''@viewport'' rules nested inside <a spec="css-conditional">conditional group rules</a>
such as ''@media'' or ''@supports'':

<pre>
    nested_statement
      : ruleset | media | page | font_face_rule | keyframes_rule |
        supports_rule | viewport
      ;
</pre>


<h2 id="viewport-desc">
Viewport descriptors</h2>

This section presents the descriptors that are allowed inside an
''@viewport'' rule. Other descriptors than those listed here will be
dropped.

Relative length values are resolved against initial values. For
instance 'em's are resolved against the initial value of the
'font-size' property. Viewport lengths (''vw'', ''vh'', ''vmin'',
''vmax'') are relative to the initial viewport.

<h3 id="min-max-width-desc">
The 'min-width' and 'max-width' descriptors</h3>

<p class="issue">min- and max- functionality can be achieved with media queries, should these be removed?</p>

<pre class=descdef>
Name: min-width
For: @viewport
Value: <<viewport-length>>
Initial: auto
Percentages: Refer to the width of the ''initial viewport''
Computed value: auto, an absolute length, or a percentage as specified
</pre>

<pre class=descdef>
Name: max-width
For: @viewport
Value: <<viewport-length>>
Initial: auto
Percentages: Refer to the width of the ''initial viewport''
Computed value: auto, an absolute length, or a percentage as specified
</pre>

Specifies the minimum and maximum width of
the <a href="https://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
that is used to set the size of
the <a href="https://www.w3.org/TR/CSS21/visudet.html#containing-block-details">
initial containing block</a> where

<pre class=prod><dfn><var>&lt;viewport-length&gt;</var></dfn> = auto | &lt;length&gt; | &lt;percentage&gt;</pre>

and the values have the following meanings:

<dl dfn-type=value dfn-for="viewport-length">
    <dt><dfn>auto</dfn></dt>
    <dd>
        The used value is calculated from the other descriptors'
        values according to the
        <a href="#constraining-procedure">constraining procedure</a>.
    </dd>

    <p class="issue">The user-agent stylesheets recommended in the informative section don't adequately represent current implementation behaviors.  Should there be a more explicit mechanism for switching between UA default behavior and requesting the CSS pixel?</p>

    <dt><dfn><<length>></dfn></dt>
    <dd>
        A non-negative absolute or relative length.
    </dd>

    <dt><dfn><<percentage>></dfn></dt>
    <dd>
        A percentage value relative to the width or height of the
        ''initial viewport'' at zoom factor 1.0, for horizontal
        and vertical lengths respectively. Must be non-negative.
    </dd>
</dl>

The 'min-width' and 'max-width' descriptors are inputs to the
<a href="#constraining-procedure">constraining procedure</a>. The
width will initially be set as close as possible to the ''initial
viewport'' width within the min/max constraints.

<h3 id="width-desc">
The 'width' shorthand descriptor</h3>

<pre class=descdef>
Name: width
For: @viewport
Value: <<viewport-length>>{1,2}
Initial: See individual descriptors
Percentages: See individual descriptors
Computed value: See individual descriptors
</pre>

This is a shorthand descriptor for setting both 'min-width' and
'max-width'. One <<viewport-length>> value will set both 'min-width'
and 'max-width' to that value. Two <<viewport-length>> values will
set 'min-width' to the first and 'max-width' to the second.

<h3 id="min-max-height-desc">
The 'min-height' and 'max-height' descriptors</h3>

<pre class=descdef>
Name: min-height
For: @viewport
Value: <<viewport-length>>
Initial: auto
Percentages: Refer to the height of the ''initial viewport''
Computed value: auto, an absolute length, or a percentage as specified
</pre>

<pre class=descdef>
Name: max-height
For: @viewport
Value: <<viewport-length>>
Initial: auto
Percentages: Refer to the height of the ''initial viewport''
Computed value: auto, an absolute length, or a percentage as specified
</pre>

Specifies the minimum and maximum height of the
<a href="https://www.w3.org/TR/CSS21/visuren.html#viewport">viewport</a>
that is used to set the size of the
<a href="https://www.w3.org/TR/CSS21/visudet.html#containing-block-details">
initial containing block</a>.

The min-height and max-height descriptors are inputs to
the <a href="#constraining-procedure">constraining procedure</a>.
The height will initially be set as close as possible to the ''initial
viewport'' height within the min/max constraints.

<h3 id="height-desc">
The 'height' shorthand descriptor</h3>

<pre class=descdef>
Name: height
For: @viewport
Value: <<viewport-length>>{1,2}
Initial: See individual descriptors
Percentages: See individual descriptors
Computed value: See individual descriptors
</pre>

This is a shorthand descriptor for setting both min-height and max-height.
One <<viewport-length>> value will set both min-height and max-height
to that value. Two <<viewport-length>> values will set min-height to
the first and max-height to the second.

<h3 id="zoom-desc">
The 'zoom' descriptor</h3>

<pre class=descdef>
Name: zoom
For: @viewport
Value: auto | <<number>> | <<percentage>>
Initial: auto
Percentages: The zoom factor itself
Computed value: auto, or a non-negative number or percentage as specified
</pre>

Specifies the initial zoom factor for the window or viewing area. This
is a magnifying glass type of zoom. Interactively changing the zoom
factor from the initial zoom factor does not affect the size of the
initial or the actual viewport.

Values have the following meanings:

<dl dfn-type=value dfn-for=zoom>
    <dt><dfn>auto</dfn></dt>
    <dd>
        The zoom factor is UA-dependent. The UA may use the size of the area
        of the canvas on which the document is rendered to find that initial
        zoom factor. See <a href="#handling-auto-zoom">this section</a> for a
        proposed way of handling ''zoom/auto'' values for 'zoom'.
    </dd>

    <dt><var><<number>></var></dt>
    <dd>
        A non-negative number used as a zoom factor. A factor of 1.0 means
        that no zooming is done. Values larger than 1.0 gives a zoomed-in
        effect and values smaller than 1.0 a zoomed-out effect.
    </dd>

    <dt><var><<percentage>></var></dt>
    <dd>
        A non-negative percentage value used as a zoom factor. A factor of
        100% means that no zooming is done. Values larger than 100% gives a
        zoomed-in effect and values smaller than 100% a zoomed-out effect.
    </dd>
</dl>

<h3 id="min-zoom-desc">
The 'min-zoom' descriptor</h3>

<pre class=descdef>
Name: min-zoom
For: @viewport
Value: auto | <<number>> | <<percentage>>
Initial: auto
Percentages: The zoom factor itself
Computed value: auto, or a non-negative number or percentage as specified
</pre>

Specifies the smallest allowed zoom factor. It is used as input to the
<a href="#constraining-procedure">constraining procedure</a> to constrain
non-''zoom/auto'' 'zoom' values, but also to limit the allowed zoom factor
that can be set through user interaction. The UA should also use this
value as a constraint when choosing an actual zoom factor when the
used value of 'zoom' is ''zoom/auto''.

Values have the following meanings:

<dl dfn-type=value dfn-for=min-zoom>
    <dt>auto</dt>
    <dd>
        The lower limit on zoom factor is UA dependent. There will be no minimum
        value constraint on the 'zoom' descriptor used in
        the <a href="#constraining-procedure">constraining
        procedure</a>
    </dd>

    <dt><var><<number>></var></dt>
    <dd>
        A non-negative number limiting the minimum value of the zoom factor.
    </dd>

    <dt><var><<percentage>></var></dt>
    <dd>
        A non-negative percentage limiting the minimum value of the zoom factor.
    </dd>
</dl>

<h3 id="max-zoom-desc">
The 'max-zoom' descriptor</h3>

<pre class=descdef>
Name: max-zoom
For: @viewport
Value: auto | <<number>> | <<percentage>>
Initial: auto
Percentages: The zoom factor itself
Computed value: auto, or a non-negative number or percentage as specified
</pre>

Specifies the largest allowed zoom factor. It is used as input to the
<a href="#constraining-procedure">constraining procedure</a> to constrain
non-''zoom/auto'' 'zoom' values, but also to limit the allowed zoom factor
that can be set through user interaction. The UA may choose to ignore
this limit for accessibility/usability reasons – see the relevant note in
the 'user-zoom' section. The UA should also use this
value as a constraint when choosing an actual zoom factor when the
used value of 'zoom' is ''zoom/auto''.

Values have the following meanings:

<dl dfn-type=value dfn-for=max-zoom>
    <dt>auto</dt>
    <dd>
        The upper limit on zoom factor is UA dependent. There will be
        no maximum value constraint on the 'zoom' descriptor used in
        the <a href="#constraining-procedure">constraining
        procedure</a>
    </dd>

    <dt><var><<number>></var></dt>
    <dd>
        A non-negative number limiting the maximum value of the zoom factor.
    </dd>

    <dt><var><<percentage>></var></dt>
    <dd>
        A non-negative percentage limiting the maximum value of the zoom factor.
    </dd>
</dl>

<h3 id="user-zoom-desc">
The 'user-zoom' descriptor</h3>

<pre class=descdef>
Name: user-zoom
For: @viewport
Value: zoom | fixed
Initial: zoom
Percentages: N/A
Computed value: as specified
</pre>

Specifies if the zoom factor can be changed by user interaction or not.

Values have the following meanings:

<dl dfn-type=value dfn-for=user-zoom>
    <dt><dfn>zoom</dfn></code></dt>
    <dd>
        The user can interactively change the zoom factor.
    </dd>
    <dt><dfn>fixed</dfn></dt>
    <dd>
        The user cannot interactively change the zoom factor.
    </dd>
</dl>

<div class="note">
    Authors should not suppress (with <code>user-zoom: fixed</code>)
    or limit (with <code>max-zoom</code>) the ability of users to resize
    a document, as this causes accessibility and usability issues.

    There may be specific use cases where preventing users from zooming
    may be appropriate, such as map applications – where custom zoom
    functionality is handled via scripting. However, in general this
    practice should be avoided.

    Most user agents now allow users to always zoom, regardless
    of any restrictions specified by web content – either by default, or
    as a setting/option (which may however not be immediately apparent
    to users).
</div>

<h3 id="orientation-desc">
The 'orientation' descriptor</h3>

<pre class=descdef>
Name: orientation
For: @viewport
Value: auto | portrait | landscape
Initial: auto
Percentages: N/A
Computed value: as specified
</pre>

This descriptor is used to request that a document is displayed in portrait
or landscape mode. For a UA/device where the orientation is changed upon
tilting the device, an author can use this descriptor to inhibit the
orientation change. The descriptor should be respected for
standalone web applications, and when the document is displayed
in fullscreen. It is recommended that it is ignored for normal
web navigation to avoid confusing the user.

Values have the following meanings:

<dl dfn-type=value dfn-for=orientation>
    <dt><dfn>auto</dfn></dt>
    <dd>
        The UA automatically chooses the orientation based on the device's
        normal mode of operation. The UA may choose to change the orientation
        of the presentation when the device is tilted.
    </dd>

    <dt><dfn>portrait</dfn></dt>
    <dd>
        The document should be locked to portrait presentation.
    </dd>

    <dt><dfn>landscape</dfn></dt>
    <dd>
        The document should be locked to landscape presentation.
    </dd>
</dl>


<h2 id="constraining">
Constraining viewport descriptor values</h2>

<h3 id="constraining-defs">
Definitions</h3>

For the procedure below:

Descriptors refer to the values resolved/constrained to at that point in
the procedure. They are initially resolved to their computed values.

<dfn><code>width</code></dfn> and <dfn><code>height</code></dfn> refer
to the resolved viewport size and not the shorthand descriptors. They
are both initially ''viewport-length/auto''.

<code>MIN/MAX</code> computations where one of the arguments is
''zoom/auto'' resolve to the other argument. For instance, <code>MIN(0.25,
''zoom/auto'') = 0.25</code>, and <code>MAX(5, ''zoom/auto'') = 5</code>.

<dfn><code>initial-width</code></dfn> is the width of the
''initial viewport'' in pixels at zoom factor 1.0.

<dfn><code>initial-height</code></dfn> is the height of the
''initial viewport'' in pixels at zoom factor 1.0.

<h3 id="constraining-procedure">
The procedure</h3>

The used values are resolved from the computed values going through
the steps below.

User agents are expected, but not required, to re-run this procedure
and re-layout the document, if necessary, in response to changes
in the user environment, for example if the device is tilted from
landscape to portrait mode or the window that forms the ''initial
viewport'' is resized.

However, Media Queries and Device Adaption are <dfn lt="Specifications
whose evaluations are both affected by the same changes to the user
environment, and so always must be evaluated together in order to
ensure proper rendering.">tethered specifications</dfn>. As a result,
UAs that also
support <a href="https://www.w3.org/TR/css3-mediaqueries/">Media Queries</a>
must re-run this procedure and re-layout the document in all cases
where changes in the user environment would cause them to re-evaluate
Media Queries.

<h4 id="constraining-min-max-zoom" class="no-num no-toc">
Resolve <code lt="min-zoom!!resolved">min-zoom</code>
and <code lt="max-zoom!!resolved">max-zoom</code> values</h4>

<ol>
    <li>
        If <code lt="min-zoom!!resolved">min-zoom</code> is not
        ''zoom/auto'' and <code lt="max-zoom!!resolved">max-zoom</code>
        is not ''zoom/auto'', set <code>max-zoom = MAX(min-zoom,
        max-zoom)</code>
    </li>
</ol>

<h4 id="constraining-zoom" class="no-num no-toc">
Constrain <code lt="zoom!!resolved">zoom</code> value to
the <code>[min-zoom, max-zoom]</code> range</h4>

<ol id="ol2">
    <li>
        If <code lt="zoom!!resolved">zoom</code> is not ''zoom/auto'',
        set <code>zoom = MAX(min-zoom, MIN(max-zoom,
        zoom))</code>
    </li>
</ol>

<h4 id="resolve-px" class="no-num no-toc">
Resolve non-''viewport-length/auto'' lengths to pixel lengths</h4>

<ol id="ol3">
    <li>
        Resolve absolute lengths and percentages to pixel values for the
        'min-width', 'max-width', 'min-height', and 'max-height'
        descriptors.
    </li>
</ol>

<h4 id="resolve-initial-width-height" class="no-num no-toc">
Resolve initial <code lt="width!!resolved">width</code>
and <code lt="height!!resolved">height</code> from min/max
descriptors</h4>

<ol id="ol4">
    <li>
        If <code lt="min-width!!resolved">min-width</code> or
        <code lt="max-width!!resolved">max-width</code> is not
        ''viewport-length/auto'', set <code>width = MAX(min-width, MIN(max-width,
        initial-width))</code>
    </li>

    <li>
        If <code lt="min-height!!resolved">min-height</code> or
        <code lt="max-height!!resolved">max-height</code> is not
        ''viewport-length/auto'', set <code>height = MAX(min-height, MIN(max-height,
        initial-height))</code>
    </li>
</ol>

<h4 id="resolve-width" class="no-num no-toc">
Resolve <code lt="width!!resolved">width</code> value</h4>

<ol id="ol6">
    <li>
        If <code lt="width!!resolved">width</code> and
        <code lt="height!!resolved">height</code> are both
        ''viewport-length/auto'', set <code>width = initial-width</code>
    </li>

    <li>
        Otherwise, if <code lt="width!!resolved">width</code> is
        ''viewport-length/auto'', set <code>width = height * (initial-width /
        initial-height)</code>, or <code>width = initial-width</code>
        if <code class="index"
        lt="height!!initial">initial-height</code> is 0.
    </li>
</ol>

<h4 id="resolve-height" class="no-num no-toc">
Resolve <code lt="height!!resolved">height</code> value</h4>

<ol id="ol8">
    <li>
        If <code lt="height!!resolved">height</code> is ''viewport-length/auto'',
        set <code>height = width * (initial-height /
        initial-width)</code>, or <code>height = initial-height</code>
        if <code class="index"
        lt="width!!initial">initial-width</code> is 0.
    </li>
</ol>


<h2 id="media-queries">
Media Queries</h2>

For several media features, the size of the initial containing block and
the orientation of the device affects the result of a media query
evaluation, which means that the effect of ''@viewport'' rules on
media queries needs extra attention.

From the Media Queries specification [[!MEDIAQ]]:

<blockquote>
    <p>
        &ldquo;To avoid circular dependencies, it is never necessary
        to apply the style sheet in order to evaluate expressions. For example,
        the aspect ratio of a printed document may be influenced by a style sheet,
        but expressions involving 'device-aspect-ratio' will be based
        on the default aspect ratio of the user agent.&rdquo;
    </p>
</blockquote>

The UA must however cascade ''@viewport'' rules separately with the
''initial viewport'' size used for evaluating media feature
expressions and other values that depend on the viewport size to avoid
circular dependencies, but use the actual viewport size when cascading all other rules.

Procedure for applying CSS rules:

<ol>
    <li>
        Cascade all ''@viewport'' rules using the ''initial viewport''
        size for values and evaluations which rely on viewport size
    </li>
    <li>
        Compute the ''actual viewport'' from the cascaded viewport
        descriptors
    </li>
    <li>
        Cascade all other rules using the ''actual viewport'' size
    </li>
</ol>

<p class="note">
    The rationale for using the viewport descriptors obtained from applying
    the ''@viewport'' rules for evaluating media queries for style
    rules, is that media queries should match the ''actual viewport''
    that the document will be laid out in and not the initial or the
    one specified in the UA stylesheet. Consider the example below
    given that the UA stylesheet has a viewport width of 980px, but an
    ''initial viewport'' width of 320px. The author has made separate
    styles to make the document look good for initial containing block
    widths above or below 400px. The ''actual viewport'' used will be
    320px wide, and in order to match the styles with the ''actual
    viewport'' width, the viewport resulting from applying the
    ''@viewport'' rules should be used to evaluate the media queries.
</p>

<div class="example">
    Given an initial viewport width of 320px and a UA stylesheet viewport
    width of 980px, the first media query will not match, but the second will.

    <pre>
        @viewport {
            width: auto;
        }

        @media screen and (min-width: 400px) {
            div { color: red; }
        }

        @media screen and (max-width: 400px) {
            div { color: green; }
        }
    </pre>
</div>

Another example:

<div class="example">
    The media query below should match because the ''@viewport'' rule
    is applied before the media query is evaluated.

    <pre>
        @media screen and (width: 397px) {
            div { color: green; }
        }

        @viewport {
            width: 397px;
        }
    </pre>
</div>

Below is an example where an ''@viewport'' rule relies on a media
query affected by the viewport descriptors.

<div class="example">
    The green color should be applied to a div because the
    ''initial viewport'' width is used to evaluate the media query
    for the second ''@viewport'' rule, but the ''actual viewport''
    is used for evaluating the media query when applying style rules.

    <pre>
        @viewport {
            width: 397px;
        }

        @media screen and (width: 397px) {
            @viewport {
                width: 500px;
            }
        }

        @media screen and (width: 397px) {
            div { color: green; }
        }
    </pre>
</div>

It is recommended that authors do not write ''@viewport'' rules that
rely on media queries whose evaluation is affected by viewport
descriptors. It is also recommended that the ''@viewport'' rule(s) is
placed as early in the document as possible to avoid unnecessary
re-evaluation of media queries or reflows.


<h2 id="cssom">
CSSOM</h2>

The ''@viewport'' rule is exposed to the CSSOM through a new CSSRule
interface.

<h3 id="css-rule-interface">
Interface <code>CSSRule</code></h3>

The following rule type is added to the <code>CSSRule</code>
interface. It provides identification for the new viewport rule.

<pre class=idl>
partial interface CSSRule {
    const unsigned short VIEWPORT_RULE = 15;
};
</pre>

<h3 id="css-viewport-rule-interface">
Interface <code>CSSViewportRule</code></h3>

The <dfn interface>CSSViewportRule</dfn> interface represents the
style rule for an ''@viewport'' rule.

<pre class=idl>
[Exposed=Window]
interface CSSViewportRule : CSSRule {
    readonly attribute CSSStyleDeclaration style;
};
</pre>

<dl dfn-type=attribute dfn-for=CSSViewportRule>
    <dt><dfn>style</dfn> <span attribute-info for=style></span></dt>
    <dd>
        This attribute represents the viewport descriptors associated
        with this ''@viewport'' rule.
    </dd>
</dl>

<h2 id="viewport-meta">
Viewport <code class=html>&lt;META&gt;</code> element</h2>

<em>This section is not normative.</em>

This section describes a mapping from the content attribute of the
viewport <code class=html>&lt;META&gt;</code> element, first
implemented by Apple in the iPhone Safari browser, to the descriptors
of the ''@viewport'' rule described in this
specification.

In order to match the Safari implementation, the following parsing
algorithm and translation rules rely on the UA stylesheet below. See the
section on <a href="#ua-stylesheet">UA stylesheets</a> for an elaborate
description.

<pre>
@viewport {
    width: extend-to-zoom 980px;
    min-zoom: 0.25;
    max-zoom: 5;
}
</pre>

<p class="note">
    Note that these values might not fit well with all UAs. For
    instance, with a min-zoom of 0.25 you will be able to fit the whole width
    of the document inside the window for widths up to 1280px on a 320px wide
    device like the original iPhone, but only 960px if you have a 240px
    display (all widths being given in CSS pixel units).
</p>

<h3 id="meta-properties">
Properties</h3>

The recognized properties in the viewport
<code class=html>&lt;META&gt;</code> element are:

<ul>
    <li><code class="index" lt="width!!viewport META">width</code></li>
    <li><code class="index" lt="height!!viewport META">height</code></li>
    <li><code class="index">initial-scale</code></li>
    <li><code class="index">minimum-scale</code></li>
    <li><code class="index">maximum-scale</code></li>
    <li><code class="index">user-scalable</code></li>
</ul>

<h3 id="parsing-algorithm">
Parsing algorithm</h3>

Below is an algorithm for parsing the <code class=html>content</code>
attribute of the <code class=html>&lt;META&gt;</code> tag produced
from testing Safari on the iPhone. <span class="note"> The testing was
done on an iPod touch running iPhone OS 4. The UA string of the
browser: <code>"Mozilla/5.0 (iPod; U; CPU iPhone OS 4_0 like Mac OS X;
en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5
Mobile/8A293 Safari/6531.22.7"</code>.</span> The pseudo code notation
used is based on the notation used in [[Algorithms]].

The whitespace class contains the following characters (ascii):

<ul>
    <li>Horizontal tab (0x09)</li>
    <li>Line feed (0x0a)</li>
    <li>Carriage return (0x0d)</li>
    <li>Space (0x20)</li>
</ul>

The recognized separator between property/value pairs is comma for the
Safari implementation. Some implementations have supported both commas
and semicolons. Because of that, existing content use semicolons instead
of commas. Authors should be using comma in order to ensure content works
as expected in all UAs, but implementors may add support for both to ensure
interoperability for existing content.

The separator class contains the following characters (ascii), with
comma as the preferred separator and semicolon as optional:

<ul>
    <li>Comma (0x2c)</li>
    <li>Semicolon (0x3b)</li>
</ul>

<style>
    /* Style for algorithm pseudo code. */

    #algorithm {
        font-family: serif;
        font-size: 1em;
        white-space: pre;
        margin: 1em;
        padding: 1em;
    }

    #algorithm .method {
        counter-reset: statement;
        line-height: 1.5em;
    }

    #algorithm .method-name {
        font-variant: small-caps;
    }

    #algorithm .statement {
        counter-increment: statement;
    }

    #algorithm .statement:before {
        content: counter(statement) "   ";
        display: inline-block;
        width: 2em;
    }

    #algorithm .keyword {
        font-weight: bold;
    }
</style>

<pre id="algorithm">
    <span class="method"><span class="method-name">Parse-Content</span>(<span class="variable">S</span>)</span>
    <span class="statement"><span class="variable">i</span> &larr; 1</span>
    <span class="statement"><span class="keyword">while</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>]</span>
    <span class="statement">    <span class="keyword">do</span> <span class="keyword">while</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>] and <span class="variable">S</span>[<span class="variable">i</span>] in [whitespace, separator, '=']</span>
    <span class="statement">        <span class="keyword">do</span> <span class="variable">i</span> &larr; <span class="variable">i</span> + 1</span>
    <span class="statement">    <span class="keyword">if</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>]</span>
    <span class="statement">        <span class="keyword">then</span> <span class="variable">i</span> &larr; <span class="method-name">Parse-Property</span>(<span class="variable">S</span>, <span class="variable">i</span>)</span>

    <span class="method"><span class="method-name">Parse-Property</span>(<span class="variable">S</span>, <span class="variable">i</span>)</span>
    <span class="statement"><span class="variable">start</span> &larr; <span class="variable">i</span></span>
    <span class="statement"><span class="keyword">while</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>] and <span class="variable">S</span>[<span class="variable">i</span>] <span class="keyword">not</span> in [whitespace, separator, '=']</span>
    <span class="statement">    <span class="keyword">do</span> <span class="variable">i</span> &larr; <span class="variable">i</span> + 1</span>
    <span class="statement"><span class="keyword">if</span> <span class="variable">i</span> &gt; <span class="op">length</span>[<span class="variable">S</span>] or <span class="variable">S</span>[<span class="variable">i</span>] in [separator]</span>
    <span class="statement">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="variable">i</span></span>
    <span class="statement"><span class="variable">property-name</span> &larr; <span class="variable">S</span>[<span class="variable">start</span> .. (<span class="variable">i</span> - 1)]</span>
    <span class="statement"><span class="keyword">while</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>] and <span class="variable">S</span>[<span class="variable">i</span>] <span class="keyword">not</span> in [separator, '=']</span>
    <span class="statement">    <span class="keyword">do</span> <span class="variable">i</span> &larr; <span class="variable">i</span> + 1</span>
    <span class="statement"><span class="keyword">if</span> <span class="variable">i</span> &gt; <span class="op">length</span>[<span class="variable">S</span>] or <span class="variable">S</span>[<span class="variable">i</span>] in [separator]</span>
    <span class="statement">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="variable">i</span></span>
    <span class="statement"><span class="keyword">while</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>] and <span class="variable">S</span>[<span class="variable">i</span>] in [whitespace, '=']</span>
    <span class="statement">    <span class="keyword">do</span> <span class="variable">i</span> &larr; <span class="variable">i</span> + 1</span>
    <span class="statement"><span class="keyword">if</span> <span class="variable">i</span> &gt; <span class="op">length</span>[<span class="variable">S</span>] or <span class="variable">S</span>[<span class="variable">i</span>] in [separator]</span>
    <span class="statement">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="variable">i</span></span>
    <span class="statement"><span class="variable">start</span> &larr; <span class="variable">i</span></span>
    <span class="statement"><span class="keyword">while</span> <span class="variable">i</span> &le; <span class="op">length</span>[<span class="variable">S</span>] and <span class="variable">S</span>[<span class="variable">i</span>] <span class="keyword">not</span> in [whitespace, separator, '=']</span>
    <span class="statement">    <span class="keyword">do</span> <span class="variable">i</span> &larr; <span class="variable">i</span> + 1</span>
    <span class="statement"><span class="variable">property-value</span> &larr; <span class="variable">S</span>[<span class="variable">start</span> .. (<span class="variable">i</span> - 1)]</span>
    <span class="statement"><span class="method-name">Set-Property</span>(<span class="variable">property-name</span>, <span class="variable">property-value</span>)</span>
    <span class="statement"><span class="keyword">return</span> <span class="variable">i</span></span>
</pre>

<span class="method-name">Set-Property</span> matches the
<a href="#meta-properties">listed property names</a> case-insensitively.
The <code class="variable">property-value</code> strings are interpreted
as follows:

<ol>
    <li>
        If a prefix of <code class="variable">property-value</code>
        can be converted to a number using <code>strtod</code>, the
        value will be that number. The remainder of the string is
        ignored.
    </li>
    <li>
        If the value can not be converted to a number as described above,
        the whole <code class="variable">property-value</code> string
        will be matched with the following strings
        case-insensitively: <code class="index">yes</code>,
        <code class="index">no</code>, <code class="index" lt="device-width!!viewport META">device-width</code>,
        <code  class="index" lt="device-height!!viewport META">device-height</code>
    </li>
    <li>
        If the string did not match any of the known strings, the
        value is unknown.
    </li>
</ol>

<h3 id="extend-to-zoom">''extend-to-zoom''</h3>

In order to be able to implement the functionality from
<code class=html>&lt;META&gt;</code> viewport where the viewport width
or height is extended to fill the viewing area at a given zoom level,
we introduce a UA internal value to the list of <<viewport-length>>
values called ''extend-to-zoom''. It will be used in width and height
declarations in the translation outlined in the section below.

This new value is necessary in order to implement the mapping for two
reasons. First, whether resolving the width/height needs to extend the
pixel length to the visible width/height for a given zoom factor depends
on the current initial width/height.
<code class=html>&lt;meta name="viewport" content="width=400, initial-scale=1"&gt;</code>
yields a width of 400px for an initial-width of 320px, and 640px for an
initial width of 640px. This can not be expressed as normative min/max
descriptors that would constrain correctly when the initial width changes
like for an orientation change.

Secondly, the extended width/height also relies on cascading viewport
properties from different sources, including 'min-zoom' and 'max-zoom'
from the UA stylesheet. For instance, if the UA stylesheet
has <code>max-zoom: 5</code>, and the initial width is 320px,
<code class=html>&lt;meta name="viewport" content="width=10"&gt;</code>
will resolve to 64px.

<h4 id="resolve-extend-to-zoom" class="no-num no-toc">
Resolving '<code class="css" lt="extend-to-zoom">extend-to-zoom</code>'</h4>

The '<code class="css" lt="extend-to-zoom">extend-to-zoom</code>'
value is resolved to pixel or auto lengths as part of
<a href="#resolve-px">step 3</a> of the
<a href="#constraining-procedure">constraining procedure</a>. Since this
is a <em>non-normative</em> descriptor value, the resolution is described
here. Note that max-descriptors need to be resolved to pixel lengths
<em>before</em> min-descriptors when
'<code class="css" lt="extend-to-zoom">extend-to-zoom</code>'
is a valid value.

Let <code>extend-zoom = MIN(zoom, max-zoom)</code>

For non-''zoom/auto'' <code>extend-zoom</code>, let:

<pre>
    extend-width = initial-width / extend-zoom
    extend-height = initial-height / extend-zoom
</pre>

Then, resolve for ''extend-to-zoom'' as follows:

<ul>
    <li>If <code>extend-zoom</code> is ''zoom/auto'':
        <ol>
            <li>
                If <code lt="max-width!!resolved">max-width</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>max-width = ''viewport-length/auto''</code>
            </li>
            <li>
                If <code lt="max-height!!resolved">max-height</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>max-height = ''viewport-length/auto''</code>
            </li>
            <li>
                If <code lt="min-width!!resolved">min-width</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>min-width = max-width</code>
            </li>
            <li>
                If <code lt="min-height!!resolved">min-height</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>min-height = max-height</code>
            </li>
        </ol>
    </li>

    <li>
        If <code>extend-zoom</code> is non-''zoom/auto'':
        <ol>
            <li>
                If <code lt="max-width!!resolved">max-width</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>max-width = extend-width</code>
            </li>
            <li>
                If <code lt="max-height!!resolved">max-height</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>max-height = extend-height</code>
            </li>
            <li>
                If <code lt="min-width!!resolved">min-width</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>min-width = MAX(extend-width, max-width)</code>
            </li>
            <li>
                If <code lt="min-height!!resolved">min-height</code> is
                '<code class="css">extend-to-zoom</code>', set
                <code>min-height = MAX(extend-height, max-height)</code>
            </li>
        </ol>
    </li>
</ul>

<h3 id="translate-meta-to-at-viewport">
Translation into ''@viewport'' descriptors</h3>

The Viewport <code class=html>&lt;META&gt;</code> element is placed
in the cascade as if it was a <code class=html>&lt;STYLE&gt;</code> element,
in the exact same place in the dom, that only contains a single
''@viewport'' rule.

Each of the property/value pair from the parsing in the
previous section are translated, and added to that single at-rule
as follows:

<h4 id="unknown-properties" class="no-num no-toc">
Unknown properties</h4>

Unknown properties are dropped.

<h4 id="width-and-height-properties" class="no-num no-toc">
The <code class="index" lt="width!!viewport META">width</code>
and <code class="index" lt="height!!viewport META">height</code>
properties</h4>

The <code class="index" lt="width!!viewport META">width</code> and
<code class="index" lt="height!!viewport META">height</code>
viewport <code class=html>&lt;META&gt;</code> properties are
translated into 'width' and 'height' descriptors, setting the
'min-width'/'min-height' value to ''extend-to-zoom'' and the
'max-width'/'max-height' value to the  length from the
viewport <code class=html>&lt;META&gt;</code> property as follows:

<ol>
    <li>
        Non-negative number values are translated to pixel lengths, clamped to
        the range: <code>[1px, 10000px]</code>
    </li>
    <li>
        Negative number values are dropped
    </li>
    <li>
        <code class="index" lt="device-width!!viewport META">device-width</code>
        and <code class="index" lt="device-height!!viewport META">device-height</code>
        translate to 100vw and 100vh respectively
    </li>
    <li>
        Other keywords and unknown values translate to 1px
    </li>
</ol>

<p class="note">
    Some existing UA implementations use device dimensions in CSS
    pixels, and some use the window dimensions (CSS pixels) for device-width /
    device-height. Above, we translate to 100vw / 100vh which are the window
    dimensions. The rationale is that the device dimensions would not be what
    the author intended for UAs where the window is resizable or does not fill
    the screen of the device.
</p>

<div class="example">

    This <code class=html>&lt;META&gt;</code> element:

    <pre>
        &lt;meta name="viewport" content="width=500, height=600"&gt;
    </pre>

    translates into:

    <pre>
        @viewport {
            width: extend-to-zoom 500px;
            height: extend-to-zoom 600px;
        }
    </pre>
</div>

For a viewport <code class=html>&lt;META&gt;</code> element that
translates into an ''@viewport'' rule with a non-''zoom/auto'' 'zoom'
declaration and no 'width' declaration:

<ul>
    <li>
        If it adds a '<code class="descriptor">height</code>'
        descriptor, add: <pre>width: auto;</pre>
      </li>
      <li>
          Otherwise, add: <pre>width: extend-to-zoom;</pre>
      </li>
</ul>

to the ''@viewport'' rule.

<div class="example">
    This <code class=html>&lt;META&gt;</code> element:

    <pre>
        &lt;meta name="viewport" content="initial-scale=1.0"&gt;
    </pre>

    translates into:

    <pre>
        @viewport {
            zoom: 1.0;
            width: extend-to-zoom;
        }
    </pre>
</div>

<div class="example">
    This <code class=html>&lt;META&gt;</code> element:

    <pre>
        &lt;meta name="viewport" content="initial-scale=2.0,
        height=device-width"&gt;
    </pre>

    translates into:

    <pre>
        @viewport {
            zoom: 2.0;
            width: auto;
            height: extend-to-zoom 100%;
        }
    </pre>
</div>

<h4 id="min-scale-max-scale" class="no-num no-toc">
The <code class="index">initial-scale</code>, <code class="index">minimum-scale</code>, and <code class="index">maximum-scale</code> properties</h4>

The properties are translated into
'<code class="descriptor" lt="zoom!!descriptor">zoom</code>',
'<code class="descriptor">min-zoom</code>',
and '<code class="descriptor">max-zoom</code>'
respectively with the following translations of values.

<ol>
    <li>
        Non-negative number values are translated to &lt;number&gt; values,
        clamped to the range <code>[0.1, 10]</code>
    </li>
    <li>
        Negative number values are dropped
    </li>
    <li>
        <code class="index">yes</code> is translated to 1
    </li>
    <li>
        <code class="index" lt="device-width!!viewport META">device-width</code>
        and <code class="index" lt="device-height!!viewport META">device-height</code>
        are translated to 10
    </li>
    <li>
        <code class="index">no</code> and unknown values are
        translated to 0.1
    </li>
</ol>

For a viewport <code class=html>&lt;META&gt;</code> element that translates
into an ''@viewport'' rule with no 'max-zoom' declaration and a
non-auto 'min-zoom' value that is larger than the 'max-zoom' value of
the UA stylesheet, the 'min-zoom' declaration value is clamped to the
UA stylesheet 'max-zoom' value.

<h4 id="user-scalable" class="no-num no-toc">
The <code class="index">user-scalable</code> property</h4>

The <code class="index">user-scalable</code> property is translated into
'user-zoom' with the following value translations.

<ol>
    <li>
        <code class="index">yes</code> and <code class="index">no</code> are
        translated into ''zoom'' and ''fixed'' respectively.
    </li>
    <li>
        Numbers &ge; 1, numbers &le; -1, <code class="index"
        lt="device-width!!viewport META">device-width</code>
        and <code class="index" lt="device-height!!viewport
        META">device-height</code> are mapped to ''zoom''
    </li>
    <li>
        Numbers in the range <code>&lt;-1, 1&gt;</code>, and unknown values,
        are mapped to ''fixed''
    </li>
</ol>

<div class="example">
    This <code class=html>&lt;META&gt;</code> element:

    <pre>
        &lt;meta name="viewport" content="width=480, initial-scale=2.0, user-scalable=1"&gt;
    </pre>

    will translate into this ''@viewport'' block:

    <pre>
        @viewport {
            width: 480px;
            zoom: 2.0;
            user-zoom: zoom;
        }
    </pre>
</div>

<h2 id="handling-auto-zoom">
Handling ''zoom/auto'' for 'zoom'</h2>

<em>This section is not normative.</em>

This section presents one way of picking an actual value for the
'zoom' descriptor when the used value is ''zoom/auto''.

Given an ''initial viewport'' with size <code>(initial-width,
initial-height)</code>, and a finite region within the
<a href="https://www.w3.org/TR/CSS21/intro.html#canvas">canvas</a>
where the formatting structure is rendered <code>(rendered-width,
rendered-height)</code>. That region is at least as large as the
''actual viewport''.

Then, if the used value of 'zoom' is ''zoom/auto'', let the actual zoom factor be:

<pre>
    zoom = MAX(initial-width / rendered-width, initial-height / rendered-height)
</pre>

The actual zoom factor should also be further limited by the
[min-zoom, max-zoom] range.

<h2 id="ua-stylesheet">
UA stylesheets</h2>

<em>This section is informative</em>

Traditional user agents, used mostly on desktop and laptop computers, can
easily be resized to fit most websites inside the initial viewport without
breaking the layout. Using the recommendations below, sites not adding any
''@viewport'' rules themselves will continue to look and function like
they always have.

<h3 id="large-screen-ua">
Large screen UA styles</h3>

If a user agent has an initial viewport size large enough to fit common documents without breaking the layout,
or which can easily to resized to do so,
the recommendation is to have <em>no</em> UA styles.
That means that it will have all descriptors initially set to ''viewport-length/auto'',
and behave as it would have without support for viewport descriptors.

If a user agent supports changing orientation,
and the landscape mode's size fits common documents as described above
but the portrait mode's size does not,
it is recommended to set a minimum layout width
equal to that of the width in landscape mode.

<div class="example">
    <pre>
        @viewport {
            min-width: 1024px;
        }
    </pre>
</div>

<h3 id="small-screen-ua">
Small screen UA styles</h3>

For smaller screen UAs, the UA could set the minimum viewport width to
typically used as an initial viewport width of a traditional user
agent (as described above).

<div class="example">
    <pre>
        @viewport {
            min-width: 980px;
        }
    </pre>
</div>

It is recommended that limitations in zooming capabilities are not
reflected in the UA styles but rather only affect the used values for
zoom. The min-zoom/max-zoom UA styles mentioned in
the <a href="#viewport-meta">Viewport META section</a> are there to
give an accurate description of how the Safari browser behaves, not as
part of a recommended UA stylesheet.

<pre class=biblio>
{
    "Algorithms": {
        "authors": [
            "Thomas H. Cormen; et al"
        ],
        "title": "Introduction to Algorithms, Second Edition, MIT Press",
        "publisher": "MIT Press"
    }
}
</pre>

<h2 class="no-num" id="changes">Appendix A. Changes</h2>

This appendix is <em>informative</em>.

This appendix describes changes from the
<a href="https://www.w3.org/TR/2011/WD-css-device-adapt-20110915/">15 September 2011 First Public Working Draft</a>.

<ul>
	<li>Made various editorial improvements and clarifications.
	<li>Added <a href="#cssom">OM Interfaces</a>.
	<li>Added semi-colon as separator in meta viewport.
	<li>Created <a href="#ua-stylesheet">UA stylesheets section</a>.
	<li>Added recommendation for when to respect orientation property.
	<li>Dropped support for the resolution descriptor.
	<li>Decouple width/height and zoom, introducing ''extend-to-zoom'' value for meta viewport translation.
	<li>Made normative rules about interaction of @viewport and @media.
	<li>Allow 0 for <<viewport-length>> and '@viewport/zoom' values
	<li>Removed support for device-width/height.
	<li>Apply @viewport to top level document only.
	<li>Extend [[!CSS3-CONDITIONAL]] rather than CSS21 for nesting in @media.
</ul>
