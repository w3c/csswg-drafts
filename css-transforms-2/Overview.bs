<pre class='metadata'>
Title: CSS Transforms Module Level 2
Shortname: css-transforms
Level: 2
Status: ED
!Delta Spec: yes
Work Status: Exploring
Group: csswg
ED: https://drafts.csswg.org/css-transforms-2/
TR: https://www.w3.org/TR/css-transforms-2/
Previous Version: https://www.w3.org/TR/2021/WD-css-transforms-2-20211109/
Editor: Tab Atkins Jr., Google https://www.google.com, https://xanthir.com/contact/, w3cid 42199
Editor: L. David Baron, Google https://www.google.com, https://dbaron.org/, w3cid 15393
Editor: Simon Fraser, Apple Inc https://www.apple.com/, simon.fraser@apple.com, w3cid 44066
Editor: Dean Jackson, Apple Inc https://www.apple.com/, dino@apple.com, w3cid 42080
Editor: Theresa O'Connor, Apple Inc http://www.apple.com/, eoconnor@apple.com, w3cid 40614
Abstract: CSS transforms allows elements styled with CSS to be transformed in two-dimensional or three-dimensional space.
Abstract:
Abstract: This spec adds new transform functions and properties for three-dimensional transforms, and convenience functions for simple transforms.
Ignored Terms: SVG data types
</pre>

<!-- TODO: Figure out what was *intended* by the <a>SVG data types</a> link, update it to point to that.  See #6768. -->

<pre class="link-defaults">
spec:css-transforms-1;
	type:property;
		text:transform
		text:transform-origin
	type:dfn;
		text: transformation matrix
		text: transformable element
		text: transformed element
		text: 2d matrix
		text: reference box
	type: type;
		text: <transform-list>
	type: function;
		text: matrix()
spec:css2;
	type: dfn;
		text: stacking context
spec: infra
	type:dfn;
		text: list
spec: filter-effects-1; type:property; text:filter;
spec: html; type: element; text: a;
</pre>

<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$']],
    displayMath: [['$$', '$$']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script src="mathjax/es5/tex-svg.js"></script>

Introduction {#intro}
=====================

This specification is a delta spec that extends [[!css-transforms-1]] to allow authors to transform elements in three-dimensional space.
New transform functions for the 'transform' property allow three-dimensional transforms,
and additional properties make working with three-dimensional transforms easier,
and allow the author to control how nested three-dimensional transformed elements interact.

1. The 'perspective' property allows the author to provide child elements with an extra perspective transformation. The 'perspective-origin' property provides control over the origin at which perspective is applied, effectively changing the location of the "vanishing point".

2. The 'transform-style' property allows 3D-transformed elements and their 3D-transformed descendants to share a common three-dimensional space, allowing the construction of hierarchies of three-dimensional objects.

3. The 'backface-visibility' property comes into play when an element is flipped around via three-dimensional transforms such that its reverse side is visible to the viewer. In some situations it is desirable to hide the element in this situation, which is possible using the value of ''backface-visibility/hidden'' for this property.

Note: While some values of the 'transform' property allow an element to be transformed in a three-dimensional coordinate system, the elements themselves are not three-dimensional objects. Instead, they exist on a two-dimensional plane (a flat surface) and have no depth.

This specification also adds three convenience properties, 'scale', 'translate' and 'rotate', that make it easier to describe and animate simple transforms.


Module Interactions {#module-interactions}
------------------------------------------

The <a>3D transform functions</a> here extend the set of functions for the 'transform' property.

Some values of 'perspective', 'transform-style' and 'backface-visibility' result in the creation of a [=containing block for all descendants=], and/or the creation of a <a>stacking context</a>.

Three-dimensional transforms affect the visual layering of elements, and thus override the back-to-front painting order described in <a href="https://www.w3.org/TR/CSS2/zindex.html">Appendix E</a> of [[!CSS21]].


Value Definitions {#values}
-----------------

This specification follows the <a href="https://www.w3.org/TR/CSS2/about.html#property-defs">CSS property definition conventions</a> from [[!CSS21]]
using the <a href="https://www.w3.org/TR/css-values-3/#value-defs">value definition syntax</a> from [[!CSS-VALUES-3]].
Value types not defined in this specification are defined in CSS Values &amp; Units [[!CSS-VALUES-3]].
Combination with other CSS modules may expand the definitions of these value types.

In addition to the property-specific values listed in their definitions,
all properties defined in this specification
also accept the <a>CSS-wide keywords</a> as their property value.
For readability they have not been repeated explicitly.

Terminology {#terminology}
==========================

: <dfn>3D transformed element</dfn>
:: An element whose computed value for the 'transform' property includes one of the <a>3D transform functions</a>

: <dfn>3D matrix</dfn>
:: A 4x4 matrix which does not fulfill the requirements of an [=2D matrix=].

: <dfn>identity transform function</dfn>
:: In addition to the identity transform function in CSS Transforms,
	examples for identity transform functions include
	''translate3d(0, 0, 0)'',
	''translateZ(0)'',
	''scaleZ(1)'',
	''rotate3d(1, 1, 1, 0)'',
	''rotateX(0)'',
	''rotateY(0)'',
	''rotateZ(0)''
	and ''matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)''.
	A special case is perspective: ''perspective(none)''.
	The value of m<sub>34</sub> becomes infinitesimal small
	and the transform function is therefore assumed to be equal to the identity matrix.

: <dfn>perspective matrix</dfn>
:: A matrix computed from the values of the 'perspective' and 'perspective-origin' properties as described <a href="#perspective-matrix-computation">below</a>.

: <dfn>accumulated 3D transformation matrix</dfn>
:: A matrix computed for an element relative to the root of its <a>3D rendering context</a>, as described <a href="#accumulated-3d-transformation-matrix-computation">below</a>.

: <dfn>3D rendering context</dfn>
:: A set of elements with a common ancestor which share a common three-dimensional coordinate system, as described <a href="#3d-rendering-contexts">below</a>.


Serialization of the <a>computed value</a> of <<transform-list>> {#serialization-of-the-computed-value}
----------------------------------------------------------------

A <<transform-list>> for the <a>computed value</a> is serialized to either one <<matrix()>> or one <<matrix3d()>> function by the following algorithm:

<ol class="algorithm">
	1. Let <var>transform</var> be a 4x4 matrix initialized to the identity matrix. The elements <var ignore> m11</var>, <var ignore>m22</var>, <var ignore>m33</var> and <var ignore>m44</var> of <var>transform</var> must be set to ''1'' all other elements of <var>transform</var> must be set to ''0''.
	2. Post-multiply all <<transform-function>>s in <<transform-list>> to <var>transform</var>.
	3. Chose between <<matrix()>> or <<matrix3d()>> serialization:
		<dl class="switch">
			<dt>If <var>transform</var> is a <a>2D matrix</a>
			<dd>Serialize <var>transform</var> to a <<matrix()>> function.
			<dt>Otherwise
			<dd>Serialize <var>transform</var> to a <<matrix3d()>> function.
		</dl>
</ol>

Issue: fix this text to add to the text in CSS Transforms 1.

Two Dimensional Subset {#two-dimensional-subset}
================================================

UAs may not always be able to render three-dimensional transforms and then just support a two-dimensional subset of this specification. In this case <a href="#three-d-transform-functions">three-dimensional transforms</a> and the properties 'transform-style', 'perspective', 'perspective-origin' and 'backface-visibility' must not be supported. Section <a href="#3d-transform-rendering">3D Transform Rendering</a> does not apply. Matrix decomposing uses the technique taken from the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", simplified for the 2D case. Section <a href="#mathematical-description">Mathematical Description of Transform Functions</a> is still effective but can be reduced by using a 3x3 transformation matrix where <em>a</em> equals m<sub>11</sub>, <em>b</em> equals m<sub>12</sub>, <em>c</em> equals m<sub>21</sub>, <em>d</em> equals m<sub>22</sub>, <em>e</em> equals m<sub>41</sub> and <em>f</em> equals m<sub>42</sub> (see A 2D 3x2 matrix with six parameter).

<div class="figure">
	$$\begin{bmatrix} a & c & e \\ b & d & f \\ 0 & 0 & 1 \end{bmatrix}$$
	 <p class="caption">
		 3x3 matrix for two-dimensional transformations.

</div>

<div class="example">

Authors can easily provide a fallback if UAs do not provide support for three-dimensional transforms. The following example has two property definitions for 'transform'. The first one consists of two two-dimensional transform functions. The second one has a two-dimensional and a three-dimensional transform function.

	<pre>div {
	transform: scale(2) rotate(45deg);
	transform: scale(2) rotate3d(0, 0, 1, 45deg);
}</pre>

		With 3D support, the second definition will override the first one. Without 3D support, the second definition is invalid and a UA falls back to the first definition.

</div>

The Transform Rendering Model {#transform-rendering}
====================================================

This specification extends [[css-transforms-1#transform-rendering]] to account for the existence of three-dimensional transform functions, the Z value of 'transform-origin', the 'perspective' property, and a new 3D rendering model that applies when the used value of the ''transform-style'' property is ''transform-style/preserve-3d''.

Three-dimensional transform functions conceptually extend the coordinate space into three dimensions, adding a Z axis perpendicular to the plane of the screen, that increases towards the viewer.

<div class="figure">
	<img src="images/coordinates.svg" width="270" height="240" alt="Demonstration of the initial coordinate space">
	<p class="caption">
		 Demonstration of the initial coordinate space.

</div>

3D Transform Rendering {#3d-transform-rendering}
----------------------

Normally, elements render as flat planes, and are rendered into the same plane as their stacking context. Often this is the plane shared by the rest of the page. Two-dimensional transform functions can alter the appearance of an element, but that element is still rendered into the same plane as its stacking context.

An element with a three-dimensional transform that is not contained in a <a>3D rendering context</a> renders with the appropriate transform applied, but does not intersect with any other elements. The three-dimensional transform in this case can be considered just as a painting effect, like two-dimensional transforms. Similarly, the transform does not affect painting order. For example, a transform with a positive Z translation may make an element look larger, but does not cause that element to render in front of elements with no translation in Z.

Issue: describe how nested 3d-transformed elements render (perhaps with math)

<div class="example">

Issue: This example doesn't follow from the previous text.

This example shows the effect of three-dimensional transform applied to an element.

	<pre>
	&lt;style>
	div {
			height: 150px;
			width: 150px;
	}
	.container {
			border: 1px solid black;
	}
	.transformed {
			transform: rotateY(50deg);
	}
	&lt;/style>

	&lt;div class="container">
			&lt;div class="transformed">&lt;/div>
	&lt;/div>
	</pre>
	<div class="figure">
		<img src="examples/simple-3d-example.png" width="210" height="190" alt="Div with a rotateY transform.">
	</div>

The transform is a 50&deg; rotation about the vertical, Y axis. Note how this makes the blue box appear narrower, but not three-dimensional.
</div>

### Perspective ### {#perspective}

Perspective can be used to add a feeling of depth to a scene by making elements higher on the Z axis (closer to the viewer) appear larger, and those further away to appear smaller. The scaling is proportional to <var>d</var>/(<var>d</var> &minus; <var>Z</var>) where <var>d</var>, the value of 'perspective', is the distance from the drawing plane to the assumed position of the viewer's eye.

The appearance of perspective can be applied to a 3d-transformed element in two ways. First, the element's 'transform function list' can contain the ''perspective()'' function which computes into the element's 'current transformation matrix'.

Second, the 'perspective' and 'perspective-origin' properties can be applied to an element to influence the rendering of its 3d-transformed children, giving them a shared perspective that provides the impression of them living in the same three-dimensional scene.

<div class="figure">
	<img alt="Diagram of scale vs. Z position" src="images/perspective_distance.png">
	<p class="caption">
		Diagrams showing how scaling depends on the 'perspective' property and Z position. In the top diagram, <var>Z</var> is half of <var>d</var>. In order to make it appear that the original circle (solid outline) appears at <var>Z</var> (dashed circle), the circle is scaled up by a factor of two, resulting in the light blue circle. In the bottom diagram, the circle is scaled down by a factor of one-third to make it appear behind the original position.

</div>

Normally the assumed position of the viewer's eye is centered on a drawing. This position can be moved if desired &ndash; for example, if a web page contains multiple drawings that should share a common perspective &ndash; by setting 'perspective-origin'.

<div class="figure">
	<img alt="Diagram of different perspective-origin" src="images/perspective_origin.png">
	<p class="caption">
		Diagram showing the effect of moving the perspective origin upward.
</div>

<p id="perspective-matrix-computation">
	The <a>perspective matrix</a> is computed as follows:
		1. Start with the identity matrix.
		2. Translate by the computed X and Y values of 'perspective-origin'
		3. Multiply by the matrix that would be obtained from the ''perspective()'' transform function, where the length is provided by the value of the 'perspective' property
		4. Translate by the negated computed X and Y values of 'perspective-origin'

<div class="example">

This example shows how perspective can be used to cause three-dimensional transforms to appear more realistic.

	<pre>
	&lt;style>
	div {
		height: 150px;
		width: 150px;
	}
	.container {
		perspective: 500px;
		border: 1px solid black;
	}
	.transformed {
		transform: rotateY(50deg);
	}
	&lt;/style>

	&lt;div class="container">
		&lt;div class="transformed">&lt;/div>
	&lt;/div>
	</pre>

	<div class="figure">
		<img src="examples/simple-perspective-example.png" width="210" height="190" alt="Div with a rotateY transform, and perspective on its container">
	</div>

The inner element has the same transform as in the previous example, but its rendering is now influenced by the perspective property on its parent element. Perspective causes vertices that have positive Z coordinates (closer to the viewer) to be scaled up in X and Y, and those further away (negative Z coordinates) to be scaled down, giving an appearance of depth.
</div>

### 3D Rendering Contexts ### {#3d-rendering-contexts}

This section specifies the rendering model for content that uses 3D-transforms and the ''transform-style'' property. In order to describe this model, we introduce the concept of a "3D rendering context".

A <a>3D rendering context</a> is a set of elements rooted in a common ancestor that, for the purposes of 3D-transform rendering, are considered to share a common three-dimensional coordinate system. The front-to-back rendering of elements in the a 3D rendering context depends on their z-position in that three-dimensional space, and, if the 3D transforms on those elements cause them to intersect, then they are rendered with intersection.

The position of each element in that three-dimensional space is determined by [=accumulated 3D transformation matrix|accumulating=] the transformation matrices up from the given element to the element that establishes the <a>3D rendering context</a>.

Elements establish and participate in 3D rendering contexts as follows:

* A <a>3D rendering context</a> is established by a <a>transformable element</a> whose used value for 'transform-style' is ''transform-style/preserve-3d'' and which itself is not part of a 3D rendering context. An element that establishes a 3D rendering context also participates in that context.
* An element whose used value for 'transform-style' is ''transform-style/preserve-3d'' and which itself participates in a <a>3D rendering context</a>, extends that 3D rendering context rather than establishing a new one.
* An element participates in a <a>3D rendering context</a> if its parent establishes or extends a <a>3D rendering context</a>.


Some CSS properties have values that are considered to force "grouping": they require that their element and its descendants are rendered as a group before being composited with other elements; these include opacity, filters and properties that affect clipping. The relevant property values are listed under <a href="#grouping-property-values">grouping property values</a>. Consequently, when used on an element with transform-style:preserve-3d, they change the used value to
''transform-style/flat'' and prevent it from creating or extending a <a>3D rendering context</a>.

In a 3D rendering context, rendering and sorting of elements is done as follows:

1. The element establishing the 3D rendering context,
	and each other 3D transformed element participating in the 3D rendering context,
	is rendered into its own plane.
	This plane includes
	the element's backgrounds, borders, other box decorations, content,
	and descendant elements,
	excluding any descendant elements that have their own plane (and their descendants).
	This rendering is done according to
	<a href="https://www.w3.org/TR/CSS2/zindex.html#painting-order">CSS 2.1,
	Appendix E, Section E.2 Painting Order</a>.
2. Intersection is performed between this set of planes,
	according to
	<a href="https://en.wikipedia.org/wiki/Newell%27s_algorithm">Newell's algorithm</a>,
	with the planes transformed by the [=accumulated 3D transformation matrix=].
	Coplanar [=3D transformed elements=] are rendered in painting order.

Issue: is it OK to not pop 2D-transformed elements into their own planes?

Note: This specification previously defined that
the background, borders, and other box decorations of the establishing element
were rendered behind the entire 3D scene.
This was changed in <a href="https://github.com/w3c/csswg-drafts/issues/6238">#6238</a>.
However, if the definition of 3D Rendering Contexts is changed in the future,
it may be worth considering changing back.

Note that elements with transforms which have a negative z-component will render behind the content and untransformed descendants of the establishing element, and that [=3D transformed elements=] may interpenetrate with content and untransformed elements.

Note: Because the 3D-transformed elements in a 3D rendering context can all depth-sort and intersect with each other, they are effectively rendered as if they were siblings. The effect of transform-style: preserve-3d can then be thought of as causing all the [=3D transformed elements=] in a 3D rendering context to be hoisted up into the establishing element, but still rendered with their <a href="#accumulated-3d-transformation-matrix-computation">accumulated 3D transformation matrix</a>.

<div class="example">
	<pre>
	&lt;style>
	div {
		height: 150px;
		width: 150px;
	}
	.scene {
		background-color: rgba(0, 0, 0, 0.3);
		border: 1px solid black;
		perspective: 500px;
	}
	.container {
		transform-style: preserve-3d;
	}
	.container > div {
		position: absolute;
		left: 0;
	}
	.container > :first-child {
		transform: rotateY(45deg);
		background-color: orange;
		top: 10px;
		height: 135px;
	}
	.container > :last-child {
		transform: translateZ(40px);
		background-color: rgba(0, 0, 255, 0.6);
		top: 50px;
		height: 100px;
	}
	&lt;/style>

	&lt;div class="scene">
	  &lt;div class="container">
	    Lorem ipsum dolor sit amet, consectetaur adipisicing elit&hellip;
	    &lt;div>&lt;/div>
	    &lt;div>&lt;/div>
	  &lt;/div>
	&lt;/div>
	</pre>

This example shows show elements in a 3D rendering context can intersect. The container element establishes a 3D rendering context for itself and its two children, and the scene element adds perspective to the 3D rendering context. The children intersect with each other, and the orange element also intersects with the container.

	<div class="figure">
		<img src="examples/3d-intersection.png" width="210" height="198" alt="Intersecting sibling elements.">
	</div>
</div>

<div class="example">
	<pre>
	&lt;style>
	div {
		height: 150px;
		width: 150px;
	}
	.container {
		perspective: 500px;
		border: 1px solid black;
	}
	.transformed {
		transform: rotateY(50deg);
		background-color: blue;
	}
	.child {
		transform-origin: top left;
		transform: rotateX(40deg);
		background-color: lime;
	}
	&lt;/style>

	&lt;div class="container">
		&lt;div class="transformed">
			&lt;div class="child">&lt;/div>
		&lt;/div>
	&lt;/div>
	</pre>

This example shows how nested 3D transforms are rendered. The blue div is transformed as in the previous example, with its rendering influenced by the perspective on its parent element. The lime element also has a 3D transform, which is a rotation about the X axis (anchored at the top, by virtue of the transform-origin). However, the lime element is being rendered into the plane of its parent because it is not a member of the same 3D rendering context. Thus the lime element only appears shorter; it does not "pop out" of the blue element.

	<div class="figure">
		<img src="examples/3d-rendering-context-flat.png" width="240" height="200" alt="Nested 3D transforms, with flattening">
	</div>
</div>

### Transformed element hierarchies ### {#transformed-element-hierarchies}

By default, <a>transformed elements</a> do not create a <a>3D rendering context</a> and create a flattened representation of their content. However, since it is useful to construct hierarchies of transformed objects that share a common 3-dimensional space, this flattening behavior may be overridden by specifying a value of ''transform-style/preserve-3d'' for the ''transform-style'' property. This allows descendants of the transformed element to share the same 3D rendering context. Non-3D-transformed descendants of such elements are rendered into the plane of the element in step C above, but 3D-transformed elements in the same 3D rendering context will "pop out" into their own planes.

<div class="example">
	<pre>
	&lt;style>
	div {
		height: 150px;
		width: 150px;
	}
	.container {
		perspective: 500px;
		border: 1px solid black;
	}
	.transformed {
		<b>transform-style: preserve-3d</b>;
		transform: rotateY(50deg);
		background-color: blue;
	}
	.child {
		transform-origin: top left;
		transform: rotateX(40deg);
		background-color: lime;
	}
	&lt;/style>
	</pre>

This example is identical to the previous example, with the addition of ''transform-style: preserve-3d'' on the blue element. The blue element now extends the 3D rendering context of its container. Now both blue and lime elements share a common three-dimensional space, so the lime element renders as tilting out from its parent, influenced by the perspective on the container.

	<div class="figure">
		<img src="examples/3d-rendering-context-3d.png" width="240" height="200" alt="Nested 3D transforms, with preserve-3d.">
	</div>
</div>

### Accumulated 3D Transformation Matrix Computation ### {#accumulated-3d-transformation-matrix-computation}

The final value of the transform used to render an element in a <a>3D rendering context</a> is computed by accumulating an <a>accumulated 3D transformation matrix</a> as follows:

1. Let <var>transform</var> be the identity matrix.
2. Let <var>current element</var> be the transformed element.
3. Let <var>parent element</var> be the parent element of the transformed element.
4. While <var>current element</var> is an element in the transformed element's <a>3D rendering context</a>:

		1. If <var>current element</var> has a value for 'transform' which is not ''transform/none'', pre-multiply <var>current element</var>'s <a>transformation matrix</a> with the <var>transform</var>.
		2. Compute a translation matrix which represents the offset (including the scroll offset) of <var>current element</var> from its <var>parent element</var>, and pre-multiply that matrix into the <var>transform</var>.
		3. If <var>parent element</var> has a value for 'perspective' which is not ''perspective/none'', pre-multiply the <var>parent element</var>'s <a>perspective matrix</a> into the <var>transform</var>.
		4. Let <var>current element</var> be the <var>parent element</var>.
		5. Let <var>parent element</var> be the <var>current element</var>'s parent.

Note: as described here, the <a>accumulated 3D transformation matrix</a> takes into account offsets (including the scroll offset) generated by the <a href="https://www.w3.org/TR/CSS2/visuren.html">visual formatting model</a> on the transformed element, and elements in its ancestor chain up to and including the element that establishes the its <a>3D rendering context</a>.

### Backface Visibility ### {#backface-visibility}

Using three-dimensional transforms, it's possible to transform an element such that its reverse side is visible. 3D-transformed elements show the same content on both sides, so the reverse side looks like a mirror-image of the front side (as if the element were projected onto a sheet of glass). Normally, elements whose reverse side is towards the viewer remain visible. However, the 'backface-visibility' property allows the author to make an element invisible when its reverse side is towards the viewer. This behavior is "live"; if an element with ''backface-visibility: hidden'' were animating, such that its front and reverse sides were alternately visible, then it would only be visible when the front side were towards the viewer.

Visibility of the reverse side of an element is considered using the <a>accumulated 3D transformation matrix</a>, and is thus relative to the parent of the element that establishes the <a>3D rendering context</a>.

Note: This property is useful when you place two elements back-to-back, as you would to create a playing card. Without this property, the front and back elements could switch places at times during an animation to flip the card. Another example is creating a box out of 6 elements, but where you want to see only the inside faces of the box.

<div class="example">

This example shows how to make a "card" element that flips over when clicked. Note the "transform-style: preserve-3d" on #card which is necessary to avoid flattening when flipped.

	<pre>
	&lt;style>
	.body { perspective: 500px; }
	#card {
		position: relative;
		height: 300px; width: 200px;
		transition: transform 1s;
		transform-style: preserve-3d;
	}
	#card.flipped {
		transform: rotateY(180deg);
	}
	.face {
		position: absolute;
		top: 0; left: 0;
		width: 100%; height: 100%;
		background-color: silver;
		border-radius: 40px;
		backface-visibility: hidden;
	}
	.back {
		transform: rotateY(180deg);
	}
	&lt;/style>
	&lt;div id="card" onclick="this.classList.toggle('flipped')">
		&lt;div class="front face">Front&lt;/div>
		&lt;div class="back face">Back&lt;/div>
	&lt;/div>
	</pre>

</div>

Issue: what is the impact of backface-visibility on non-transformed or 2D-transformed elements? Do they get popped into their own planes and intersect?

Processing of Perspective-Transformed Boxes {#processing-of-perspective-transformed-boxes}
-------------------------------------------

Issue: This is a first pass at an attempt to precisely specify how exactly to transform elements using the provided matrices. It might not be ideal, and implementer feedback is encouraged.  See <a href="https://github.com/w3c/csswg-drafts/issues/912">#912</a>.

The <a>accumulated 3D transformation matrix</a> is affected both by the ''perspective'' property, and by any perspective() transform function present in the value of the ''transform'' property.

This <a>accumulated 3D transformation matrix</a> is a 4&times;4 matrix, while the objects to be transformed are two-dimensional boxes. To transform each corner (<var>a</var>, <var>b</var>) of a box, the matrix must first be applied to (<var>a</var>, <var>b</var>, 0, 1), which will result in a four-dimensional point (<var>x</var>, <var>y</var>, <var>z</var>, <var>w</var>).  This is transformed back to a three-dimensional point (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) as follows:

If <var>w</var> > 0, (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) = (<var>x</var>/<var>w</var>, <var>y</var>/<var>w</var>, <var>z</var>/<var>w</var>).

If <var>w</var> = 0, (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) = (<var>x</var> &sdot; <var>n</var>, <var>y</var> &sdot; <var>n</var>, <var>z</var> &sdot; <var>n</var>).  <var>n</var> is an implementation-dependent value that should be chosen so that <var>x</var>&prime; or <var>y</var>&prime; is much larger than the viewport size, if possible.  For example, (5px, 22px, 0px, 0) might become (5000px, 22000px, 0px), with <var>n</var> = 1000, but this value of <var>n</var> would be too small for (0.1px, 0.05px, 0px, 0). This specification does not define the value of <var>n</var> exactly.  Conceptually, (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) is <a href="https://en.wikipedia.org/wiki/Plane_at_infinity">infinitely far</a> in the direction (<var>x</var>, <var>y</var>, <var>z</var>).

If <var>w</var> &lt; 0 for all four corners of the transformed box, the box is not rendered.

If <var>w</var> &lt; 0 for one to three corners of the transformed box, the box must be replaced by a polygon that has any parts with <var>w</var> &lt; 0 cut out. This will in general be a polygon with three to five vertices, of which exactly two will have <var>w</var> = 0 and the rest <var>w</var> > 0. These vertices are then transformed to three-dimensional points using the rules just stated.  Conceptually, a point with <var>w</var> &lt; 0 is "behind" the viewer, so should not be visible.

<div class="example">
	<pre>
	.transformed {
		height: 100px;
		width: 100px;
		background: lime;
		transform: perspective(50px) translateZ(100px);
	}
	</pre>

All of the box's corners have <var>z</var>-coordinates greater than the perspective.  This means that the box is behind the viewer and will not display.  Mathematically, the point (<var>x</var>, <var>y</var>) first becomes (<var>x</var>, <var>y</var>, 0, 1), then is translated to (<var>x</var>, <var>y</var>, 100, 1), and then applying the perspective results in (<var>x</var>, <var>y</var>, 100, &minus;1). The <var>w</var>-coordinate is negative, so it does not display. An implementation that doesn't handle the <var>w</var> &lt; 0 case separately might incorrectly display this point as (&minus;<var>x</var>, &minus;<var>y</var>, &minus;100), dividing by &minus;1 and mirroring the box.

</div>

<div class="example">
	<pre>
	.transformed {
		height: 100px;
		width: 100px;
		background: radial-gradient(yellow, blue);
		transform: perspective(50px) translateZ(50px);
	}
	</pre>

Here, the box is translated upward so that it sits at the same place the viewer is looking from. This is like bringing the box closer and closer to one's eye until it fills the entire field of vision. Since the default transform-origin is at the center of the box, which is yellow, the screen will be filled with yellow.

Mathematically, the point (<var>x</var>, <var>y</var>) first becomes (<var>x</var>, <var>y</var>, 0, 1), then is translated to (<var>x</var>, <var>y</var>, 50, 1), then becomes (<var>x</var>, <var>y</var>, 50, 0) after applying perspective. Relative to the transform-origin at the center, the upper-left corner was (&minus;50, &minus;50), so it becomes (&minus;50,
		&minus;50, 50, 0).  This is transformed to something very far to the upper left, such as (&minus;5000, &minus;5000, 5000).  Likewise the other corners are sent very far away. The radial gradient is stretched over the whole box, now enormous, so the part that's visible without scrolling should be the color of the middle pixel: yellow.  However, since the box is not actually infinite, the user can still scroll to the edges to see the blue parts.

</div>

<div class="example">
	<pre>
	.transformed {
		height: 50px;
		width: 50px;
		background: lime;
		border: 25px solid blue;
		transform-origin: left;
		transform: perspective(50px) rotateY(-45deg);
	}
	</pre>

The box will be rotated toward the viewer, with the left edge staying fixed while the right edge swings closer.  The right edge will be at about <var>z</var> = ''70.7px'', which is closer than the perspective of ''50px''. Therefore, the rightmost edge will vanish ("behind" the viewer), and the visible part will stretch out infinitely far to the right.

Mathematically, the top right vertex of the box was originally (100, &minus;50), relative to the transform-origin. It is first expanded to (100, &minus;50, 0, 1).  After applying the transform specified, this will get mapped to about (70.71, &minus;50, 70.71, &minus;0.4142). This has <var>w</var> = &minus;0.4142 &lt; 0, so we need to slice away the part of the box with <var>w</var> &lt; 0.  This results in the new top-right vertex being (50, &minus;50, 50, 0).  This is then mapped to some faraway point in the same direction, such as (5000, &minus;5000, 5000), which is up and to the right from the transform-origin.  Something similar is done to the lower right corner, which gets mapped far down and to the right. The resulting box stretches far past the edge of the screen.

Again, the rendered box is still finite, so the user can scroll to see the whole thing if he or she chooses. However, the right part has been chopped off.  No matter how far the user scrolls, the rightmost ''30px'' or so of the original box will not be visible.  The blue border was only ''25px'' wide, so it will be visible on the left, top, and bottom, but not the right.

The same basic procedure would apply if one or three vertices had <var>w</var> &lt; 0.  However, in that case the result of truncating the <var>w</var> &lt; 0 part would be a triangle or pentagon instead of a quadrilateral.

</div>

Individual Transform Properties: the 'translate', 'scale', and 'rotate' properties {#individual-transforms}
===========================================================================================================

The 'translate', 'rotate', and 'scale' properties
allow authors to specify simple transforms independently,
in a way that maps to typical user interface usage,
rather than having to remember the order in 'transform'
that keeps the actions of ''translate()'', ''rotate()'' and ''scale()''
independent and acting in screen coordinates.

<pre class="propdef">
Name: translate
Value: none | <<length-percentage>> [ <<length-percentage>> <<length>>? ]?
Initial: none
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: relative to the width of the <a>reference box</a> (for the first value) or the height (for the second value)
Computed Value: the keyword ''translate/none'' or a pair of computed <<length-percentage>> values and an absolute length
Animation type: by computed value, but see below for ''translate/none''
</pre>

The 'translate' property accepts 1-3 values,
each specifying a translation against one axis,
in the order X, Y, then Z.
When the second or third values are missing,
they default to ''0px''.

If the third value is omitted or zero,
this specifies a 2d translation,
equivalent to the ''translate()'' function.
Otherwise,
this specifies a 3d translation,
equivalent to the ''translate3d()'' function.

Note: The <a>resolved value</a> of the 'translate' property
is the <a>computed value</a>,
and thus {{Window/getComputedStyle()}}
includes percentage values in its results.

<pre class="propdef">
Name: rotate
Value: none | <<angle>> | [ x | y | z | <<number>>{3} ] && <<angle>>
Initial: none
Applies to: <a>transformable elements</a>
Inherited: no
Computed value: the keyword ''rotate/none'', or an <<angle>> with an axis consisting of a list of three <<number>>s
Animation type: as SLERP, but see below for ''rotate/none''
</pre>

The 'rotate' property accepts an angle to rotate an element,
and optionally an axis to rotate it around.

The axis can be specified with either the
<dfn value for=rotate>x</dfn>,
<dfn value for=rotate>y</dfn>,
or <dfn value for=rotate>z</dfn> keywords,
which specify a rotation around that axis,
equivalent to the ''rotateX()'', ''rotateY()'',
and ''rotateZ()'' transform functions.
Alternately, the axis can be specified explicitly
by giving three numbers
representing the x, y, and z components of an origin-centered vector,
equivalent to the ''rotate3d()'' function.

There is no difference in behavior between
a rotation specified as an <<angle>> alone
and a rotation specified as being around the z-axis
(whether by the ''z'' keyword or
by a vector whose first two components are zero
and third component is positive);
they are all 2d rotations equivalent to the ''rotate()'' function.
For example, ''rotate: 30deg'', ''rotate: z 30deg'', and
''rotate: 0 0 1 30deg'' are equivalent.

<pre class="propdef">
Name: scale
Value: none | [ <<number>> | <<percentage>> ]{1,3}
Initial: none
Applies to: <a>transformable elements</a>
Inherited: no
Computed value: the keyword ''scale/none'', or a list of 3 <<number>>s
Animation type: by computed value, but see below for ''scale/none''
</pre>

The 'scale' property accepts 1-3 values,
each specifying a scale along one axis,
in order X, Y, then Z.

If the Y value is not given,
then it defaults to being the same as the X value.

If the Z value is not given,
then it defaults to ''1''.

If the third value is omitted, ''1'', or ''100%'',
this specifies a 2d scaling,
equivalent to the ''scale()'' function.
Otherwise,
this specifies a 3d scaling,
equivalent to the ''scale3d()'' function.

There is no difference in behavior between the third value being omitted
and the third value being ''1'' or ''100%''.

A <<percentage>> is equivalent to a <<number>>,
for example ''scale: 100%'' is equivalent to ''scale: 1''.
Numbers are used during serialization of specified and computed values.


----

All three properties accept
(and default to)
the value <dfn value for="translate, rotate, scale">none</dfn>,
which produces no transform at all.
In particular,
this value does <em>not</em> trigger the creation of a stacking context or [=containing block for all descendants=],
while all other values
(including “identity” transforms like ''translate: 0px'')
create a stacking context and [=containing block for all descendants=],
per usual for transforms.

When 'translate', 'rotate' or 'scale' are animating or transitioning, and the from value or to
value (but not both) is ''translate/none'', the value ''translate/none'' is replaced by the equivalent identity
value (''0px'' for translate, ''0deg'' for rotate, ''1'' for scale).

Serialization {#individual-transform-serialization}
---------------------------------------------------

Because these properties have two distinct modes of behavior
(no transform versus transform),
serialization must take this into account:

: for 'translate'
:: If a translation is specified,
	the property must serialize with one through three values.
	(As usual, if the second and third values are ''0px'', the default,
	or if only the third value is ''0px'',
	then those ''0px'' values must be omitted when serializing).

	It must serialize as the keyword ''translate/none''
	if and only if ''translate/none'' was originally specified.
	(An identity transform does not count;
	it must serialize as ''0px''.)

: for 'rotate'
:: If a rotation about the z axis (that is, in 2D) is specified,
	the property must serialize as just an <<angle>>.

	If any other rotation is specified,
	the property must serialize with an axis specified.
	If the axis is parallel with the x or y axes,
	it must serialize as the appropriate keyword.

	It must serialize as the keyword ''rotate/none''
	if and only if ''rotate/none'' was originally specified.
	(An identity transform does not count;
	it must serialize as ''0deg''.)

: for 'scale'
:: If a scale is specified,
	the property must serialize with only one through three values.
	As usual, if the third value is 1, the default,
	then it is omitted when serializing.
	If the third value is omitted
	and the second value is the same as the first (the default),
	then the second value is also omitted when serializing.

	It must serialize as the keyword ''scale/none''
	if and only if ''scale/none'' was originally specified.
	(An identity transform does not count;
	it must serialize as ''1''.)

Current Transformation Matrix {#ctm}
====================================

<p id="transformation-matrix-computation">
The <a>transformation matrix</a> computation is amended to the following:

The transformation matrix is computed from the 'transform', 'transform-origin', 'translate', 'rotate', 'scale', and 'offset' properties as follows:

1. Start with the identity matrix.
2. Translate by the computed X, Y, and Z values of 'transform-origin'.
3. Translate by the computed X, Y, and Z values of 'translate'.
4. Rotate by the computed <<angle>> about the specified axis of 'rotate'.
5. Scale by the computed X, Y, and Z values of 'scale'.
6. Translate and rotate by the transform specified by 'offset'.
7. Multiply by each of the transform functions in 'transform' from left to right.
8. Translate by the negated computed X, Y and Z values of 'transform-origin'.


The 'transform-style' Property {#transform-style-property}
==============================

<pre class='propdef'>
Name: transform-style
Value: flat | preserve-3d
Initial: flat
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: specified keyword
Used value: flat if a <a href="#grouping-property-values">grouping property</a> is present, specified keyword otherwise
Animation type: discrete
</pre>

A computed value of ''transform-style/preserve-3d'' for 'transform-style'
on a <a>transformable element</a>
establishes both a stacking context and
a [=containing block for all descendants=].
If the used value is ''transform-style/preserve-3d''
then it also establishes or extends a <a>3D rendering context</a>.

Grouping property values {#grouping-property-values}
------------------------

The following CSS property values require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore force the element to have a used style of ''transform-style/flat'' for ''transform-style/preserve-3d''.

* 'overflow': any value other than ''overflow/visible'' or ''overflow/clip''.
* 'opacity': any value less than 1.
* 'filter': any value other than ''filter/none''.
* 'clip': any value other than ''clip/auto''.
* 'clip-path': any value other than ''clip-path/none''.
* 'isolation': used value of ''isolation/isolate''.
* 'mask-image': any value other than ''mask-image/none''.
* 'mask-border-source': any value other than ''mask-border-source/none''.
* 'mix-blend-mode': any value other than ''mix-blend-mode/normal''.
* 'contain': ''contain/paint'' and any other property/value combination that causes [=paint containment=].
	<span class=note>Note: this includes any property that affect the [=used value=] of the 'contain' property,
	such as ''content-visibility: hidden''.</span>

The 'perspective' Property {#perspective-property}
==========================

<pre class='propdef'>
Name: perspective
Value: none | <<length [0, ∞]>>
Initial: none
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: the keyword ''perspective/none'' or an absolute length
Animation type: by computed value
</pre>

<dl dfn-type=value dfn-for="perspective">
	: <dfn><<length [0, ∞]>></dfn>
	:: Distance to the center of projection.

		Issue: Verify that projection is the distance to the center of projection.

		As very small <<length>> values can produce bizarre rendering results
		and stress the numerical accuracy of transform calculations,
		values less than ''1px'' must be treated as ''1px''
		for rendering purposes.
		(This clamping does not affect the underlying value,
		so ''perspective: 0;'' in a stylesheet
		will still serialize back as ''0''.)

	: <dfn>none</dfn>
	:: No perspective transform is applied. The effect is mathematically similar to an infinite <<length>> value. All objects appear to be flat on the canvas.

</dl>

The use of this property with any value other than ''perspective/none'' establishes a stacking context. It also establishes a [=containing block for all descendants=], just like the 'transform' property does.

Issue: We don't really need to be a stacking context or containing block for perspective, but maybe webcompat means we can't change this.

The values of the 'perspective' and 'perspective-origin' properties are used to compute the <a>perspective matrix</a>, as described above.



The 'perspective-origin' Property {#perspective-origin-property}
=================================

The 'perspective-origin' property establishes the origin for the 'perspective' property. It effectively sets the X and Y position at which the viewer appears to be looking at the children of the element.

<pre class='propdef'>
Name: perspective-origin
Value: <<position>>
Initial: 50% 50%
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: refer to the size of the <a>reference box</a>
Computed value: see 'background-position'
Animation type: by computed value
</pre>

The values of the 'perspective' and 'perspective-origin' properties are used to compute the <a>perspective matrix</a>, as described above.

The values for 'perspective-origin' represent an offset of the perspective origin from the top left corner of the <a>reference box</a>.

<dl dfn-for="perspective-origin" dfn-type="value">
	: <dfn><<percentage>></dfn>
	:: A percentage for the horizontal perspective offset is relative to the width of the <a>reference box</a>. A percentage for the vertical offset is relative to height of the <a>reference box</a>. The value for the horizontal and vertical offset represent an offset from the top left corner of the <a>reference box</a>.

	: <dfn><<length>></dfn>
	:: A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the <a>reference box</a>.

	: <dfn>top</dfn>
	:: Computes to ''0%'' for the vertical position if one or two values are given, otherwise specifies the top edge as the origin for the next offset.

	: <dfn>right</dfn>
	:: Computes to ''100%'' for the horizontal position if one or two values are given, otherwise specifies the right edge as the origin for the next offset.

	: <dfn>bottom</dfn>
	:: Computes to ''100%'' for the vertical position if one or two values are given, otherwise specifies the bottom edge as the origin for the next offset.

	: <dfn>left</dfn>
	:: Computes to ''0%'' for the horizontal position if one or two values are given, otherwise specifies the left edge as the origin for the next offset.

	: <dfn>center</dfn>
	:: Computes to ''50%'' (''left 50%'') for the horizontal position if the horizontal position is not otherwise specified, or ''50%'' (''top 50%'') for the vertical position if it is.

</dl>

The 'perspective-origin' property is a <a>resolved value special case property like <css>height</css></a>. [[!CSSOM]]

The 'backface-visibility' Property {#backface-visibility-property}
==================================

<pre class='propdef'>
Name: backface-visibility
Value: visible | hidden
Initial: visible
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: specified keyword
Animation type: discrete
</pre>

The visibility of an element with ''backface-visibility: hidden'' is determined as follows:

1. Compute the element's <a>accumulated 3D transformation matrix</a>.
2. If the component of the matrix in row 3, column 3 is negative, then the element should be hidden. Otherwise it is visible.

Issue: Backface-visibility cannot be tested by only looking at m33. See <a href="https://github.com/w3c/csswg-drafts/issues/917">#917</a>.

Note: The reasoning for this definition is as follows. Assume elements are rectangles in the <var>x</var>&ndash;<var>y</var> plane with infinitesimal thickness. The front of the untransformed element has coordinates like (<var>x</var>, <var>y</var>, <var>&epsilon;</var>), and the back is (<var>x</var>, <var>y</var>, &minus;<var>&epsilon;</var>), for some very small <var>&epsilon;</var>. We want to know if after the transformation, the front of the element is closer to the viewer than the back (higher <var>z</var>-value) or further away. The <var>z</var>-coordinate of the front will be m<sub>13</sub><var>x</var> + m<sub>23</sub><var>y</var> + m<sub>33</sub><var>&epsilon;</var> + m<sub>43</sub>, before accounting for perspective, and the back will be m<sub>13</sub><var>x</var> + m<sub>23</sub><var>y</var> &minus; m<sub>33</sub><var>&epsilon;</var> + m<sub>43</sub>.  The first quantity is greater than the second if and only if m<sub>33</sub> > 0. (If it equals zero, the front and back are equally close to the viewer. This probably means something like a 90-degree rotation, which makes the element invisible anyway, so we don't really care whether it vanishes.)


SVG and 3D transform functions {#svg-three-dimensional-functions}
==============================

This specification explicitly requires three-dimensional transform functions to apply to the <a>container elements</a>: <{a}>, <{g}>, <{svg}>, all <a>graphics elements</a>, all <a>graphics referencing elements</a> and the SVG <{foreignObject}> element.

Three-dimensional transform functions and the properties 'perspective', 'perspective-origin', 'transform-style' and 'backface-visibility' can not be used for the elements: <{clipPath}>, <{linearGradient}>, <{radialGradient}> and <{pattern}>. If a transform list includes a three-dimensional transform function, the complete transform list must be ignored. The values of every previously named property must be ignored. Transformable elements that are contained by one of these elements can have three-dimensional transform functions. The <{clipPath}>, <{mask}>, <{pattern}> elements require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore override the behavior of ''transform-style: preserve-3d''.

If the 'vector-effect' property is set to ''non-scaling-stroke'' and an object is within a <a>3D rendering context</a> the property has no affect on stroking the object.

Issue: formally describe the syntax of the 3D transform functions in SVG,
as is done <a href="https://drafts.csswg.org/css-transforms-1/#svg-syntax">for the 2-D functions</a>.

The Transform Functions {#transform-functions}
=======================

The value of the 'transform' property is a list of <dfn>&lt;transform-function></dfn>. The set of allowed transform functions is given below. Wherever <<angle>> is used in this specification, a <<number>> that is equal to zero is also allowed, which is treated the same as an angle of zero degrees. A percentage for horizontal translations is relative to the width of the <a>reference box</a>. A percentage for vertical translations is relative to the height of the <a>reference box</a>.
A percentage in a scale function is equivalent to a number, and serializes as a number in specified values.
For example, ''scale3d(50%, 100%, 150%)'' serializes as ''scale3d(0.5, 1, 1.5)''.

2D Transform Functions {#two-d-transform-functions}
----------------------

The scale functions defined in [[!css-transforms-1]] now support percentages.

: <span class='prod'><dfn>scale()</dfn> = scale( [ <<number>> | <<percentage>> ]#{1,2} )</span>
: <span class='prod'><dfn>scaleX()</dfn> = scaleX( [ <<number>> | <<percentage>> ] )</span>
: <span class='prod'><dfn>scaleY()</dfn> = scaleY( [ <<number>> | <<percentage>> ] )</span>
:: As <a href="https://www.w3.org/TR/css-transforms-1/#two-d-transform-functions">defined in css-transforms-1</a>, but also accepting percentages as <a href="#transform-functions">described above</a>.

3D Transform Functions {#three-d-transform-functions}
----------------------

In the following <dfn export>3d transform functions</dfn>, a <<zero>> behaves the same as ''0deg''.
("Unitless 0" angles are preserved for legacy compat reasons.)


: <span class='prod'><dfn>matrix3d()</dfn> = matrix3d( <<number>>#{16} )</span>
:: specifies a 3D transformation as a 4x4 homogeneous matrix of 16 values in column-major order.
: <span class='prod'><dfn>translate3d()</dfn> = translate3d( <<length-percentage>> , <<length-percentage>> , <<length>> )</span>
:: specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [tx,ty,tz], with tx, ty and tz being the first, second and third translation-value parameters respectively.
: <span class='prod'><dfn>translateZ()</dfn> = translateZ( <<length>> )</span>
:: specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [0,0,tz] with the given amount in the Z direction.
: <span class='prod'><dfn>scale3d()</dfn> = scale3d( [ <<number>> | <<percentage>> ]#{3} )</span>
:: specifies a <a href="#Scale3dDefined">3D scale</a> operation by the [sx,sy,sz] scaling vector described by the 3 parameters.
: <span class='prod'><dfn>scaleZ()</dfn> = scaleZ( [ <<number>> | <<percentage>> ] )</span>
:: specifies a <a href="#Scale3dDefined">3D scale</a> operation using the [1,1,sz] scaling vector, where sz is given as the parameter.
: <span class='prod'><dfn>rotate3d()</dfn> = rotate3d( <<number>> , <<number>> , <<number>> , [ <<angle>> | <<zero>> ] )</span>
:: specifies a <a href="#Rotate3dDefined">3D rotation</a> by the angle specified in last parameter about the [x,y,z] direction vector described by the first three parameters. A direction vector that cannot be normalized, such as [0,0,0], will cause the rotation to not be applied.

	Note: the rotation is clockwise as one looks from the end of the vector toward the origin.

: <span class='prod'><dfn>rotateX()</dfn> = rotateX( [ <<angle>> | <<zero>> ] )</span>
:: same as ''rotate3d(1, 0, 0, &lt;angle>)''.
: <span class='prod'><dfn>rotateY()</dfn> = rotateY( [ <<angle>> | <<zero>> ] )</span>
:: same as ''rotate3d(0, 1, 0, &lt;angle>)''.
: <span class='prod'><dfn>rotateZ()</dfn> = rotateZ( [ <<angle>> | <<zero>> ] )</span>
:: same as ''rotate3d(0, 0, 1, &lt;angle>)'', which is a 3d transform equivalent to the 2d transform ''rotate(&lt;angle>)''.
: <span class='prod'><dfn>perspective()</dfn> = perspective( <<length [0,∞]>> | <dfn id="valdef-perspective-func-none" dfn-type="value" for="perspective()">none</dfn> )</span>
:: specifies a <a href="#PerspectiveDefined">perspective projection matrix</a>. This matrix scales points in X and Y based on their Z value, scaling points with positive Z values away from the origin, and those with negative Z values towards the origin. Points on the z=0 plane are unchanged. The parameter represents the distance of the z=0 plane from the viewer. Lower values give a more flattened pyramid and therefore a more pronounced perspective effect. For example, a value of 1000px gives a moderate amount of foreshortening and a value of 200px gives an extreme amount.

	If the depth value is less than ''1px'',
	it must be treated as ''1px'' for the purpose of rendering,
	for computing the <a>resolved value</a> of 'transform',
	and when used as the endpoint of
	<a href="#interpolation-of-transform-functions">interpolation</a>.

	Note: The intent of the above rules on values less than ''1px'' is
	that they cover the cases where the ''perspective()'' function
	needs to be converted into a matrix.


Transform function primitives and derivatives {#transform-primitives}
----------------------------

Some transform functions can be represented by more generic transform functions. These transform functions are called derived transform functions, and the generic transform functions are called primitive transform functions. Three-dimensional primitives and their derived transform functions are:

<dl>
	<dt id="translate3d-primitive">''translate3d()''
	<dd>for <<translateX()>>, <<translateY()>>, ''translateZ()'' and <<translate()>>.

	<dt id="scale3d-primitive">''scale3d()''
	<dd>for <<scaleX()>>, <<scaleY()>>, ''scaleZ()'' and <<scale()>>.

	<dt id="rotate3d-primitive">''rotate3d()''
	<dd>for <<rotate()>>, ''rotateX()'', ''rotateY()'' and ''rotateZ()''.
</dl>

<p id="interpolation-two-three-dimensional-function">
  For derived transform functions that have a two-dimensional primitive and a three-dimensional primitive, the context decides about the used primitive. See <a href="#interpolation-of-transform-functions">Interpolation of primitives and derived transform functions</a>.


Interpolation of Matrices {#matrix-interpolation}
=================================================

When interpolating between two matrices, each matrix is decomposed into the corresponding translation, rotation, scale, skew and (for a <a>3D matrix</a>) perspective values. Each corresponding component of the decomposed matrices gets interpolated numerically and recomposed back to a matrix in a final step.

Interpolation of 3D matrices {#interpolation-of-3d-matrices}
----------------------------

### Decomposing a 3D matrix ### {#decomposing-a-3d-matrix}

The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", but modified to use Quaternions instead of Euler angles to avoid the problem of Gimbal Locks.

The following pseudocode works on a 4x4 homogeneous matrix:

<pre>
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
				scale       ; a 3 component vector
				skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
				perspective ; a 4 component vector
				quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can


// Normalize the matrix.
if (matrix[3][3] == 0)
		return false

for (i = 0; i < 4; i++)
		for (j = 0; j < 4; j++)
				matrix[i][j] /= matrix[3][3]

// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
perspectiveMatrix = matrix

for (i = 0; i < 3; i++)
		perspectiveMatrix[i][3] = 0

perspectiveMatrix[3][3] = 1

if (determinant(perspectiveMatrix) == 0)
		return false

// First, isolate perspective.
if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
		// rightHandSide is the right hand side of the equation.
		rightHandSide[0] = matrix[0][3]
		rightHandSide[1] = matrix[1][3]
		rightHandSide[2] = matrix[2][3]
		rightHandSide[3] = matrix[3][3]

		// Solve the equation by inverting perspectiveMatrix and multiplying
		// rightHandSide by the inverse.
		inversePerspectiveMatrix = inverse(perspectiveMatrix)
		transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
		perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)
else
		// No perspective.
		perspective[0] = perspective[1] = perspective[2] = 0
		perspective[3] = 1

// Next take care of translation
for (i = 0; i < 3; i++)
		translate[i] = matrix[3][i]

// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
for (i = 0; i < 3; i++)
		row[i][0] = matrix[i][0]
		row[i][1] = matrix[i][1]
		row[i][2] = matrix[i][2]

// Compute X scale factor and normalize first row.
scale[0] = length(row[0])
row[0] = normalize(row[0])

// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0] = dot(row[0], row[1])
row[1] = combine(row[1], row[0], 1.0, -skew[0])

// Now, compute Y scale and normalize 2nd row.
scale[1] = length(row[1])
row[1] = normalize(row[1])
skew[0] /= scale[1];

// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1] = dot(row[0], row[2])
row[2] = combine(row[2], row[0], 1.0, -skew[1])
skew[2] = dot(row[1], row[2])
row[2] = combine(row[2], row[1], 1.0, -skew[2])

// Next, get Z scale and normalize 3rd row.
scale[2] = length(row[2])
row[2] = normalize(row[2])
skew[1] /= scale[2]
skew[2] /= scale[2]

// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
pdum3 = cross(row[1], row[2])
if (dot(row[0], pdum3) < 0)
		for (i = 0; i < 3; i++)
				scale[i] *= -1;
				row[i][0] *= -1
				row[i][1] *= -1
				row[i][2] *= -1

// Now, get the rotations out
quaternion[0] = 0.5 * sqrt(max(1 + row[0][0] - row[1][1] - row[2][2], 0))
quaternion[1] = 0.5 * sqrt(max(1 - row[0][0] + row[1][1] - row[2][2], 0))
quaternion[2] = 0.5 * sqrt(max(1 - row[0][0] - row[1][1] + row[2][2], 0))
quaternion[3] = 0.5 * sqrt(max(1 + row[0][0] + row[1][1] + row[2][2], 0))

if (row[2][1] > row[1][2])
		quaternion[0] = -quaternion[0]
if (row[0][2] > row[2][0])
		quaternion[1] = -quaternion[1]
if (row[1][0] > row[0][1])
		quaternion[2] = -quaternion[2]

return true</pre>

### Interpolation of decomposed 3D matrix values ### {#interpolation-of-decomposed-3d-matrix-values}

Each component of the decomposed values translation, scale, skew and perspective of the source matrix get linearly interpolated with each corresponding component of the destination matrix.

Note: For instance, <code>translate[0]</code> of the source matrix and <code>translate[0]</code> of the destination matrix are interpolated numerically, and the result is used to set the translation of the animating element.

Quaternions of the decomposed source matrix are interpolated with quaternions of the decomposed destination matrix using the spherical linear interpolation (Slerp) as described by the pseudo code below:

<pre>
Input:  quaternionA   ; a 4 component vector
				quaternionB   ; a 4 component vector
				t             ; interpolation parameter with 0 <= t <= 1
Output: quaternionDst ; a 4 component vector


product = dot(quaternionA, quaternionB)

// Clamp product to -1.0 <= product <= 1.0
product = min(product, 1.0)
product = max(product, -1.0)

if (abs(product) == 1.0)
	 quaternionDst = quaternionA
	 return

theta = acos(product)
w = sin(t * theta) / sqrt(1 - product * product)

for (i = 0; i < 4; i++)
	quaternionA[i] *= cos(t * theta) - product * w
	quaternionB[i] *= w
	quaternionDst[i] = quaternionA[i] + quaternionB[i]

return</pre>

### Recomposing to a 3D matrix ### {#recomposing-to-a-3d-matrix}

After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below:

<pre>
Input:  translation ; a 3 component vector
				scale       ; a 3 component vector
				skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
				perspective ; a 4 component vector
				quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

Supporting functions (matrix is a 4x4 matrix):
	matrix  multiply(matrix a, matrix b)   returns the 4x4 matrix product of a * b

// apply perspective
for (i = 0; i < 4; i++)
	matrix[i][3] = perspective[i]

// apply translation
for (i = 0; i < 4; i++)
	for (j = 0; j < 3; j++)
		matrix[3][i] += translation[j] * matrix[j][i]

// apply rotation
x = quaternion[0]
y = quaternion[1]
z = quaternion[2]
w = quaternion[3]

// Construct a composite rotation matrix from the quaternion values
// rotationMatrix is a identity 4x4 matrix initially
rotationMatrix[0][0] = 1 - 2 * (y * y + z * z)
rotationMatrix[0][1] = 2 * (x * y - z * w)
rotationMatrix[0][2] = 2 * (x * z + y * w)
rotationMatrix[1][0] = 2 * (x * y + z * w)
rotationMatrix[1][1] = 1 - 2 * (x * x + z * z)
rotationMatrix[1][2] = 2 * (y * z - x * w)
rotationMatrix[2][0] = 2 * (x * z - y * w)
rotationMatrix[2][1] = 2 * (y * z + x * w)
rotationMatrix[2][2] = 1 - 2 * (x * x + y * y)

matrix = multiply(matrix, rotationMatrix)

// apply skew
// temp is a identity 4x4 matrix initially
if (skew[2])
		temp[2][1] = skew[2]
		matrix = multiply(matrix, temp)

if (skew[1])
		temp[2][1] = 0
		temp[2][0] = skew[1]
		matrix = multiply(matrix, temp)

if (skew[0])
		temp[2][0] = 0
		temp[1][0] = skew[0]
		matrix = multiply(matrix, temp)

// apply scale
for (i = 0; i < 3; i++)
	for (j = 0; j < 4; j++)
		matrix[i][j] *= scale[i]

return</pre>


Interpolation of primitives and derived transform functions {#interpolation-of-transform-functions}
===================================================================================================

Two transform functions with the same name and the same number of arguments are interpolated numerically without a former conversion. The calculated value will be of the same transform function type with the same number of arguments. Special rules apply to <<matrix()>>, <<matrix3d()>> and <<perspective()>>.

The transform functions <<matrix()>>, ''matrix3d()'' and ''perspective()'' get converted into 4x4 matrices first and interpolated as defined in section <a href="#matrix-interpolation">Interpolation of Matrices</a> afterwards.

For interpolations with the primitive ''rotate3d()'', the direction vectors of the transform functions get normalized first. If the normalized vectors are not equal and both rotation angles are non-zero the transform functions get converted into 4x4 matrices first and interpolated as defined in section <a href="#matrix-interpolation">Interpolation of Matrices</a> afterwards. Otherwise the rotation angle gets interpolated numerically and the rotation vector of the non-zero angle is used or (0, 0, 1) if both angles are zero.

<div class="example">

The two transform functions ''translate(0)'' and ''translate(100px)'' are of the same type, have the same number of arguments and therefore can get interpolated numerically. ''translateX(100px)'' is not of the same type and ''translate(100px, 0)'' does not have the same number of arguments, therefore these transform functions can not get interpolated without a former conversion step.

</div>

Two different types of transform functions that share the same primitive, or transform functions of the same type with different number of arguments can be interpolated. Both transform functions need a former conversion to the common primitive first and get interpolated numerically afterwards. The computed value will be the primitive with the resulting interpolated arguments.

<div class="example">

The following example describes a transition from ''translateX(100px)'' to ''translateY(100px)'' in 3 seconds on hovering over the div box. Both transform functions derive from the same primitive ''translate()''
and therefore can be interpolated.

  <pre><code highlight=css>
  div {
    transform: translateX(100px);
  }

  div:hover {
    transform: translateY(100px);
    transition: transform 3s;
  }
  </code></pre>

For the time of the transition both transform functions get transformed to the common primitive. ''translateX(100px)'' gets converted to ''translate(100px, 0)'' and ''translateY(100px)'' gets converted to ''translate(0, 100px)''. Both transform functions can then get interpolated numerically.
</div>

If both transform functions share a primitive in the two-dimensional space, both transform functions get converted to the two-dimensional primitive. If one or both transform functions are three-dimensional transform functions, the common three-dimensional primitive is used.

<div class="example">

In this example a two-dimensional transform function gets animated to a three-dimensional transform function. The common primitive is ''translate3d()''.

  <pre><code highlight=css>
  div {
    transform: translateX(100px);
  }

  div:hover {
    transform: translateZ(100px);
    transition: transform 3s;
  }
  </code></pre>

First ''translateX(100px)'' gets converted to ''translate3d(100px, 0, 0)'' and ''translateZ(100px)'' to ''translate3d(0, 0, 100px)'' respectively. Then both converted transform functions get interpolated numerically.

</div>


Addition and accumulation of transform lists {#combining-transform-lists}
============================================

<div algorithm="transform list addition">
  <a lt="value addition">Addition</a> of two transform lists
  <var>V<sub>a</sub></var> and <var>V<sub>b</sub></var>
  is defined as [=list=] concatenation
  such that <var ignore>V<sub>result</sub></var> is equal to
  <var>V<sub>b</sub></var> [=list/appended=] to
  <var>V<sub>a</sub></var>.
</div>

<div algorithm="transform list accumulation">
  <a lt="value accumulation">Accumulation</a> of two transform lists
  <var>V<sub>a</sub></var> and <var>V<sub>b</sub></var>
  follows the same steps as interpolation
  with regards to matching transform functions including
  padding lists with <a>identity transform functions</a>,
  converting ''transform/none'' to an <a>identity transform function</a>,
  and converting both arguments to matrices as necessary (see
  [[css-transforms-1#interpolation-of-transforms]]).
  However, instead of interpolating the individual parameters,
  they are combined using arithmetic addition--
  except in the case of parameters whose value is one in the
  <a>identity transform function</a>
  (e.g. scale parameters and matrix elements
  <var ignore>m11</var>, <var ignore>m22</var>,
  <var ignore>m33</var>, and <var ignore>m44</var>),
  which combine using <dfn export>accumulation for one-based values</dfn>
  as follows:

    <var ignore>V<sub>result</sub></var> =
    <var>V<sub>a</sub></var> + <var>V<sub>b</sub></var> - 1

  <div class="note">
    The above definition preserves the intent of <a lt="value
    accumulation">accumulation</a> which is that
    <var>V<sub>b</sub></var> acts as
    a delta from <var>V<sub>a</sub></var>
    and allows an animation such as:

    <pre class="lang-javascript">
    div.animate(
      { transform: ['scale(1)', 'scale(2)'] },
      {
        duration: 1000,
        easing: 'ease',
      }
    );
    </pre>

    to produce the expected behavior when extended as follows:

    <pre class="lang-javascript">
    div.animate(
      { transform: ['scale(1)', 'scale(2)'] },
      {
        duration: 1000,
        easing: 'ease',
        <strong>iterations: 5,
        iterationComposite: 'accumulate',</strong>
      }
    );
    </pre>
  </div>
</div>

Neutral element for addition {#neutral-element}
----------------------------

Some animations require a neutral element for addition. For transform functions this is a scalar or a list of scalars of 0. Examples of neutral elements for transform functions are ''translate(0)'', ''translate3d(0, 0, 0)'', ''translateX(0)'', ''translateY(0)'', ''translateZ(0)'', ''scale(0)'', ''scaleX(0)'', ''scaleY(0)'', ''scaleZ(0)'', ''rotate(0)'', ''rotate3d(v<sub>x</sub>, v<sub>y</sub>, v<sub>z</sub>, 0)'' (where <var ignore>v</var> is a context dependent vector), ''rotateX(0)'', ''rotateY(0)'', ''rotateZ(0)'', ''skew(0, 0)'', ''skewX(0)'', ''skewY(0)'', ''matrix(0, 0, 0, 0, 0, 0)'', ''matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'' and ''perspective(none)''.

Note: Animations to or from the neutral element of additions <<matrix()>>, ''matrix3d()'' and ''perspective()'' fall back to discrete animations (See [[#matrix-interpolation]]).


Mathematical Description of Transform Functions {#mathematical-description}
===============================================

Mathematically, all transform functions can be represented as 4x4 transformation matrices of the following form:

$$\begin{bmatrix} m11 & m21 & m31 & m41 \\ m12 & m22 & m32 & m42 \\ m13 & m23 & m33 & m43 \\ m14 & m24 & m34 & m44 \end{bmatrix}$$

One translation unit on a matrix is equivalent to 1 pixel in the local coordinate system of the element.

<ul>
	<li id="Translate3dDefined">
			A 3D translation with the parameters <em>tx</em>, <em>ty</em> and <em>tz</em> is equivalent to the matrix:

		$$\begin{bmatrix} 1 & 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & tz \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

	<li id="Scale3dDefined">
			A 3D scaling with the parameters <em>sx</em>, <em>sy</em> and <em>sz</em> is equivalent to the matrix:

		$$\begin{bmatrix} sx & 0 & 0 & 0 \\ 0 & sy & 0 & 0 \\ 0 & 0 & sz & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

	<li id="Rotate3dDefined">
			A 3D rotation with the vector [x,y,z] and the parameter <em>alpha</em> is equivalent to the matrix:

		$$\begin{bmatrix} 1 - 2 \cdot (y^2 + z^2) \cdot sq & 2 \cdot (x \cdot y \cdot sq - z \cdot sc) & 2 \cdot (x \cdot z \cdot sq + y \cdot sc) & 0 \\ 2 \cdot (x \cdot y \cdot sq + z \cdot sc) & 1 - 2 \cdot (x^2 + z^2) \cdot sq & 2 \cdot (y \cdot z \cdot sq - x \cdot sc) & 0 \\ 2 \cdot (x \cdot z \cdot sq - y \cdot sc) & 2 \cdot (y \cdot z \cdot sq + x \cdot sc) & 1 - 2 \cdot (x^2 + y^2) \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

			where:

		$$sc = \sin (\alpha/2) \cdot \cos (\alpha/2)$$
		$$sq = \sin^2 (\alpha/2)$$

			and where x, y, and z have been normalized
			(that is,
			where the x, y, and z values given
			have been divided by
			the square root of the sum of their squares).

			<div class=note>
			Note that this means that a rotation around the X axis simplifies to:

			$$\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 - 2 \cdot sq & -2 \cdot sc & 0 \\ 0 & 2 \cdot sc & 1 - 2 \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

			a rotation around the Y axis simplifies to:

			$$\begin{bmatrix} 1 - 2 \cdot sq & 0 & 2 \cdot sc & 0 \\ 0 & 1 & 0 & 0 \\ -2 \cdot sc & 0 & 1 - 2 \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

			and a rotation around the Z axis simplifies to:

			$$\begin{bmatrix} 1 - 2 \cdot sq & -2 \cdot sc & 0 & 0 \\ 2 \cdot sc & 1 - 2 \cdot sq & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$
			</div>

	<li id="PerspectiveDefined">
			A perspective projection matrix with the parameter <var>d</var> is equivalent to the matrix:

			$$\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/d & 1 \end{bmatrix}$$

			If the parameter <var>d</var> is ''perspective()/none'' it is treated as infinity
			(and the resulting matrix is the identity matrix).

</ul>

The SVG 'transform' Attribute {#svg-transform}
=============================

This specification will also introduce the new presentation attributes 'transform-origin', 'perspective', 'perspective-origin', 'transform-style' and 'backface-visibility'.

Values on new introduced presentation attributes get parsed following the syntax rules on <a>SVG Data Types</a> [[!SVG11]].


SVG Animation {#svg-animation}
=============

The <{animate}> and <{set}> element {#svg-animate-element}
-----------------------------------

The introduce presentation attributes 'perspective', 'perspective-origin', 'transform-style' and 'backface-visibility' are animatable. 'transform-style' and 'backface-visibility' are non-additive.


More Issues {#more-issues}
==========================

Issue: Per <a href="https://lists.w3.org/Archives/Public/www-style/2015Mar/0371.html">https://lists.w3.org/Archives/Public/www-style/2015Mar/0371.html</a>,
the WG resolved to add a formula for decomposing a transform into a unified "scale"
(the spec already defines how to decompose it into scaleX/Y/Z),
for use by things like SVG's non-scaling stroke spec.
<a href="https://www.w3.org/Graphics/SVG/WG/wiki/Proposals/Specifying_decomposition_of_scale">Formula is defined here.</a>

Security and Privacy Considerations {#priv-sec}
===============================================

This specification introduces no new security or privacy considerations.

<h2 class="no-num" id="changes">
Changes</h2>

<h3 class="no-num" id="changes-recent">
Recent Changes</h3>

	Substantive changes since <a href="https://www.w3.org/TR/2021/WD-css-transforms-2-20211109/">9 November 2021 WD</a>:

	<i>None yet</i>

	Substantive changes since <a href="https://www.w3.org/TR/2020/WD-css-transforms-2-20200303/">3 March 2020 WD</a>:

	<ul>
		<li>The specification no longer requires maintaining state for whether individual transform properties have 2D or 3D values, but instead requires that any value that can be expressed as 2D is treated as 2D (see <a href="https://github.com/w3c/csswg-drafts/issues/3305">#3305</a>).

			Note: An analogous change is intended for transform functions, but it has not been made yet.
		</li>
		<li>The 'scale' property and ''scale()'', ''scaleX()'' and ''scaleY()'' functions now support percentages (see <a href="https://github.com/w3c/csswg-drafts/issues/3399">#3399</a>).</li>
		<li>Fix multiple definitions to be consistent with the spec's definition for a 3D Rendering Context:
			<ul>
				<li>Define that borders, backgrounds, and box decorations of an element establishing a 3D Rendering Context are rendered at z=0 in its 3D scene, rather than behind its 3D scene (see <a href="https://github.com/w3c/csswg-drafts/issues/6238">#6238</a>).</li>
				<li>Define [=accumulated 3D transformation matrix=] to include the 'transform' of the establishing element and the 'perspective' of its parent (see <a href="https://github.com/w3c/csswg-drafts/issues/6191">#6191</a>).</li>
			</ul>
		</li>
		<li>Define that paint containment is a grouping property (see <a href="https://github.com/w3c/csswg-drafts/issues/6202">#6202</a>).</li>
		<li>Add support for a ''perspective()/none'' argument to ''perspective()'' (see <a href="https://github.com/w3c/csswg-drafts/issues/6488">#6488</a>).</li>
		<li>Define that clamping of values of ''perspective()'' also applies to resolved values and interpolation (see <a href="https://github.com/w3c/csswg-drafts/issues/6320">#6320</a> and <a href="https://github.com/w3c/csswg-drafts/issues/6346">#6346</a>).</li>
		<li>Clarify that the effects of ''transform-style/preserve-3d'' only affect <a>transformable elements</a> (see <a href="https://github.com/w3c/csswg-drafts/issues/6430">#6430</a>).</li>
		<li>Fixed the <a href="#neutral-element">neutral element for addition</a> for ''perspective()'' to be ''perspective(none)''
		<li>Added a note that the resolved value of 'translate' includes percentages (see <a href="https://github.com/w3c/csswg-drafts/issues/2124">#2124</a>).</li>
		<li>Describe 3D sorting more precisely, to explain which descendants are included, and not limit Appendix E reference to steps 1-7 (see <a href="https://github.com/w3c/csswg-drafts/issues/926">#926</a>).</li>
	</ul>

