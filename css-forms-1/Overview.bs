<pre class='metadata'>
Title: CSS Form Styling Module Level 1
Shortname: css-forms
Level: 1
Group: csswg
Status: UD
Work Status: Exploring
ED: https://drafts.csswg.org/css-forms/
Editor: Tim Nguyen, w3cid 137443, Apple Inc. https://apple.com/, ntim@apple.com
Abstract: This document is currently a loosely-structured set of ideas and inspiration for CSS form styling.
	It is not an implementable standard. Do not look at this as anything but a collection of ideas.
Warning: not ready
</pre>

# Pseudo-Elements # {#pseudo-elements}

This section defines some pseudo-elements for styling parts of form elements.

## Styling form control pickers: the ''::picker()'' pseudo-element ## {#picker-pseudo-element}

  The <dfn>::picker()</dfn> pseudo-element targets the popup picker of form
  control elements which have popup pickers, such as the <{select}> element. It
  is an [=element-backed pseudo-element=].

  <pre class=prod>
    ::picker() = ::picker( <<ident>>+ )
  </pre>

  Note: Once all of the controls that might support picker styling have it,
  then we might add a (no-argument) ''::picker'' pseudo-element as well.

  The ''::picker()'' pseudo-element only matches when the <a>originating
  element</a> supports <a>base appearance</a> and has a popup picker. The
  specified <<ident>> must also match the <dfn>unique picker name</dfn> of the
  <a>originating element</a>. For example, the <a>unique picker name</a> for
  the <{select}> element is "select".

  Since it is an [=element-backed pseudo-element=], There is no restriction on which
  properties apply to the ''::picker()'' pseudo-element.

  In order for the ''::picker()'' pseudo-element to be rendered, it and its
  <a>originating element</a> must be rendered with <a>base appearance</a> by
  applying ''appearance: base'' to both of them.

  <pre class="example">
&lt;style>
  select, select::picker(select) {
    appearance: base;
  }
  select::picker(select) {
    border: 5px solid red;
    background-color: blue;
  }
&lt;/style>
  </pre>

## Picker opener icon: the ''::picker-icon'' pseudo-element ## {#picker-icon-pseudo-element}

  The ''::picker-icon'' pseudo-element is only generated when the
  <a>originating element</a> has <a>base appearance</a> and opens a picker.

  ''::picker-icon'' is a [=tree-abiding pseudo-element=]. It accepts all
  properties. It inherits from its [=originating element=].

  ''::picker-icon'' generates a box as if it was an child of its
  <a>originating element</a>, after any boxes generated by the ''::after''
  pseudo-element, with content as specified by 'content'.

## Checkmark icon: the ''::checkmark'' pseudo-element ## {#checkmark-element}

  The '::checkmark'' pseudo-element is only generated when the <a>originating
  element</a> supports the <a>:checked</a> pseudo-class and either has <a>base
  appearance</a> or an ancestor with <a>base appearance</a>.

  ''::checkmark'' is a [=tree-abiding pseudo-element=]. It accepts all properties.
  It inherits from its [=originating element=].

  ''::checkmark'' generates a box as if it was an child of its <a>originating
  element</a>, preceding any boxes generated by the ''::before''
  pseudo-element, with content as specified by 'content'.

## Styling parts of [=slider-like controls=]: the ''::slider-thumb'', ''::slider-track'', ''::slider-fill'' and ''::slider-options-track'' pseudo-elements ## {#slider-pseudos}

  <dfn>Slider-like controls</dfn> are form controls that represent progress.
  That progress may be adjustable by the user.

  The list of [=slider-like controls=] depends on the host language. For HTML, this corresponds to:

  - ''&lt;progress>''
  - ''&lt;meter>''
  - ''&lt;input>'' elements with `type="range"`
  - ''&lt;input>'' elements with `type="checkbox" switch`


  The following pseudo-elements are provided to style their different parts:

  <dl export>
    <dt><dfn>::slider-thumb</dfn>
    <dd>
      The ''::slider-thumb'' pseudo-element represents
      the portion that allows the user to adjust the progress of the control.

      That portion may be omitted for controls where the progress is not adjustable.
      Disabled controls should provide this portion if the enabled state allows adjusting the progress.

      NOTE: It is typically natively rendered as a circle in most user agents.

    <dt><dfn>::slider-track</dfn>
    <dd>
      The ''::slider-track'' pseudo-element represents the portion containing
      both the progressed and unprogressed portions of the control.

    <dt><dfn>::slider-fill</dfn>
    <dd>
      The ''::slider-fill'' pseudo-element represents
      the portion containing the progressed portion of the control.

      When the progress of control is undetermined (like with ''&ltprogress indeterminate>''),
      the user agent is expected to give this portion an inline-size of zero.

    <dt><dfn>::slider-options-track</dfn>
    <dd>
      The ''::slider-options-track'' pseudo-element represents the portion containing
      the options. It is expected to render at the same width as ''::slider-track''
      and underneath it in the block direction.

      With `appearance: auto`, the user agent may draw tickmarks
      corresponding to the options given by the associated `<datalist>`.
  </dl>

  These pseudo-elements are [=tree-abiding pseudo-elements=] and their structure is expected to be the following:

  ```
      <input type="range">
      ├─ ::slider-track
      │  └─ ::slider-fill
      ├─ ::slider-thumb
      └─ ::slider-options-track
  ```

<h2 class="no-num non-normative" id="changes">Appendix: Explorations</h2>

## Basic Styling Proposals ## {#ideas}

This section sketches a few proposals for solving the form styling problem.

### Prototypes ### {#prototypes}

This idea, originally suggested by fantasai,
is that we can style a handful of "prototype" elements.
Browser UI designers can then take the styling of those elements
and extrapolate the design into their own UIs.
At minimum, things like text, backgrounds, and borders can be used.
At the limit, things like internal padding, border-radius, etc might be used.

<pre class='lang-css'>
	@control button {
		&lt;declaration-list>
	}

	@control input {
		&lt;declaration-list>
	}

	input::selection {
		&lt;declaration-list>
	}

	...
</pre>

<blockquote cite="https://lists.w3.org/Archives/Public/www-style/2015Jan/0490.html">
	You would be able to use styles for:

	* font selection (css-fonts)
	* text decoration (css-text-decor)
	* text layout (css-text)
	* backgrounds & drop-shadow (css-backgrounds)
	* borders & padding (css-backgrounds)
	* filters
	* anything else we or a UA decides seems relevant

	Most form controls, even a calendar widget or clock, are a combination of
	these three primitives in some way. If the UA is given the styling for
	these three primitives, and perhaps one or two more it can figure out how
	to style the rest.

	For example, a calendar widget might have the month, the year, some buttons
	to move them around, the ability to click into them and edit them directly,
	and a representation of the days of the month. The selected day is selected.
	Perhaps the buttons only show up on :hover or :focus -- the UA decides. But
	it knows that a button should be this particular shade of blue with that
	particular border-radius and drop-shadow. The calendar might be shown in the
	colors of the input field, and the selected day in the selection color, and
	in all ways it will match the way the input fields look in the rest of the
	page.

	Now, the author can't decide, for example, the spacing between the year
	and the month name, or whether the button to change years has a solid
	arrow or a hollow arrow or a frilly one, and she can't decide that there
	should be a black solid half-border between the month and the day field
	below it with 5px spacing. But the calendar will look like it belongs to
	the page, and the UA can come up with a different calendar layout when it
	ships one on a wide but short smart watch where the month and year are
	better placed on the side without breaking anything.
</blockquote>

<div class='example'>
	<img src=images/time01.png>

	<blockquote cite="https://lists.w3.org/Archives/Public/www-style/2015Jan/0622.html">
		The black area is the button color; a very light transparency of it
		can be the glass color. The rollers are the input colors.
	</blockquote>
</div>

<div class='example'>
	<img src=images/time02.png>

	<blockquote cite="https://lists.w3.org/Archives/Public/www-style/2015Jan/0622.html">
		It's hard to tell without more context, but for the one on the right,
		the clock face and the digital readout are @input colors, the highlighted
		bits are the highlight color, the Done button is the button styling,
		and the shaded area around the clock face is the same color as the
		button background.
</div>


### Inverse System Colors ### {#inverse-system}

This idea, originally sketched by Florian and Tab,
is to define an abstract set of colors
that UI designers can then choose from when coloring their UI.

Tab's suggested set of colors, from an Android color-extraction API proposal:

* Light/Normal/Dark Vibrant
* Light/Normal/Dark Muted
* Vibrant Complementary (for call-out buttons and such that need to be visually distinct)

(where light ~75% lightness, normal is ~50%, dark is ~25%; vibrant is
at least 30% saturation, ideally 100%, and muted is at most 40%
saturation, ideally 30%)

* Light/Dark Contrasting Text
* Light/Dark Contrasting Secondary Text

That's 11 colors, many of which should be drawable from the webpage's own color scheme.
We can auto-gen a bunch of them if you specify at least some of them,
like genning the light/dark variants from the "normal-vibrant" color,
or automatically setting text colors to white/black as appropriate.

There's no guarantee that the input UIs will use the colors in the *same way* that the rest of the page does, though.

## Miscellaneous Control-Specific Suggestions ## {#misc}

Issue: <a href="http://blog.teamtreehouse.com/use-meter-progress-elements">&lt;progress> and &lt;meter> styling</a>

Issue: Insert &lt;select> and &lt;datalist> styling proposal and/or whiteboard photo.

### Select/Datalist Dropdown ### {#select-dropdown}

1. Only allow styling if both 'color!!property' and 'background' are set.
2. Option container:
	* backgrounds
	* borders
	* padding
3. <{option}>
	* padding
	* borders
	* border-collapse?
	* backgrounds
	* display-inside is allowed, automatically blockified
	* not margins, position, float, width, height

	All options are contain:paint and BFCs.


## Input UI Examples ## {#examples}


This section catalogues as many input UI examples as we can screenshot,
especially on mobile devices where they're a bit "weirder".

### Time Pickers ### {#time-examples}

<figure>
	<img src="images/time01.png">
	<figcaption>iOS time picker</figcaption>
</figure>

<figure>
	<img src="images/time02.png">
	<figcaption>Android time picker 1</figcaption>
</figure>

<figure>
	<img src="images/time03.png">
	<figcaption>Android time picker 2</figcaption>
</figure>

### Date Pickers ### {#date-examples}

<figure>
	<img src="images/date01.png">
	<figcaption>Android date picker</figcaption>
</figure>
