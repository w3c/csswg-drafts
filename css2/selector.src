<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0 Transitional//EN'>
<html lang="en">
<!-- $Id: selector.src,v 2.27 1998-03-16 14:33:13 ijacobs Exp $ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Selectors</title>
</head>
<body>
<h1 align="center">Selectors</h1>

<h2>Pattern matching</h2>

<p>In CSS, pattern matching rules determine which style rules apply to
elements in the <a href="conform.html#doctree">document
tree</a>. These patterns, called <span class="index-inst"
title="selector">selectors,</span> may range from simple element names
to rich contextual patterns. If all conditions in the pattern are true
for a certain element, the selector <span class="index-def"
title="match|selector::match"><dfn>matches</dfn></span> the element.

<P>The case-sensitivity of document language element names in
selectors depends on the document language. For example, in HTML,
element names are case-insensitive, but in XML they are
case-sensitive.

<P>The following table summarizes CSS2 selector syntax:</P>

<table border>
<TR><TH>Pattern<TH>Meaning<TH>Described in section</TR>
<TR><TD>*<TD>Matches any element.<TD><a href="#universal-selector">Universal
selector</a></TR>
<TR><TD>E<TD>Matches any element of type E.<TD><a href="#type-selectors">Type
selectors</a></TR>
<TR><TD>A B<TD>Matches any B element that is a descendant of
an A element.<TD><a href="#descendant-selectors">Descendant
selectors</a></TR>
<TR><TD>A &gt; B<TD>Matches any B element that is a child of
an element A.<TD><a href="#child-selectors">Child selectors</a></TR>
<TR><TD>E:first-child<TD>Matches element E when E is the first
child of some other element
<TD><a href="#first-child">The :first-child pseudo-class</a></TR>

<TR><TD>E:link<br>E:visited <TD>Matches element E if E is the source
anchor of a hyperlink of which the target is not yet visited (:link)
or already visited (:visited)
<TD><a href="#link-pseudo-classes">The link pseudo-classes</a></TR>

<TR><TD>E:target<TD>Matches element E if E is the target 
anchor of the current document
<TD><a href="#target-pseudo-class">The target pseudo-class</a></TR>

<TR><TD>E:active<br>E:hover<br>E:focus <TD>Matches E during certain
user actions
<TD><a href="#dynamic-pseudo-classes">The dynamic pseudo-classes</a>
<TR><TD>E:lang(c) <TD>Matches element of type E if it is in (human) language c
(the document language specifies how language is determined)
<TD><a href="#lang">The :lang() pseudo-class</a>
<TR><TD>E + F<TD>Matches any F element immediately preceded by
an element E.<TD><a href="#adjacent-selectors">Adjacent selectors</a>
</TR>
<TR><TD>E[foo]<TD>Matches any E element with the
"foo" attribute set (whatever the value).
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>E[foo="warning"]<TD>Matches any E element whose
"foo" attribute value is exactly equal to "warning".
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>E[foo~="warning"]<TD>Matches any E element whose
"foo" attribute value is a list of space-separated 
of values, one of which is exactly equal to "warning".
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>E[lang|="en"]<TD>Matches any E element whose
"lang" attribute has a hyphen-separated list of values
beginning (from the left) with "en".
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>DIV.warning<TD><em>HTML only</em>. The same as DIV[class~="warning"].
<TD><a href="#class-html">The "class" attribute in HTML</a></TR>
<TR><TD>E#myid<TD>Matches any E element with the "id" attribute
equal to "myid".<TD><a href="#id-selectors">ID selectors</a></TR>
</table>


<h2>Selector syntax</h2>

<P>A <span class="index-def" title="simple selector"><a
name="simple-selector"><dfn>simple
selector</dfn></a></span> is either a <a href="#type-selectors">type
selector</a> or <a href="#universal-selector">universal selector</a>
followed immediately by zero or more <a
href="#attribute-selectors">attribute selectors</a>, optionally
followed immediately by an <a href="#id-selectors">ID selector</a>,
optionally followed immediately by a <a
href="#pseudo-classes">pseudo-class</a>.  Each component specifies a
requirement of an element, and the simple selector requires the
logical AND of those requirements.  


<P>A <span class="index-def"
title="selector"><dfn>selector</dfn></span> is a chain of one or more
simple selectors separated by combinators (plus optional whitespace).
The elements of the document tree that match a selector are called
<span class="index-def" title="subject (of selector)|selector::subject
of"><a name="subject"><dfn>subjects</dfn></a></span> of the selector.
A selector consisting of a single simple selector matches any element
satisfying its requirements.  Prepending a simple selector and
combinator to a chain imposes additional matching constraints, so the
subjects of a selector are always a subset of the elements matching
the rightmost simple selector.

<P>One <a href="#pseudo-elements">pseudo-element</a> may be appended
to the last simple selector in a chain, in which case the style
information applies to a subpart of the subjects.

<h3><a name="grouping">Grouping</a></h3>

<p>When several selectors share the same declarations, they may be
grouped into a comma-separated list.</p>

<div class="example">
<P>In this example, we condense three rules with identical declarations
into one. Thus,

<pre>
H1 { font-family: Helvetica }
H2 { font-family: Helvetica }
H3 { font-family: Helvetica }
</pre>

<p>is equivalent to:</p>

<pre>
H1, H2, H3 { font-family: Helvetica }
</pre>
</div>

<P>CSS offers other "shorthand" mechanisms as well, including <a
href="syndata.html#declaration">multiple declarations</a> and <a
href="about.html#shorthand">shorthand properties</a>.

<h2><a name="universal-selector">Universal selector</a></h2>

<P>The <span class="index-def" title="universal selector">universal
selector</span>, written "*", matches the name of any element
type. It matches any single element in the <a
href="conform.html#doctree">document tree.</a>


<P>If the universal selector is not the only component of a <a
href="#simple-selector">simple selector</a>, the '*' may be
omitted. <!-- However, we recommend that authors always include the "*" for
clarity. --> For example:</P>

<ul>
<li>*[LANG=fr] and [LANG=fr] are equivalent.
<li>*.warning and .warning are equivalent.
<li>*#myid and #myid are equivalent.
</ul>

<h2><a name="type-selectors">Type selectors</a></h2>

<p>A <span class="index-def" title="type selector"><em>type
selector</em></span> matches the name of a document language element
type. A type selector matches every instance of the element type in
the document tree.

<div class="example">
<P>The following rule matches all H1 elements in the
document tree:</p>

<pre>
H1 { font-family: Helvetica }
</pre>
</div>

<h2><a name="descendant-selectors">Descendant selectors</a></h2>

<p>At times, authors may want selectors to match an element that is
the descendant of another element in the document tree (e.g., "Match
those EM elements that are contained by an H1 element").
<span class="index-def" title="descendant-selectors">Descendant
selectors</span> express such a relationship in a pattern.
A descendant selector matches when an element B is an arbitrary
descendant of some <a href="conform.html#doctree">ancestor</a> element
A. A descendant selector is made up of two or more selectors separated
by <a href="syndata.html#whitespace">whitespace</a>.

<div class="example"><p>
For example, consider the following rules:</p>

<pre>
H1 { color: red }
EM { color: red }
</pre>

<p>Although the intention of these rules is to add emphasis to text by
changing its color, the effect will be lost in a case such as:</p>

<pre class="html-example">
&lt;H1&gt;This headline is &lt;EM&gt;very&lt;/EM&gt; important&lt;/H1&gt;
</pre>

<p>We address this case by supplementing the previous rules with a
rule that sets the text color to blue whenever an EM occurs anywhere
within an H1:</p>

<pre>
H1 { color: red }
EM { color: red }
H1 EM { color: blue }
</pre>

<p>The third rule will match the EM in the following fragment:</p>

<pre class="html-example">
&lt;H1&gt;This &lt;SPAN class="myclass"&gt;headline 
is &lt;EM&gt;very&lt;/EM&gt; important&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
</div>

<div class="example"><P>
The following selector:</p>

<PRE>
DIV * P 
</PRE>

<P>matches a P element that is a grandchild or later descendant
of a DIV element.
</div>

<div class="example"><p>
The selector in the following rule, which combines
descendant and <a href="#attribute-selectors">attribute selectors</a>,
matches any element with an "href" attribute
inside a P that is itself inside a DIV:</p>

<pre>
DIV P *[href]
</pre>
</div>

<h2><a name="child-selectors">Child selectors</a></h2>

<p>A <span class="index-def" title="child selector"><em>child
selector</em></span> matches when an element is the <a
href="conform.html#doctree">child</a> of some element. A child
selector is made up of two or more selectors separated by "&gt;".

<div class="example"><p>
The following rule sets the style of all P elements that 
are children of BODY:</p>

<pre>
BODY &gt; P { line-height: 1.3 }
</pre>
</div>

<div class="example"><P>
The following example combines descendant selectors and child selectors:</p>
<pre>
DIV OL &gt; LI P
</pre>

<P>matches a P element that is a descendant of an LI; the LI element
must be the child of an OL element; the OL element must be a
descendant of a DIV.
</div>

<P>For information on selecting the first child of an element, please
see the section on the <a href="#first-child">:first-child</a>
pseudo-class below.

<h2><a name="adjacent-selectors">Adjacent selectors</a></h2>

<p>Often, special formatting rules apply when two types of elements
appear next to each other in a document. For example, when block-level
elements are laid out, the vertical space between them collapses. In
this case, the special formatting is handled by the rules for <a
href="./visudet.html#collapsing-margins">collapsing margins,</a> but
in other cases of adjacent selectors, authors may want to specify
their own special formatting rules.</p>

<p>Adjacent selectors have the following syntax: E1 + E2, where E2
is the subject of the selector. The selector matches if E1 and E2
share the same parent in the document tree and E1 immediately precedes
E2.

<div class="example"><p>
Thus, the following rule states that when a P element immediately
follows a MATH element, it should not be indented:</p>

<pre>
MATH + P { text-indent: 0 } 
</pre>

<p>The next example reduces the vertical space separating
an H1 and an H2 that immediately follows it:</p>

<pre>
H1 + H2 { margin-top: -5mm }   
</pre>
</div>

<div class="example"><p> 
The following rule is similar to the one in the
previous example, except that it adds and attribute
selector. Thus, special formatting only occurs when
H1 has <samp>class="opener"</samp>:</p>

<pre>
H1.opener + H2 { margin-top: -5mm }   
</pre>
</div>

<h2><a name="attribute-selectors">Attribute selectors</a></h2>

<p>CSS2 allows authors to specify rules that match according to
attributes defined in the document language. 

<h3>Matching attributes and attribute values</h3>

<P>Attribute selectors may match in four ways:</p>

<dl>
<dt><code>[att]</code>
<dd>Match when the element sets the "att" attribute, whatever
the value of the attribute.
<dt><span class="index-def" title="exact
matching|="><code>[att=val]</code></span>
<dd>Match when the element's "att" attribute value is exactly "val".
<dt><span class="index-def" title="space-separated
matching|~="><code>[att~=val]</code></span>
<dd>Match when the element's "att" attribute value is a 
space-separated list of "words", one of which is exactly "val". 
If this selector is used, the words in the value must not contain
spaces (since they are separated by spaces).
<dt><span class="index-def" title="hyphen-separated
matching|&#124;="><code>[att|=val]</code></span>
<dd>Match when the element's "att" attribute value is a 
hyphen-separated list of "words", beginning with "val". The match
always starts at the beginning of the attribute value.
<!--If this selector is used, the words in the value must not contain
hyphens (since they are separated by hyphens).--> This is primarily
intended to allow <span class="index-inst" title="language
code">language subcode</span> matches (e.g., the "lang"
attribute in HTML) as described in RFC 1766 ([[-RFC1766]]).
</dl>

<p>Attribute values must be identifiers or strings. The
case-sensitivity of attribute names and values in selectors depends on
the document language.

<div class="example"><p>
For example, the following attribute selector 
matches all H1 elements that specify the "title" attribute, 
whatever its value:</p>

<pre>
H1[title] { color: blue; }
</pre>
</div>

<div class="example"><p>
In the following example, the selector matches all SPAN elements whose
"class" attribute has exactly the value "example":</p>

<pre>
SPAN[class=example] { color: blue; }
</pre>
</div>

<P>Multiple attribute selectors may refer to several attributes, in
which case the attribute parts must follow one another, in any order.

<div class="example"><p>
Here, the selector matches all SPAN elements whose
"hello" attribute has exactly the value "Cleveland" and whose
"goodbye" attribute has exactly the value "Columbus":</P>

<pre>
SPAN[hello="Cleveland"][goodbye="Columbus"] { color: blue; }
</pre>
</div>

<div class="example"><p>
The following selectors illustrate the differences between "=" and "~=".
The first selector will match, for example, the value 
"copyright copyleft copyeditor" for the "rel" attribute. The second
selector will only match when the "colspan" attribute has the value "2".
</p>

<pre>
A[rel~="copyright"]
TD[colspan="2"]
</pre>
</div>

<div class="example"><P>
The following rule hides all elements for which the value of the
"lang" attribute is "fr" (i.e., the language is French).

<PRE>
*[LANG=fr] { display : none }
</PRE>
</div>

<div class="example"><P>
The following rule will match for values of the "lang" attribute
that begin with "en", including "en", "en-US", and "en-cockney":</p>

<PRE>
*[LANG|="en"] { color : red }
</PRE>
</div>

<div class="example"><P>
Similarly, the following aural style sheet rules allow a script
to be read aloud in different voices for each role:</p>

<pre class="xml-example">
DIALOGUE[character=romeo] 
     { voice-family: "Lawrence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }
</pre>
</div>

<H3>Default attribute values in DTDs</H3>

<P>Matching takes place on attribute values in the document tree. For
document languages other than HTML, default attribute values may be
defined in a <span class="index-inst" title="DTD">DTD</span> or elsewhere. Style
sheets should be designed so that they work even if the default values
are not included in the document tree.

<div class="example">
<P>For example, consider an element EXAMPLE with an attribute NOTATION
that has a default value of "decimal". The DTD fragment might be

<pre class="xml-example">
&lt;!ATTLIST EXAMPLE NOTATION (decimal,octal) "decimal">
</pre>

<p>If the style sheet contains the rules

<pre class="example">
EXAMPLE[NOTATION=decimal] { ... default property settings ... }
EXAMPLE[NOTATION=octal] { ... other settings... }
</pre>

<p>then to catch the cases where this attribute is set by default,
and not explicitly, the following rule might be added:

<pre class="example">
EXAMPLE { ... default property settings ... }
</pre>

<p>Because this selector is less specific than a selector with another
specific attribute value, it will only be used for the default
case. Care has to be taken that all other attribute values that don't
get the same style as the default value are explicitly covered.
</div>


<h3><a name="class-html">Class selectors</a></h3> 

<p>For style sheets used with HTML, authors may use the dot (.)
notation as an alternative to the "~=" notation when matching on the
CLASS attribute. Thus, for HTML,
"DIV.value" and "DIV[class~=value]" have the same meaning. The
attribute value must immediately follow the ".".

<div class="example"><p>
For example, we can assign style information to all elements with
<samp>class~="pastoral"</samp> as follows:</p>

<pre>
*.pastoral { color: green }  /* all elements with class~=pastoral */
</pre>

<p>or just to H1 elements with <samp>class~="pastoral"</samp>:</p>

<pre>
H1.pastoral { color: green }  /* H1 elements with class~=pastoral */
</pre>

<p>Given these rules, the first H1 instance below would not have green
text, while the second would:</p>

<pre>
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>
</div>

<!--<p>The normal inheritance rules apply to classed elements; they
inherit values from their parent in the document structure.</p>-->

<p>To match a subset of "class" values, each value must be preceded
by a ".", in any order.</P>

<div class="example"><P>
For example, the following rule matches any P element whose "class" attribute
has been assigned a list of space-separated values that includes "pastoral"
and "marine":</p>

<pre> 
P.pastoral.marine { color: green }
</pre>

<p>This rule matches when <samp>class="pastoral blue aqua
marine"</samp> but does not match for <samp>class="pastoral
blue"</samp>.
</div>

<div class="note"><p> <em><strong>Note.</strong> CSS gives so much
power to the "class" attribute, that authors could conceivably design
their own "document language" based on elements with almost no
associated presentation (such as DIV and SPAN in HTML) and assigning
style information through the "class" attribute.  Authors should avoid
this practice since the structural elements of a document language
have recognized and accepted meanings and author-defined classes may
not.</em>
</div>

<h2><a name="id-selectors">ID selectors</a></h2>

<P>Document languages may contain attributes that are declared to be
of type ID.  What makes attributes of type ID special is that no two
such attributes can have the same value; whatever the document
language, an ID attribute can be used to uniquely identify its
element. In HTML, for example, all ID attributes are named "id"; XML
applications may name (multiple) ID attributes differently, but the
same restrictions apply.

<p>The ID attribute of a document language allows authors to assign an
identifier to one element instance in the document tree.  CSS ID
selectors match an element instance based on its identifier.  A CSS
ID selector contains a "#" immediately followed by the ID
value.</p>

<div class="example"><p> 
The following ID selector matches the H1 element whose ID
attribute has the value "chapter1":</p>

<PRE>
H1#chapter1 { text-align: center }
</PRE>
</div>

<div class="html-example"><p> 
In the following example, the style rule matches
any element that has the ID value "z98y".
The rule will thus match for the P element:</p>

<pre>
&lt;HEAD&gt;
&lt;TITLE&gt;Match P&lt;/TITLE&gt;
&lt;STYLE type="text/css"&gt;
   *#z98y { letter-spacing: 0.3em }
&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>

<p>In the next example, however, the style rule will only match an H1
element that has an ID value of "z98y". The rule will not match the
P element in this example:</p>

<pre>
&lt;HEAD&gt;
&lt;TITLE&gt;Match H1 only&lt;/TITLE&gt;
&lt;STYLE type="text/css"&gt;
   H1#z98y { letter-spacing: 0.5em }
&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>
</div>

<P>ID selectors have a higher precedence than attribute selectors.
For example, in HTML, the selector <samp>#p123</samp> is more specific
than <samp>[ID=p123]</samp> in terms of the <a
href="cascade.html">cascade</a>.

<!-- What to do if no DTD? -IJ -->


<h2><a name="pseudo-elements">Pseudo-elements</a> and <a
name="pseudo-classes">pseudo-classes</a></h2>

<p>In CSS2, style is normally attached to an element based on its
position in the <a href="conform.html#doctree">document tree</a>. This
simple model is sufficient for many cases, but some common publishing
scenarios may not be possible due to the structure of the <a
href="conform.html#doctree">document tree</a>. For instance, in HTML
4.0 (see [[HTML40]]), no element refers to the first line of a
paragraph, and therefore no simple CSS selector may refer to it.</p>

<p>CSS introduces the concepts of <span class="index-def"
title="pseudo-elements"><dfn>pseudo-elements</dfn></span> and <span
class="index-def"
title="pseudo-classes"><dfn>pseudo-classes</dfn></span> to permit
formatting based on information that lies outside the document
tree. </p>

<ul>
<li>Pseudo-elements create abstractions about the document tree beyond
those specified by the document language. For instance, document
languages do not offer mechanisms to access the first letter or first
line of an element's content. CSS pseudo-elements allow style sheet
designers to refer to this otherwise inaccessible
information. Pseudo-elements may also provide style sheet designers a
way to assign style to otherwise <a
href="visuren.html#anonymous">anonymous</a> content (e.g., the <a
href="generate.html#before-after-content">:before and :after</a>
pseudo-elements give access to generated content).

<li>Pseudo-classes classify elements on characteristics other than
their name, attributes or content; in principle characteristics that
cannot be deduced from the document tree. Pseudo-classes may be
dynamic, in the sense that an element may acquire or loose a
pseudo-class while a user interacts with the document. The exception
is <a href="#first-child">':first-child'</a>, which <em>can</em> be
deduced from the document tree.
</ul>

<P>Neither pseudo-elements nor pseudo-classes appear in the document
source or document tree.

<P>Pseudo-classes are allowed anywhere in selectors while
pseudo-elements may only appear after the <a
href="#subject">subject</a> of the selector.
</p>

<!--
<p>Although pseudo-elements and pseudo-classes do not exist in the
document tree, their behavior is defined as if they did. Each
pseudo-element and pseudo-class may be modeled by a <span
class="index-def" title="fictional tag sequence"><em>fictional tag
sequence,</em></span> a fragment of document source that includes
imaginary elements from the document language. The fictional tag
sequence is only a model used to describe the rendering effects of
pseudo-elements and pseudo-classes and does not indicate how these
should be implemented.

[Too strong. BB]-->

<p>Pseudo-elements and pseudo-class names are case-insensitive.</p>

<!--
<p>Several pseudo-element rules may have an impact on the same
content. These are called <span class="index-def" title="overlapping
pseudo-elements">overlapping pseudo-elements</span>. An <a
href="#overlapping-example">example</a> is provided below.

[Isn't this obvious? BB]-->

<P>Some pseudo-classes are mutually exclusive, while others can be
applied simultaneously to the same element. In case of conflicting
rules, the normal <a href="cascade.html#cascading-order">cascading
order</A> determines the outcome.


<!--
<P> Some common typographical effects are associated not with
structural elements but rather with typographical items as rendered. 
In CSS2, two such typographical items can be addressed
through <span class="index-inst"
title="pseudo-elements">pseudo-elements</span>: the first line of an
element, and the first letter.
-->

<p><a href="conform.html#conformance">Conforming HTML user agents</a>
may <span class="index-inst" title="ignore"><a
href="syndata.html#ignore">ignore</a></span> all rules with :first-line or
:first-letter in the selector, or, alternatively, may only support a
subset of the properties on these pseudo-elements.</P>

<h2>Pseudo-classes</h2>

<h3><a name="first-child">:first-child</a> pseudo-class</h3>

<P>The <span class="index-def"
title="first-child|:first-child">:first-child</span> pseudo-class
matches an element that is the first child of some other element.

<div class="example"><P>
In the following example, the selector matches any P element
that is the first child of a DIV element. The rule
suppresses indentation for the first paragraph of a DIV:</p>

<PRE>
  DIV &gt; P:first-child { text-indent: 0 }
</PRE>

<P>This selector would match the P inside the DIV of the
following fragment:</p>

<pre class="html-example">
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>

<p>but would not match the second P in the following
fragment:</p>

<pre class="html-example">
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;H2&gt;Note&lt;/H2&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>
</div>

<div class="example">
<p>The following rule sets the font weight to "bold" for any EM
element that is some descendant of a P element that is a first
child:</p>

<pre>
P:first-child EM { font-weight : bold }
</pre>
</div>

<P>Note that since <a href="visuren.html#anonymous">anonymous</a>
boxes are not part of the document tree, they are not counted when
calculating the first child.</p>

<div class="html-example"><P>
For example, the EM in:</p>

<PRE>
&lt;P&gt;abc &lt;EM&gt;default&lt;/EM&gt; 
</PRE>

<P>is the first child of the P.
</div>

<P>The following two selectors are equivalent:</p>

<PRE>
* &gt; A:first-child   /* A is first child of any element */
A:first-child          /* Same */
</PRE>


<h3><a name="link-pseudo-classes">The link pseudo-classes</a>: <span
class="index-def" title="pseudo-classes:::link|:link|link
(pseudo-class)">:link</span> and <span class="index-def"
title="pseudo-classes:::visited|:visited|visited
(pseudo-class)">:visited</span></h3>

<p>User agents commonly display unvisited links differently from
previously visited ones. CSS provides the pseudo-classes ':link' and
':visited' to distinguish them:</p>

<ul>
<li> The :link pseudo-class applies for links that have
not yet been visited.

<li> The :visited pseudo-class applies once the link has been
visited by the user.
</ul>

<p class="note"><strong>Note.</strong> After a certain amount of time,
user agents may choose to return a visited link to the (unvisited)
':link' state.

<P>The two states are mutually exclusive.

<p>The document language determines which elements are hyperlink
source anchors. For example, In HTML&nbsp;4.0, the link pseudo-classes
only apply to A elements with an "href" attribute. Thus, the following
two CSS2 declarations are equivalent:</p>

<pre>
A:link { color: red }
:link  { color: red }
</pre>

<!-- What about LINK? Why only A elements (WG still out on 
this)? What about XML? -IJ -->

<div class="example"><p>
If the following link:</p>

<pre class="html-example">
  &lt;P&gt;
  &lt;A class="external" href="http://out.side/"&gt;external link&lt;/A&gt;
</pre>

<P>has been visited, this rule:</p>

<pre>
  A.external:visited { color: blue }
</pre>

<P>will cause it to be blue.
</div>

<!--
<div class="example"><P>
Here's another example. The following rule:</p>

<pre>
  P.note:first-letter { color: red }
</pre>

<P>would make the first letter of all P elements with
<samp>class="note"</samp> such as the following, the color 'red',
as in:</p>

<pre class="html-example">
  &lt;P class="note"&gt;Note: Only valid until December 31.&lt;/P&gt;
</pre>
</div>
-->

<h3><a name="target-pseudo-class">The target pseudo-class</a>: <span
class="index-def" title="pseudo-classes:::target|:target|target
(pseudo-class)">:target</span></h3>

<P>Some URIs refer to a location within a resource. This kind of URI ends with "#" followed by an anchor identifier (called the fragment identifier).
<pre>
  P.note:first-letter { color: red }
</pre>


<P>URIs with fragment identifiers link to a certain element within the
document, known as the target element. For instance, here is a URI
pointing to an anchor named section_2:

<PRE>
  http://somesite.com/html/top.html#section_2
</PRE>

<P>The target element can be styled with the :target pseudo-class:

<pre>
  :target { color: red }
</pre>

<P>If the URI that has been followed has no fragment identifier, the
rule above will have no effect.


<h3><a name="dynamic-pseudo-classes">The dynamic pseudo-classes:</a>
<span class="index-def" title="pseudo-classes:::hover|:hover|hover
(pseudo-class)">:hover</span>, <span class="index-def"
title="pseudo-classes:::active|:active|active
(pseudo-class)">:active</span>, and <span class="index-def"
title="pseudo-classes:::focus|:focus|focus
(pseudo-class)">:focus</span></h3>

<p>Interactive user agents sometimes change the rendering in response
to user actions. CSS provides three pseudo-classes for common cases:</p>

<ul>
<li> The :hover pseudo-class applies while the user designates an
element (with some pointing device), but does not activate it. For
example, a visual user agent could apply this pseudo-class when the
cursor (mouse pointer) hovers over a box generated by the element.
User agents not supporting the
<a href="media.html#interactive-media-group">interactive media group</a>
do not have to support this pseudo-class.
Some conforming user agents supporting the
<a href="media.html#interactive-media-group">interactive media group</a>
may not be able to support this pseudo-class (e.g., a pen device).

<li> The :active pseudo-class applies while an element is being
activated by the user. For example, between the times the user presses
the mouse button and releases it.

<li> The :focus pseudo-class applies while an element has the
focus (accepts keyboard events, or other forms of text input).
</ul>

<p>These pseudo-classes are not mutually exclusive. An element may
match several of them at the same time.

<p>CSS doesn't define which elements may be in the above states, or
how the states are entered and left. Scripting may change whether
elements react to user events or not, and different devices and UAs
may have different ways of pointing to, or activating elements.

<p>User agents are not required to reflow a currently displayed
document due to pseudo-class transitions. For instance, a style sheet
may specify that the <span
class="propinst-font-size">'font-size'</span> of an :active link
should be larger than that of an inactive link, but since this may
cause letters to change position when the reader selects the link, a
UA may ignore the corresponding style rule.</p>

<div class="example"><p>Example:</p>

<pre>
  A:link    { color: red }    /* unvisited links */
  A:visited { color: blue }   /* visited links   */
  A:hover   { color: yellow } /* user hovers     */
  A:active  { color: lime }   /* active links    */
</pre>

<p>Note that the A:hover must be placed after the A:link and A:visited
rules, since otherwise the cascading rules will hide the <span
class="propinst-color">'color'</span> property of the A:hover
rule. Similarly, because A:active is placed after A:hover, the active
color (lime) will apply when the user both activates and hovers over
the A element.
</div>

<div class="example">
<p>An example of combining dynamic pseudo classes:

<pre>
A:focus {background: yellow}
A:focus:hover {background: white}
</pre>
</div>

<P>In order to support the :focus pseudo-class, user agents are
expected to be able to reformat a document dynamically. For
information about the presentation of focus outlines, please consult
the section on <a href="ui.html#focus-representation"> representing
the focus</a>.

<div class="note"><P>
<em><strong>Note.</strong>
In CSS1, the ':active' pseudo-class was mutually
exclusive with ':link' and ':visited'. That is no longer the case. An
element can be both ':visited' and ':active' (or ':link' and
':active') and the normal cascading rules determine which properties
apply.
</em>
</div>

<h3><a name="lang">The language pseudo-class:</a> <span
class="index-def" title="pseudo-classes:::lang|:lang|lang
(pseudo-class)">:lang</span></h3>

<p>If the document language specifies how the <span class="index-inst"
title="language (human)">human language</span> of an element is
determined, it is possible to write selectors in CSS that match an
element based on its language. For example, in HTML [[HTML40]], the
language is determined by a combination of the LANG attribute, the
META element, and possibly by information from the protocol (such as
HTTP headers). XML uses an attribute called XML:LANG, and there may be
other document language-specific methods for determining the language.

<p>The pseudo-class ':lang(<var>C</var>)' matches if the element is in
language <var>C</var>. Here <var>C</var> is a <span class="index-inst"
title="language code">language code</span> as specified in
HTML&nbsp;4.0 [[HTML40]] and RFC&nbsp;1766 [[-RFC1766]]. It is matched
the same way as for the <a href="#attribute-selectors">'|='
operator</a>.

<div class="example">
<p>The following rules set the quotation marks for an HTML document
that is either in French or German, or a combination of those:</p>

<pre>
HTML:lang(fr) {quotes: "" ""  "\2039"  "\203A"  "\201C" "\201D"}
HTML:lang(de) {quotes: "" ""  "\203A" "\2039"  "\201E" "\201D"}
[LANG|=fr] > * {quotes: "" ""  "\2039"  "\203A"  "\201C" "\201D"}
[LANG|=de} > * {quotes: "" ""  "\203A" "\2039"  "\201E" "\201D"}
</pre>

<p>The second pair of rules actually set the <span
class="propinst-quotes">'quotes'</span> property on the
<em>children</em> of each element with a LANG attribute, since in a
multilingual document the choice of quote marks is typically based on
the language of the element around the quote, not the quote itself:
like this piece of French &#8220;&agrave; l'improviste&#8221; in the middle
of an English text uses the English quotation marks.
</div>


<h2>Pseudo-elements</h2>

<h3>The <span class="index-def"
title="pseudo-elements:::first-line|:first-line|first-line"><a
name="first-line-pseudo">:first-line</a></span> pseudo-element</h3>

<p>The :first-line pseudo-element applies special styles to
the first formatted line of a paragraph. For instance:</p>

<pre class="example">
  P:first-line { text-transform: uppercase }
</pre>

<p>The above rule means "change the letters of the first line of
every paragraph to uppercase". However, the selector "P:first-line"
does not match any real HTML element. It does match a pseudo-element
that <a href="conform.html#conformance">conforming user agents</a>
will insert at the beginning of every paragraph.</p>

<p>Note that the length of the first line depends on a number of
factors, including the width of the page, the font size, etc.  Thus,
an ordinary HTML paragraph such as:</p>

<pre class="html-example">
  &lt;P&gt;This is a
  somewhat long HTML 
  paragraph that will be
  broken into several 
  lines. The first line will be identified
  by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p>the lines of which happen to be broken as follows:

<pre class="html-example">
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT WILL
be broken  into  several  lines. The  first line
will   be    identified  by    a fictional   tag
sequence. The  other  lines  will be treated  as
ordinary lines in the paragraph.
</pre>

<p>might be "rewritten" by user agents to include the <em><span
class="index-def" title="fictional tag sequence">fictional tag
sequence</span></em> for :first-line. This fictional tag sequence helps
to show how properties are inherited.</p>

<pre>
  &lt;P&gt;<b>&lt;P:first-line&gt;</b>This is a
  somewhat long HTML 
  paragraph that will<b>&lt;/P:first-line&gt;</b> be
  broken into several
  lines. The first line will be identified 
  by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p>If a pseudo-element breaks up a real element, the desired effect
can often be described by a fictional tag sequence that closes and
then re-opens the element. Thus, if we mark up the previous paragraph
with a SPAN element:</p>

<pre>
  &lt;P&gt;<b>&lt;SPAN class="test"&gt;</b>This is a
  somewhat long HTML
  paragraph that will be
  broken into several
  lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
  by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p>The user agent could generate the appropriate start and end tags for
SPAN when inserting the fictional tag sequence for :first-line.</p>

<pre>
  &lt;P&gt;&lt;P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b>This is a
  somewhat long HTML
  paragraph that will<b>&lt;/SPAN&gt;</b>&lt;/P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
  broken into several
  lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
  by a fictional tag sequence. The other lines will 
  be treated as ordinary lines in the paragraph.&lt;/P&gt;
</pre>

<p> The <span class="index-inst" title="pseudo-elements:::first-line">:first-line</span> pseudo-element can only be attached to
a block-level element.</p>

<p>The <a name="first-line">:first-line</a> pseudo-element is similar
to an inline-level element, but with certain restrictions. Only the
following properties apply to a :first-line element: <a
href="fonts.html#font-properties">font properties,</a> <a
href="colors.html">color properties,</a> <a
href="colors.html#background-properties">background properties,</a>
<span class="propinst-word-spacing">'word-spacing',</span> <span
class="propinst-letter-spacing">'letter-spacing',</span> <span
class="propinst-text-decoration">'text-decoration',</span> <span
class="propinst-vertical-align">'vertical-align',</span> <span
class="propinst-text-transform">'text-transform',</span> <span
class="propinst-line-height">'line-height',</span> and <span
class="propinst-clear">'clear'.</span></p>

<h3><a name="first-letter">The</a> <span class="index-def" title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span> pseudo-element</h3>

<!-- [Define better alignment of drop caps?  BB] -->

<p>The :first-letter pseudo-element may be used for <span
class="index-inst" title="initial caps">"initial caps"</span> and
<span class="index-inst" title="drop caps">"drop caps"</span>, which
are common typographical effects. This type of initial letter is
similar to an inline-level element if its <span
class="propinst-float">'float'</span> property is 'none', otherwise it
is similar to a floating element.</p>

<p>These are the properties that apply to :first-letter
pseudo-elements: <a href="fonts.html#font-properties">font
properties,</a> <a href="colors.html">color
properties,</a> <a href="colors.html#background-properties">background
properties,</a> <span
class="propinst-text-decoration">'text-decoration',</span> <span
class="propinst-vertical-align">'vertical-align'</span> (only if
'float' is 'none'), <span
class="propinst-text-transform">'text-transform',</span> <span
class="propinst-line-height">'line-height',</span> <a
href="visudet.html#margin-properties">margin properties,</a> <a
href="visudet.html#padding-properties">padding properties,</a> <a
href="visudet.html#border-properties">border properties,</a> <span
class="propinst-float">'float',</span> and <span
class="propinst-clear">'clear'.</span></p>

<div class="html-example"><p></p>
<p>The following CSS2 will make a dropcap initial letter span two lines:</p>

<pre>
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Dropcap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 12pt }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>This example might be formatted as follows:</p>

<P><img src="./images/first-letter.gif" alt="Image illustrating the combined effect of the :first-letter and :first-line pseudo-elements"></p>

<p>The <span class="index-inst" title="fictional tag
sequence">fictional tag sequence</span> is:</p>

<pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P:first-letter&gt;
T
&lt;/P:first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

<p>Note that the :first-letter pseudo-element tags abut the content
(i.e., the initial character), while the :first-line pseudo-element
start tag is inserted right after the start tag of the element to
which it is attached.</p>
</div>

<p><!--
The user agent defines what characters are inside the :first-letter
element. Removed. 27/2/98 -->

Punctuation (i.e, characters defined in Unicode [[UNICODE]] in the
"open" (Ps), "close" (Pe), and "other" (Po) punctuation classes), that
precedes the first letter should be included, as in:</p>

<P><img src="./images/first-letter2.gif" alt="Quotes that precede the
first letter should be included."></p>

<!--
<p> When the paragraph starts with other punctuation (e.g.,
parenthesis and ellipsis points) or other characters that are normally
not considered letters (e.g., digits and mathematical symbols),
:first-letter pseudo-elements are generally <span class="index-inst"
title="ignore"><a href="syndata.html#ignore">ignored</a></span></p>
Removed 27/2/98 -->

<p>The :first-letter pseudo-element matches parts of <a
href="visuren.html#block-level">block-level</a> elements only.</p>

<p>
Some languages may have specific rules about how to treat certain
letter combinations. In Dutch, for example, if the letter combination
"ij" appears at the beginning of a word, they should both be
considered within the :first-letter pseudo-element.

<div class="example"><p>
<a name="overlapping-example">The following example</a> illustrates
how overlapping pseudo-elements may interact.  The first letter of
each P element will be green with a font size of '24pt'. The rest of
the first formatted line will be 'blue' while the rest of the
paragraph will be 'red'.</p>

<pre>
P { color: red; font-size: 12pt }
P:first-letter { color: green; font-size: 200% }
P:first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;
</pre>

<p>Assuming that a line break will occur before the word "ends", the
<span class="index-inst" title="fictional tag sequence">fictional tag
sequence</span> for this fragment might be:</p>

<pre>
&lt;P&gt;
&lt;P:first-line&gt;
&lt;P:first-letter&gt; 
S 
&lt;/P:first-letter&gt;ome text that 
&lt;/P:first-line&gt; 
ends up on two lines 
&lt;/P&gt;
</pre>

<p>Note that the :first-letter element is inside the :first-line
element.  Properties set on :first-line are inherited by
:first-letter, but are overridden if the same property is set on
:first-letter.</p>
</div>

<h3><a name="before-and-after">The</a> <span class="index-def"
title="pseudo-elements:::before|:before">:before</span> and <span
class="index-def" title="pseudo-elements:::after|:after">:after</span>
pseudo-elements</h3>

<p>The ':before' and ':after' pseudo-elements can be used to insert
fixed text before or after an element. They are explained in the
section on <a href="generate.html">generated text.</a>

<div class="example">
<p>Example:</p>

<pre>
H1:before {content: counter(chapno, upper-roman) ". "}
</pre>
</div>

<p>When the :first-letter and :first-line pseudo-elements are combined
with :before and :after, they apply to the first letter or line of the
element including the inserted text.

<div class="example">
<p>Example:

<pre>
P.special:before {content: "Special! "}
P.special:first-letter {color: #ffd800}
</pre>

<p>This will render the "S" of "Special!" in gold.
</div>

<!--
<div class="example"><p>
The following example illustrates this with the
<span class="index-inst" title=":first-letter">:first-letter</span>
pseudo-element.</p>

<pre>
BODY P:first-letter { color: purple }
</pre>
</div>

<div class="example"><p>
The following example sets the border color to blue of all images that
descend from A elements that have not yet been visited:</p>
<pre>
A:link IMG { border: solid blue }
</pre>
</div>
-->

</body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/HTML4.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
End:
-->
