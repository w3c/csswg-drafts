<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.0 Transitional//EN'>
<html lang="en">
<!-- $Id: selector.src,v 2.57 1999-11-04 20:23:35 ijacobs Exp $ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Selectors</title>
<!-- Changed by: Ian B. Jacobs, 28-Sep-1998 -->
</head>
<body>
<h1 align="center">Selectors</h1>

<h2>Pattern matching</h2>

<p>In CSS, pattern matching rules determine which style rules apply to
elements in the <a href="conform.html#doctree">document
tree</a>. These patterns, called <span class="index-inst"
title="selector">selectors,</span> may range from simple element names
to rich contextual patterns. If all conditions in the pattern are true
for a certain element, the selector <span class="index-def"
title="match|selector::match"><dfn>matches</dfn></span> the element.

<P>The case-sensitivity of document language element names in
selectors depends on the document language. For example, in HTML,
element names are case-insensitive, but in XML they are
case-sensitive.

<P>The following table summarizes CSS2 selector syntax:</P>

<table border=1>
<TR><TH>Pattern<TH>Meaning<TH>Described in section</TR>
<TR><TD>*<TD>Matches any element.<TD><a href="#universal-selector">Universal
selector</a></TR>
<TR><TD>E<TD>Matches any E element (i.e., an element of type E).<TD><a href="#type-selectors">Type
selectors</a></TR>
<TR><TD>E F<TD>Matches any F element that is a descendant of
an E element.<TD><a href="#descendant-selectors">Descendant
selectors</a></TR>
<TR><TD>E &gt; F<TD>Matches any F element that is a child of
an element E.<TD><a href="#child-selectors">Child selectors</a></TR>
<TR><TD>E:first-child<TD>Matches element E when E is the first
child of its parent.
<TD><a href="#first-child">The :first-child pseudo-class</a></TR>

<TR><TD>E:link<br>E:visited <TD>Matches element E if E is the source
anchor of a hyperlink of which the target is not yet visited (:link)
or already visited (:visited).
<TD><a href="#link-pseudo-classes">The link pseudo-classes</a></TR>
<TR><TD>E:active<br>E:hover<br>E:focus <TD>Matches E during certain
user actions.
<TD><a href="#dynamic-pseudo-classes">The dynamic pseudo-classes</a>
<TR><TD>E:lang(c) <TD>Matches element of type E if it is in (human) language c
(the document language specifies how language is determined).
<TD><a href="#lang">The :lang() pseudo-class</a>
<TR><TD>E + F<TD>Matches any F element immediately preceded by
an element E.<TD><a href="#adjacent-selectors">Adjacent selectors</a>
</TR>
<TR><TD>E[foo]<TD>Matches any E element with the
"foo" attribute set (whatever the value).
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>E[foo="warning"]<TD>Matches any E element whose
"foo" attribute value is exactly equal to "warning".
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>E[foo~="warning"]<TD>Matches any E element whose
"foo" attribute value is a list of space-separated  values, one of
which is exactly equal to "warning".
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>E[lang|="en"]<TD>Matches any E element whose
"lang" attribute has a hyphen-separated list of values
beginning (from the left) with "en".
<TD><a href="#attribute-selectors">Attribute selectors</a>
</TR>
<TR><TD>DIV.warning<TD><em>HTML only</em>. The same as DIV[class~="warning"].
<TD><a href="#class-html">Class selectors</a></TR>
<TR><TD>E#myid<TD>Matches any E element ID
equal to "myid".<TD><a href="#id-selectors">ID selectors</a></TR>
</table>


<h2>Selector syntax</h2>

<P>A <span class="index-def" title="simple selector"><a
name="simple-selector"><dfn>simple selector</dfn></a></span> is either
a <a href="#type-selectors">type selector</a> or <a
href="#universal-selector">universal selector</a> followed immediately
by zero or more <a href="#attribute-selectors">attribute
selectors</a>, <a href="#id-selectors">ID selectors</a>, or <a
href="#pseudo-classes">pseudo-classes</a>, in any order.  The simple
selector matches if all of its components match.

<P>A <span class="index-def"
title="selector"><dfn>selector</dfn></span> is a chain of one or more
simple selectors separated by combinators.  <span class="index-def"
title="combinator"><a
name="combinator"><dfn>Combinators</dfn></a></span> are: whitespace,
"&gt;", and "+". Whitespace may appear between a combinator and the
simple selectors around it.

<P>The elements of the document tree that match a selector are called
<span class="index-def" title="subject (of selector)|selector::subject
of"><a name="subject"><dfn>subjects</dfn></a></span> of the selector.
A selector consisting of a single simple selector matches any element
satisfying its requirements.  Prepending a simple selector and
combinator to a chain imposes additional matching constraints, so the
subjects of a selector are always a subset of the elements matching
the rightmost simple selector.

<P>One <a href="#pseudo-elements">pseudo-element</a> may be appended
to the last simple selector in a chain, in which case the style
information applies to a subpart of each subject.

<h3><a name="grouping">Grouping</a></h3>

<p>When several selectors share the same declarations, they may be
grouped into a comma-separated list.</p>

<div class="example">
<P>In this example, we condense three rules with identical declarations
into one. Thus,

<pre>
H1 { font-family: sans-serif }
H2 { font-family: sans-serif }
H3 { font-family: sans-serif }
</pre>

<p>is equivalent to:</p>

<pre>
H1, H2, H3 { font-family: sans-serif }
</pre>
</div>

<P>CSS offers other "shorthand" mechanisms as well, including 
<span class="index-def" title="multiple declarations">
<a href="syndata.html#declaration">multiple declarations</a></span>
and <span class="index-inst" title="shorthand property"><a
href="about.html#shorthand">shorthand properties</a></span>.

<h2><a name="universal-selector">Universal selector</a></h2>

<P>The <span class="index-def" title="universal selector">universal
selector</span>, written "*", matches the name of any element
type. It matches any single element in the <a
href="conform.html#doctree">document tree.</a>


<P>If the universal selector is not the only component of a <a
href="#simple-selector">simple selector</a>, the "*" may be
omitted. For example:</P>

<ul>
<li><code>*[LANG=fr] </code> and <code>[LANG=fr]</code> are equivalent.
<li><code>*.warning</code> and <code>.warning</code> are equivalent.
<li><code>*#myid</code> and <code>#myid</code> are equivalent.
</ul>

<h2><a name="type-selectors">Type selectors</a></h2>

<p>A <span class="index-def" title="type selector"><em>type
selector</em></span> matches the name of a document language element
type. A type selector matches every instance of the element type in
the document tree.

<div class="example">
<P>The following rule matches all H1 elements in the
document tree:</p>

<pre>
H1 { font-family: sans-serif }
</pre>
</div>

<h2><a name="descendant-selectors">Descendant selectors</a></h2>

<p>At times, authors may want selectors to match an element that is
the descendant of another element in the document tree (e.g., "Match
those EM elements that are contained by an H1 element").  <span
class="index-def" title="descendant-selectors">Descendant
selectors</span> express such a relationship in a pattern. A
descendant selector is made up of two or more selectors separated by
<a href="syndata.html#whitespace">whitespace</a>. A descendant
selector of the form "<code>A B</code>" matches when an element
<code>B</code> is an arbitrary descendant of some <a
href="conform.html#doctree">ancestor</a> element <code>A</code>.

<div class="example"><p>
For example, consider the following rules:</p>

<pre>
H1 { color: red }
EM { color: red }
</pre>

<p>Although the intention of these rules is to add emphasis to text by
changing its color, the effect will be lost in a case such as:</p>

<pre class="html-example">
&lt;H1&gt;This headline is &lt;EM&gt;very&lt;/EM&gt; important&lt;/H1&gt;
</pre>

<p>We address this case by supplementing the previous rules with a
rule that sets the text color to blue whenever an EM occurs anywhere
within an H1:</p>

<pre>
H1 { color: red }
EM { color: red }
H1 EM { color: blue }
</pre>

<p>The third rule will match the EM in the following fragment:</p>

<pre class="html-example">
&lt;H1&gt;This &lt;SPAN class="myclass"&gt;headline 
is &lt;EM&gt;very&lt;/EM&gt; important&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
</div>

<div class="example"><P>
The following selector:</p>

<PRE>
DIV * P 
</PRE>

<P>matches a P element that is a grandchild or later descendant
of a DIV element. Note the whitespace on either side of the "*".
</div>

<div class="example"><p>
The selector in the following rule, which combines
descendant and <a href="#attribute-selectors">attribute selectors</a>,
matches any element that (1) has the "href" attribute set and
(2) is inside a P that is itself inside a DIV:</p>

<pre>
DIV P *[href]
</pre>
</div>

<h2><a name="child-selectors">Child selectors</a></h2>

<p>A <span class="index-def" title="child selector"><em>child
selector</em></span> matches when an element is the <a
href="conform.html#doctree">child</a> of some element. A child
selector is made up of two or more selectors separated by "&gt;".

<div class="example"><p>
The following rule sets the style of all P elements that 
are children of BODY:</p>

<pre>
BODY &gt; P { line-height: 1.3 }
</pre>
</div>

<div class="example"><P>
The following example combines descendant selectors and child selectors:</p>
<pre>
DIV OL&gt;LI P
</pre>

<P>It matches a P element that is a descendant of an LI; the LI element
must be the child of an OL element; the OL element must be a
descendant of a DIV. Notice that the optional whitespace around
the "&gt;" combinator has been left out.
</div>

<P>For information on selecting the first child of an element, please
see the section on the <a href="#first-child">:first-child</a>
pseudo-class below.

<h2><a name="adjacent-selectors">Adjacent sibling selectors</a></h2>

<p>Adjacent sibling selectors have the following syntax: E1 + E2,
where E2 is the subject of the selector. The selector matches if E1
and E2 share the same parent in the document tree and E1 immediately
precedes E2.

<p>In some contexts, adjacent elements generate formatting objects
whose presentation is handled automatically (e.g., collapsing
vertical margins between adjacent boxes). The "+" selector
allows authors to specify additional style to adjacent elements.

<div class="example"><p>
Thus, the following rule states that when a P element immediately
follows a MATH element, it should not be indented:</p>

<pre>
MATH + P { text-indent: 0 } 
</pre>

<p>The next example reduces the vertical space separating
an H1 and an H2 that immediately follows it:</p>

<pre>
H1 + H2 { margin-top: -5mm }   
</pre>
</div>

<div class="example"><p> 
The following rule is similar to the one in the
previous example, except that it adds an attribute
selector. Thus, special formatting only occurs when
H1 has <samp>class="opener"</samp>:</p>

<pre>
H1.opener + H2 { margin-top: -5mm }   
</pre>
</div>

<h2><a name="attribute-selectors">Attribute selectors</a></h2>

<p>CSS2 allows authors to specify rules that match attributes defined
in the source document.

<h3>Matching attributes and attribute values</h3>

<P>Attribute selectors may match in four ways:</p>

<dl>
<dt><code>[att]</code>
<dd>Match when the element sets the "att" attribute, whatever
the value of the attribute.
<dt><span class="index-def" title="exact
matching|="><code>[att=val]</code></span>
<dd>Match when the element's "att" attribute value is exactly "val".
<dt><span class="index-def" title="space-separated
matching|~="><code>[att~=val]</code></span>
<dd>Match when the element's "att" attribute value is a 
space-separated list of "words", one of which is exactly "val". 
If this selector is used, the words in the value must not contain
spaces (since they are separated by spaces).
<dt><span class="index-def" title="hyphen-separated
matching|&#124;="><code>[att|=val]</code></span>
<dd>Match when the element's "att" attribute value is a 
hyphen-separated list of "words", beginning with "val". The match
always starts at the beginning of the attribute value.
This is primarily
intended to allow <span class="index-inst" title="language
code">language subcode</span> matches (e.g., the "lang"
attribute in HTML) as described in RFC 1766 ([[-RFC1766]]).
</dl>

<p>Attribute values must be identifiers or strings. The
case-sensitivity of attribute names and values in selectors depends on
the document language.

<div class="example"><p>
For example, the following attribute selector 
matches all H1 elements that specify the "title" attribute, 
whatever its value:</p>

<pre>
H1[title] { color: blue; }
</pre>
</div>

<div class="example"><p>
In the following example, the selector matches all SPAN elements whose
"class" attribute has exactly the value "example":</p>

<pre>
SPAN[class=example] { color: blue; }
</pre>
</div>

<P>Multiple attribute selectors can be used to refer to several
attributes of an element, or even several times to the same attribute.

<div class="example"><p>
Here, the selector matches all SPAN elements whose
"hello" attribute has exactly the value "Cleveland" and whose
"goodbye" attribute has exactly the value "Columbus":</P>

<pre>
SPAN[hello="Cleveland"][goodbye="Columbus"] { color: blue; }
</pre>
</div>

<div class="example"><p>
The following selectors illustrate the differences between "=" and "~=".
The first selector will match, for example, the value 
"copyright copyleft copyeditor" for the "rel" attribute. The second
selector will only match when the "href" attribute has the value 
"http://www.w3.org/".
</p>

<pre>
A[rel~="copyright"]
A[href="http://www.w3.org/"]
</pre>
</div>

<div class="example"><P>
The following rule hides all elements for which the value of the
"lang" attribute is "fr" (i.e., the language is French).

<PRE>
*[LANG=fr] { display : none }
</PRE>
</div>

<div class="example"><P>
The following rule will match for values of the "lang" attribute
that begin with "en", including "en", "en-US", and "en-cockney":</p>

<PRE>
*[LANG|="en"] { color : red }
</PRE>
</div>

<div class="example"><P>
Similarly, the following aural style sheet rules allow a script
to be read aloud in different voices for each role:</p>

<pre class="example">
DIALOGUE[character=romeo] 
     { voice-family: "Lawrence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }
</pre>
</div>

<H3>Default attribute values in DTDs</H3>

<P>Matching takes place on attribute values in the document tree. For
document languages other than HTML, default attribute values may be
defined in a <span class="index-inst" title="DTD">DTD</span> or elsewhere. Style
sheets should be designed so that they work even if the default values
are not included in the document tree.

<div class="example">
<P>For example, consider an element EXAMPLE with an attribute "notation"
that has a default value of "decimal". The DTD fragment might be

<pre class="dtd-example">
&lt;!ATTLIST EXAMPLE notation (decimal,octal) "decimal">
</pre>

<p>If the style sheet contains the rules

<pre class="example">
EXAMPLE[notation=decimal] { /*... default property settings ...*/ }
EXAMPLE[notation=octal] { /*... other settings...*/ }
</pre>

<p>then to catch the cases where this attribute is set by default,
and not explicitly, the following rule might be added:

<pre class="example">
EXAMPLE { /*... default property settings ...*/ }
</pre>

<p>Because this selector is less 
<a href="cascade.html#specificity">
specific</a> than an attribute selector, it will only be used for the
default case. Care has to be taken that all other attribute values
that don't get the same style as the default are explicitly covered.
</div>


<h3><a name="class-html">Class selectors</a></h3> 

<p>For style sheets used with HTML, authors may use the dot (.)
notation as an alternative to the "~=" notation when matching on the
"class" attribute. Thus, for HTML,
"DIV.value" and "DIV[class~=value]" have the same meaning. The
attribute value must immediately follow the ".".

<div class="example"><p>
For example, we can assign style information to all elements with
<samp>class~="pastoral"</samp> as follows:</p>

<pre>
*.pastoral { color: green }  /* all elements with class~=pastoral */
</pre>

or just

<pre>
.pastoral { color: green }  /* all elements with class~=pastoral */
</pre>

<p>The following assigns style only to H1 elements with
<samp>class~="pastoral"</samp>:</p>

<pre>
H1.pastoral { color: green }  /* H1 elements with class~=pastoral */
</pre>

<p>Given these rules, the first H1 instance below would not have green
text, while the second would:</p>

<pre>
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>
</div>

<p>To match a subset of "class" values, each value must be preceded
by a ".", in any order.</P>

<div class="example"><P>
For example, the following rule matches any P element whose "class" attribute
has been assigned a list of space-separated values that includes "pastoral"
and "marine":</p>

<pre> 
P.pastoral.marine { color: green }
</pre>

<p>This rule matches when <samp>class="pastoral blue aqua
marine"</samp> but does not match for <samp>class="pastoral
blue"</samp>.
</div>

<div class="note"><p> <em><strong>Note.</strong> CSS gives so much
power to the "class" attribute, that authors could conceivably design
their own "document language" based on elements with almost no
associated presentation (such as DIV and SPAN in HTML) and assigning
style information through the "class" attribute.  Authors should avoid
this practice since the structural elements of a document language
often have recognized and accepted meanings and author-defined classes may
not.</em>
</div>

<h2><a name="id-selectors">ID selectors</a></h2>

<P>Document languages may contain attributes that are declared to be
of type ID.  What makes attributes of type ID special is that no two
such attributes can have the same value; whatever the document
language, an ID attribute can be used to uniquely identify its
element. In HTML all ID attributes are named "id"; XML
applications may name ID attributes differently, but the
same restriction applies.

<p>The ID attribute of a document language allows authors to assign an
identifier to one element instance in the document tree.  CSS ID
selectors match an element instance based on its identifier.  A CSS
ID selector contains a "#" immediately followed by the ID
value.</p>

<div class="example"><p> 
The following ID selector matches the H1 element whose ID
attribute has the value "chapter1":</p>

<PRE>
H1#chapter1 { text-align: center }
</PRE>
</div>

<div class="html-example"><p> 
In the following example, the style rule matches
the element that has the ID value "z98y".
The rule will thus match for the P element:</p>

<pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match P&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    *#z98y { letter-spacing: 0.3em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>

<p>In the next example, however, the style rule will only match an H1
element that has an ID value of "z98y". The rule will not match the
P element in this example:</p>

<pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match H1 only&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    H1#z98y { letter-spacing: 0.5em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>
</div>

<P>ID selectors have a higher precedence than attribute selectors.
For example, in HTML, the selector <samp>#p123</samp> is more specific
than <samp>[ID=p123]</samp> in terms of the <a
href="cascade.html">cascade</a>.

<div class="note">
<p><em><strong>Note.</strong> In XML 1.0 [[-XML10]], the information about which
attribute contains an element's IDs is contained in a DTD. When
parsing XML, UAs do not always read the DTD, and thus may not know
what the ID of an element is. If a style sheet designer knows or
suspects that this will be the case, he should use normal attribute
selectors instead: <code>[name=p371]</code> instead of
<code>#p371</code>. However, the cascading order of normal attribute
selectors is different from ID selectors. It may be necessary to add
an "!important" priority to the declarations: <code>[name=p371]
{color: red ! important}</code>. Of course, elements in 
XML 1.0 documents without a DTD do not have IDs at all.</em>
</div>

<h2><a name="pseudo-elements">Pseudo-elements</a> and <a
name="pseudo-classes">pseudo-classes</a></h2>

<p>In CSS2, style is normally attached to an element based on its
position in the <a href="conform.html#doctree">document tree</a>. This
simple model is sufficient for many cases, but some common publishing
scenarios may not be possible due to the structure of the <a
href="conform.html#doctree">document tree</a>. For instance, in HTML
4.0 (see [[HTML40]]), no element refers to the first line of a
paragraph, and therefore no simple CSS selector may refer to it.</p>

<p>CSS introduces the concepts of <span class="index-def"
title="pseudo-elements"><dfn>pseudo-elements</dfn></span> and <span
class="index-def"
title="pseudo-classes"><dfn>pseudo-classes</dfn></span> to permit
formatting based on information that lies outside the document
tree. </p>

<ul>
<li>Pseudo-elements create abstractions about the document tree beyond
those specified by the document language. For instance, document
languages do not offer mechanisms to access the first letter or first
line of an element's content. CSS pseudo-elements allow style sheet
designers to refer to this otherwise inaccessible
information. Pseudo-elements may also provide style sheet designers a
way to assign style to content that does not exist in the source
document (e.g., the <a
href="generate.html#before-after-content">:before and :after</a>
pseudo-elements give access to generated content).

<li>Pseudo-classes classify elements on characteristics other than
their name, attributes or content; in principle characteristics that
cannot be deduced from the document tree. Pseudo-classes may be
dynamic, in the sense that an element may acquire or lose a
pseudo-class while a user interacts with the document. The exceptions
are <a href="#first-child">':first-child'</a>, which <em>can</em> be
deduced from the document tree, and 
<a href="#lang">':lang()'</a>, which can be
deduced from the document tree in some cases.
</ul>

<P>Neither pseudo-elements nor pseudo-classes appear in the document
source or document tree.

<P>Pseudo-classes are allowed anywhere in selectors while
pseudo-elements may only appear after the <a
href="#subject">subject</a> of the selector.
</p>


<p>Pseudo-elements and pseudo-class names are case-insensitive.</p>

<P>Some pseudo-classes are mutually exclusive, while others can be
applied simultaneously to the same element. In case of conflicting
rules, the normal <a href="cascade.html#cascading-order">cascading
order</A> determines the outcome.

<p><a href="conform.html#conformance">Conforming HTML user agents</a>
may <span class="index-inst" title="ignore"><a
href="syndata.html#ignore">ignore</a></span> all rules with :first-line or
:first-letter in the selector, or, alternatively, may only support a
subset of the properties on these pseudo-elements.</P>

<h2>Pseudo-classes</h2>

<h3><a name="first-child">:first-child</a> pseudo-class</h3>

<P>The <span class="index-def"
title="first-child|:first-child">:first-child</span> pseudo-class
matches an element that is the first child of some other element.

<div class="example"><P>
In the following example, the selector matches any P element
that is the first child of a DIV element. The rule
suppresses indentation for the first paragraph of a DIV:</p>

<PRE>
DIV &gt; P:first-child { text-indent: 0 }
</PRE>

This selector would match the P inside the DIV of the
following fragment:

<pre class="html-example">
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>

but would not match the second P in the following
fragment:

<pre class="html-example">
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;H2&gt;Note&lt;/H2&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>
</div>

<div class="example">
<p>The following rule sets the font weight to 'bold' for any EM
element that is some descendant of a P element that is a first
child:</p>

<pre>
P:first-child EM { font-weight : bold }
</pre>
</div>

<P>Note that since <a href="visuren.html#anonymous">anonymous</a>
boxes are not part of the document tree, they are not counted when
calculating the first child.</p>

<div class="html-example"><P>
For example, the EM in:</p>

<PRE>
&lt;P&gt;abc &lt;EM&gt;default&lt;/EM&gt; 
</PRE>

is the first child of the P.
</div>

<P>The following two selectors are equivalent:</p>

<PRE>
* &gt; A:first-child   /* A is first child of any element */
A:first-child       /* Same */
</PRE>


<h3><a name="link-pseudo-classes">The link pseudo-classes</a>: <span
class="index-def" title="pseudo-classes:::link|:link|link
(pseudo-class)">:link</span> and <span class="index-def"
title="pseudo-classes:::visited|:visited|visited
(pseudo-class)">:visited</span></h3>

<p>User agents commonly display unvisited links differently from
previously visited ones. CSS provides the pseudo-classes ':link' and
':visited' to distinguish them:</p>

<ul>
<li> The :link pseudo-class applies for links that have
not yet been visited.

<li> The :visited pseudo-class applies once the link has been
visited by the user.
</ul>

<p class="note"><em><strong>Note.</strong> After a certain amount of
time, user agents may choose to return a visited link to the
(unvisited) ':link' state.</em>

<P>The two states are mutually exclusive.

<p>The document language determines which elements are hyperlink
source anchors. For example, in HTML&nbsp;4.0, the link pseudo-classes
apply to A elements with an "href" attribute. Thus, the following
two CSS2 declarations have similar effect:</p>

<pre>
A:link { color: red }
:link  { color: red }
</pre>

<div class="example"><p>
If the following link:</p>

<pre class="html-example">
&lt;A class="external" href="http://out.side/"&gt;external link&lt;/A&gt;
</pre>

has been visited, this rule:

<pre>
A.external:visited { color: blue }
</pre>

will cause it to be blue.
</div>

<h3><a name="dynamic-pseudo-classes">The dynamic pseudo-classes:</a>
<span class="index-def" title="pseudo-classes:::hover|:hover|hover
(pseudo-class)">:hover</span>, <span class="index-def"
title="pseudo-classes:::active|:active|active
(pseudo-class)">:active</span>, and <span class="index-def"
title="pseudo-classes:::focus|:focus|focus
(pseudo-class)">:focus</span></h3>

<p>Interactive user agents sometimes change the rendering in response
to user actions. CSS provides three pseudo-classes for common cases:</p>

<ul>
<li> The :hover pseudo-class applies while the user designates an
element (with some pointing device), but does not activate it. For
example, a visual user agent could apply this pseudo-class when the
cursor (mouse pointer) hovers over a box generated by the element.
User agents not supporting
<a href="media.html#interactive-media-group">interactive media</a>
do not have to support this pseudo-class.
Some conforming user agents supporting
<a href="media.html#interactive-media-group">interactive media</a>
may not be able to support this pseudo-class (e.g., a pen device).

<li> The :active pseudo-class applies while an element is being
activated by the user. For example, between the times the user presses
the mouse button and releases it.

<li> The :focus pseudo-class applies while an element has the
focus (accepts keyboard events or other forms of text input).
</ul>

<p>These pseudo-classes are not mutually exclusive. An element may
match several of them at the same time.

<p>CSS doesn't define which elements may be in the above states, or
how the states are entered and left. Scripting may change whether
elements react to user events or not, and different devices and UAs
may have different ways of pointing to, or activating elements.

<p>User agents are not required to reflow a currently displayed
document due to pseudo-class transitions. For instance, a style sheet
may specify that the <span
class="propinst-font-size">'font-size'</span> of an :active link
should be larger than that of an inactive link, but since this may
cause letters to change position when the reader selects the link, a
UA may ignore the corresponding style rule.</p>

<div class="example"><p>

<pre>
A:link    { color: red }    /* unvisited links */
A:visited { color: blue }   /* visited links   */
A:hover   { color: yellow } /* user hovers     */
A:active  { color: lime }   /* active links    */
</pre>

<p>Note that the A:hover must be placed after the A:link and A:visited
rules, since otherwise the cascading rules will hide the <span
class="propinst-color">'color'</span> property of the A:hover
rule. Similarly, because A:active is placed after A:hover, the active
color (lime) will apply when the user both activates and hovers over
the A element.
</div>

<div class="example">
<p>An example of combining dynamic pseudo-classes:

<pre>
A:focus { background: yellow }
A:focus:hover { background: white }
</pre>

<P>The last selector matches A elements that are in pseudo-class
:focus and in pseudo-class :hover.

</div>

<!--In order to support the :focus pseudo-class, user agents are
expected to be able to reformat a document dynamically. [this
conflicts with the statement above, HWL] --> 

<P>For information about the presentation of focus outlines, please
consult the section on <a href="ui.html#dynamic-outlines">dynamic
focus outlines</a>.

<div class="note"><P>
<em><strong>Note.</strong>
In CSS1, the ':active' pseudo-class was mutually
exclusive with ':link' and ':visited'. That is no longer the case. An
element can be both ':visited' and ':active' (or ':link' and
':active') and the normal cascading rules determine which properties
apply.
</em>
</div>

<h3><a name="lang">The language pseudo-class:</a> <span
class="index-def" title="pseudo-classes:::lang|:lang|lang
(pseudo-class)">:lang</span></h3>

<p>If the document language specifies how the <span class="index-inst"
title="language (human)">human language</span> of an element is
determined, it is possible to write selectors in CSS that match an
element based on its language. For example, in HTML [[HTML40]], the
language is determined by a combination of the "lang" attribute, the
META element, and possibly by information from the protocol (such as
HTTP headers). XML uses an attribute called xml:lang, and there may be
other document language-specific methods for determining the language.

<p>The pseudo-class ':lang(C)' matches if the element is in
language C. Here C is a <span class="index-inst"
title="language code">language code</span> as specified in
HTML&nbsp;4.0 [[HTML40]] and RFC&nbsp;1766 [[-RFC1766]]. It is matched
the same way as for the <a href="#attribute-selectors">'|='
operator</a>.

<div class="example">
<p>The following rules set the quotation marks for an HTML document
that is either in French or German:</p>

<pre>
HTML:lang(fr) { quotes: '« ' ' »' }
HTML:lang(de) { quotes: '»' '«' '\2039' '\203A' }
:lang(fr) > Q { quotes: '« ' ' »' }
:lang(de) > Q { quotes: '»' '«' '\2039' '\203A' }
</pre>

<p>The second pair of rules actually set the <span
class="propinst-quotes">'quotes'</span> property on Q elements
according to the language of its parent. This is done because the
choice of quote marks is typically based on the language of the
element around the quote, not the quote itself: like this piece of
French &#8220;&agrave; l'improviste&#8221; in the middle of an English
text uses the English quotation marks.  </div>

<h2>Pseudo-elements</h2>

<h3>The <span class="index-def"
title="pseudo-elements:::first-line|:first-line|first-line"><a
name="first-line-pseudo">:first-line</a></span> pseudo-element</h3>

<p>The :first-line pseudo-element applies special styles to
the first formatted line of a paragraph. For instance:</p>

<pre class="example">
P:first-line { text-transform: uppercase }
</pre>

<p>The above rule means "change the letters of the first line of
every paragraph to uppercase". However, the selector "P:first-line"
does not match any real HTML element. It does match a pseudo-element
that <a href="conform.html#conformance">conforming user agents</a>
will insert at the beginning of every paragraph.</p>

<p>Note that the length of the first line depends on a number of
factors, including the width of the page, the font size, etc.  Thus,
an ordinary HTML paragraph such as:</p>

<pre class="html-example">
&lt;P&gt;This is a somewhat long HTML 
paragraph that will be broken into several 
lines. The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

the lines of which happen to be broken as follows:

<pre class="html-example">
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag 
sequence. The other lines will be treated as 
ordinary lines in the paragraph.
</pre>

might be "rewritten" by user agents to include the <em><span
class="index-def" title="fictional tag sequence">fictional tag
sequence</span></em> for :first-line. This fictional tag sequence helps
to show how properties are inherited.

<pre>
&lt;P&gt;<b>&lt;P:first-line&gt;</b> This is a somewhat long HTML 
paragraph that <b>&lt;/P:first-line&gt;</b> will be broken into several
lines. The first line will be identified 
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p>If a pseudo-element breaks up a real element, the desired effect
can often be described by a fictional tag sequence that closes and
then re-opens the element. Thus, if we mark up the previous paragraph
with a SPAN element:</p>

<pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines 
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

the user agent could generate the appropriate start and end tags for
SPAN when inserting the fictional tag sequence for :first-line.

<pre>
&lt;P&gt;&lt;P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the 
paragraph.&lt;/P&gt;
</pre>

<p> The <span class="index-inst" title="pseudo-elements:::first-line">:first-line</span> pseudo-element can only be attached to
a block-level element.</p>

<p>The <a name="first-line">:first-line</a> pseudo-element is similar
to an inline-level element, but with certain restrictions. Only the
following properties apply to a :first-line pseudo-element: <a
href="fonts.html#font-properties">font properties,</a> <a
href="colors.html">color properties,</a> <a
href="colors.html#background-properties">background properties,</a>
<span class="propinst-word-spacing">'word-spacing',</span> <span
class="propinst-letter-spacing">'letter-spacing',</span> <span
class="propinst-text-decoration">'text-decoration',</span> <span
class="propinst-vertical-align">'vertical-align',</span> <span
class="propinst-text-transform">'text-transform',</span> <span
class="propinst-line-height">'line-height',</span> <span
class="propinst-text-shadow">'text-shadow'</span>, and <span
class="propinst-clear">'clear'.</span></p>

<h3><a name="first-letter">The</a> <span class="index-def" title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span> pseudo-element</h3>

<!-- [Define better alignment of drop caps?  BB] -->

<p>The :first-letter pseudo-element may be used for <span
class="index-inst" title="initial caps">"initial caps"</span> and
<span class="index-inst" title="drop caps">"drop caps"</span>, which
are common typographical effects. This type of initial letter is
similar to an inline-level element if its <span
class="propinst-float">'float'</span> property is 'none', otherwise it
is similar to a floated element.</p>

<p>These are the properties that apply to :first-letter
pseudo-elements: <a href="fonts.html#font-properties">font
properties,</a> <a href="colors.html">color properties,</a> <a
href="colors.html#background-properties">background properties,</a>
<span class="propinst-text-decoration">'text-decoration',</span> <span
class="propinst-vertical-align">'vertical-align'</span> (only if
'float' is 'none'), <span
class="propinst-text-transform">'text-transform',</span> <span
class="propinst-line-height">'line-height',</span> <a
href="box.html#margin-properties">margin properties,</a> <a
href="box.html#padding-properties">padding properties,</a> <a
href="box.html#border-properties">border properties,</a> <span
class="propinst-float">'float',</span> <span
class="propinst-text-shadow">'text-shadow'</span>, and <span
class="propinst-clear">'clear'.</span></p>

<div class="html-example"><p></p>
<p>The following CSS2 will make a drop cap initial letter span two lines:</p>

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 1.2 }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>This example might be formatted as follows:</p>

<div class="figure">
<P><img src="./images/first-letter.gif" alt="Image illustrating the combined effect of the :first-letter and :first-line pseudo-elements"></p>
</div>

<p>The <span class="index-inst" title="fictional tag
sequence">fictional tag sequence</span> is:</p>

<pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P:first-letter&gt;
T
&lt;/P:first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

<p>Note that the :first-letter pseudo-element tags abut the content
(i.e., the initial character), while the :first-line pseudo-element
start tag is inserted right after the start tag of the element to
which it is attached.</p>
</div>

<P>In order to achieve traditional drop caps formatting, user agents
may approximate font sizes, for example to align baselines. Also, the
glyph outline may be taken into account when formatting.

<P>Punctuation (i.e, characters defined in Unicode [[UNICODE]] in the
"open" (Ps), "close" (Pe), and "other" (Po) punctuation classes), that
precedes the first letter should be included, as in:</p>

<div class="figure">
<P><img src="./images/first-letter2.gif" alt="Quotes that precede the
first letter should be included."></p>
</div>

<p>The :first-letter pseudo-element matches parts of <a
href="visuren.html#block-level">block-level</a> elements only.</p>

<p>
Some languages may have specific rules about how to treat certain
letter combinations. In Dutch, for example, if the letter combination
"ij" appears at the beginning of a word, both letters should be
considered within the :first-letter pseudo-element.

<div class="example"><p>
<a name="overlapping-example">The following example</a> illustrates
how overlapping pseudo-elements may interact.  The first letter of
each P element will be green with a font size of '24pt'. The rest of
the first formatted line will be 'blue' while the rest of the
paragraph will be 'red'.</p>

<pre>
P { color: red; font-size: 12pt }
P:first-letter { color: green; font-size: 200% }
P:first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;
</pre>

<p>Assuming that a line break will occur before the word "ends", the
<span class="index-inst" title="fictional tag sequence">fictional tag
sequence</span> for this fragment might be:</p>

<pre>
&lt;P&gt;
&lt;P:first-line&gt;
&lt;P:first-letter&gt; 
S 
&lt;/P:first-letter&gt;ome text that 
&lt;/P:first-line&gt; 
ends up on two lines 
&lt;/P&gt;
</pre>

<p>Note that the :first-letter element is inside the :first-line
element.  Properties set on :first-line are inherited by
:first-letter, but are overridden if the same property is set on
:first-letter.</p>
</div>

<h3><a name="before-and-after">The</a> <span class="index-def"
title="pseudo-elements:::before|:before">:before</span> and <span
class="index-def" title="pseudo-elements:::after|:after">:after</span>
pseudo-elements</h3>

<p>The ':before' and ':after' pseudo-elements can be used to insert
generated content before or after an element's content. They are
explained in the section on <a href="generate.html">generated
text.</a>

<div class="example"><P>

<pre>
H1:before {content: counter(chapno, upper-roman) ". "}
</pre>
</div>

<p>When the :first-letter and :first-line pseudo-elements are combined
with :before and :after, they apply to the first letter or line of the
element including the inserted text.

<div class="example"><P>

<pre>
P.special:before {content: "Special! "}
P.special:first-letter {color: #ffd800}
</pre>

<p>This will render the "S" of "Special!" in gold.
</div>

</body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/HTML4.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
End:
-->
