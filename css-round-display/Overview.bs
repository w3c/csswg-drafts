<h1>CSS Round Display Level 1</h1>
<pre class='metadata'>
Level: 1
Status: ED
Work Status: Exploring
ED: https://drafts.csswg.org/css-round-display/
Shortname: css-round-display
TR: https://www.w3.org/TR/css-round-display-1/
Group: csswg
Link Defaults: css-shapes-1 (type) <basic-shape>, css-transforms-1 (property) transform/transform-origin
Previous Version: https://www.w3.org/TR/2016/WD-css-round-display-1-20160301/
Previous Version: https://www.w3.org/TR/2015/WD-css-round-display-1-20150922/
Editor: Hyojin Song, LG Electronics, hyojin22.song@lge.com
Editor: Jihye Hong, LG Electronics, jh.hong@lge.com
Former Editor: Soonbo Han, LG Electronics, soonbo.han@lge.com
Abstract: This document describes CSS extensions to support a round display. The extensions help web authors to build a web page suitable for a round display.
</pre>

<pre class="anchors">
url: https://svgwg.org/svg2-draft/shapes.html#TermShapeElement; type: dfn; spec: SVG2; text: shape element
url: https://www.w3.org/TR/SVG11/struct.html#DefsElement; spec: SVG11; type: element; text: defs
</pre>

<style>
/* example in table layout*/
.example-table {
	display:table; 
	margin: 0 auto 1em; 
	border-spacing: 2em 0; 
	min-width: 672px;
}
.example-table > .desc {
	display: table-cell;
	vertical-align: top;
	width: 250px;
	text-align: center;
}
</style>

Introduction {#introduction}
==================================================

Conventionally, web pages have been shown through a rectangular screen such as PC, tablet, and smart phone. The window content area in a web browser is a rectangle. Each HTML element follows the W3C box model and thus is also a rectangle.
<br>
Nowadays, devices come in varied shapes of the displays.
It needs to consider the shape of the display when implementing web pages on devices.
However, current web standards lack some features to support the devices as follows:
<ol>
    <li>Lack of the capability to detect the shape of a display</li>
    <li>Lack of layout mechanisms suitable for the shape of a display</li>
</ol>
In order to facilitate the use of the web especially on a round display, there could be some features to support it.
</p>
<p>
The 'shape' media feature is added to Media Queries.
Current user agents are not capable of detecting the shape of a display so that authors cannot apply various layouts for a round display. To resolve the issue, 'shape' informs the web page of the property regarding the shape of the display.
<br><br>
To apply the shape of a display to content area, we extend the 'shape-inside' property of CSS Shapes. The position of the element which is overflowed from the display is adjusted inside the display when using this property even if the authors don’t know the exact shape of the display.
<br><br>
We also add the 'border-boundary' property to CSS Borders. The borders of the element can be drawn along the edge of the display even if the element is overflowed.
<br><br>
For the better web design suitable for a round display, we introduce polar positioning.
In conventional positioning method, the Cartesian coordinates, elements are positioned by offsets in x-axis and y-axis. But, we suggest a method to position elements with specifying the distance and angle from the origin point of coordinates.

This module provides features such as:

	* 	Detecting the rounded display
	* 	Aligning contents in the display’s shape
	* 	Drawing borders along the display’s edge
	* 	Positioning elements in polar coordinates

Terminology {#terminology}
==================================================

This specification follows the CSS property definition conventions from [[!CSS21]]. <br/>
The detailed description of Media Queries is defined in [[MEDIAQUERIES-4]]<br/>
The detailed description of CSS Shapes is defined in [[CSS-SHAPES-1]]<br/>
The detailed description of Borders is defined in [[CSS3-BORDER]]<br/>
The detailed description of Positioned Layout is defined in [[CSS3-POSITIONING]]<br/>

Extending Media Queries for a round display {#extending-media-queries}
==================================================

Media Queries [[MEDIAQUERIES-4]] define mechanisms to support media-dependent style sheets, 
tailored for different environments. We propose to extend Media Queries 
by adding the 'shape' media feature to support various types of displays. 
This will allow web authors to apply different styles to a web page on the rounded display.

<h3 id="shape-media-feature">The 'shape' media feature</h3>

<pre class='descdef mq'>
    Name: shape
    Type: discrete
    For: @media
    Value: rect | round
</pre>

Describes the general shape of the targeted display area of the output device.
It accepts the following values:

    <dl dfn-type=value dfn-for="@media/shape">
        <dt><dfn>rect</dfn>
        <dd>
            The shape is an axis aligned rectangle or square, or a similar shape 
			such as rounded rectangle for which the traditional designs are appropriate.

        <dt><dfn>round</dfn>
        <dd>
            The shape is rounded or a similar shape to the circle such as an oval, an ellipse for which distinctively rounded designs are appropriate.
    </dl>

<div class='example'>
	The following examples show what 'shape' media feature can do when the web page
	is on the various shapes of displays.
	The sample web page is a simple clock application written in HTML and seen through
	the rectangular display and the rounded display.

	In the first example, the clock application doesn't implemented with 'shape' media feature, 
	so it can't deal with different types of displays. 
	It only uses 'rectangle.css' which is designed for the rectangular display 
	no matter what the type of the display is.
	On the round display, some parts of the clock application would be clipped.

    <pre class="lang-html">
    &lt;!DOCTYPE html>
    &lt;html>
    &lt;head>
        &lt;link rel="stylesheet" href="rectangle.css" />
    &lt;/head>
    &lt;body>
        &lt;div id="clockLayer">
            &lt;div id="clockLayer">
                &lt;div id="date">2015/02/28 (SAT)&lt;/div>
                &lt;div id="time">10:11&lt;/div>
                &lt;div id="weather">&lt;img src="cloudy.png" />&lt;/div>
            &lt;/div>
        &lt;/div>
    &lt;/body>
    &lt;/html>
    </pre>

	<div class="figure">
		<div class="example-table">
			<div class="desc">
				<img alt="An image of a clock within a rectangle display" src="images/device_radius_clock_a.png">
				<p>(A) Rectangle Display</p>
			</div>
			<div class="desc">
				<img alt="An image of a clock within a round display" src="images/device_radius_clock_b.png">
				<p>(B) Round Display</p>
			</div>
		</div>
		<figcaption>
			Clock Application without the 'shape' media feature
		</figcaption>
	</div>

	On the other hand, in the second example, the clock application uses 'shape' media feature.
	The following media queries are added to the code of the clock application from 
	the first example.

    <pre class="lang-html">
    &lt;!-- index.html -->
    &lt;head>
        &lt;link media="screen and (shape: rect)" rel="stylesheet" href="rectangle.css" />
        &lt;link media="screen and (shape: round)" rel="stylesheet" href="round.css" />
    &lt;/head>
    </pre>

	If the clock application is loaded in a round display, 'round.css' which is the design for
	the round display will be applied by the Media Queries mechanism.

	<div class="figure">
		<div class="example-table">
			<div class="desc">
				<img alt="An image of a clock within a rectangle display" src="images/device_radius_clock_a.png">
				<p>(A) Rectangle Display<br>(when 'shape: rect' returns ''true'')</p>
			</div>
			<div class="desc">
				<img alt="An image of a clock within a round display" src="images/device_radius_clock_c.png">
				<p>(B) Round Display<br>(when 'shape: round' returns ''true'')</p>
			</div>
		</div>
		<figcaption>
			Clock Application with the 'shape' media feature
		</figcaption>
	</div>
</div>
<p class="note">
Note: So far, the only standard APIs of Operating System which exposes 
information about the display's shape is 
<a href="http://developer.android.com/intl/es/reference/android/content/res/Configuration.html#isScreenRound%28%29">''isScreenRound()'' API</a>
in Android. 
<a href="http://developer.android.com/intl/es/reference/android/content/res/Configuration.html#isScreenRound%28%29">''isScreenRound()'' API</a>
 returns a boolean that says round or not.<br>
Refered the semantics of this API, when isScreenRound() returns ''true'', ''shape: round'' should evaluate
 to ''true''
and ''shape: rect'' should evaluate to ''false'' when isScreenRound() returns ''false''.<br>
'shape' is dealing with 2 shapes, but it can be extended if there are the needs about
configuring other shapes from the developers.
</p>
<p class="note">Note: There are cases when the UA may know the shape even in the absence of OS APIs. 
For example, when rendering to PDF, the shape is known to be a rectangle, so 'shape: rect' evaluates to
 ''true'' while ''shape: round'' to ''false''
</p>

Extending the @viewport rule {#extending-viewport-rule}
==================================================

<h3 id="viewport-fit-descriptor">The 'viewport-fit' descriptor</h3>

'viewport-fit' can set the size of the visual viewport.

<pre class=descdef>
    Name: viewport-fit
    For: @viewport
    Value: auto | contain | cover
    Initial: auto
    Percentages: N/A
    Media: visual, continuous
    Computed value: as specified
</pre>

The initial layout viewport seen through the physical screen of the device.
On rounded screen, the part of the page that’s currently shown on-screen is round but 
the viewport is rectangular.
Because of this, depending on the size of the viewport, some part of the page may be clipped.

<div class=figure>
    <img alt="An image of the clipped area between the viewport bounding box and the device's border" style="width: 250px" src="images/viewport_clipped_area.png">
    <figcaption>
        Clipped area
    </figcaption>
</div>

'viewport-fit' can control the clipped area by setting the size of the visual viewport.

Values have the following meanings:

<dl dfn-type=value dfn-for=viewport-fit>
    <dt><dfn>auto</dfn></dt>
    <dd>
        This value doesn’t affect the initial layout viewport, 
		and the whole web page is viewable. 
		What the UA paints outside of the viewport is undefined. 
		It may be the background color of the canvas, or anything else 
		that the UA deems appropriate.
    </dd>

    <dt><dfn>contain</dfn></dt>
    <dd>
        The initial layout viewport and the visual viewport are set to the largest rectangle 
		which is inscribed in the display of the device.
		What the UA paints outside of the viewport is undefined. 
		It may be the background color of the canvas, or anything else that
		the UA deems appropriate.
    </dd>
    <p class="note">Note: With this value, 'border-boundary: display' and 
	'shape-inside: display' have no effect.</p>

    <dt><dfn>cover</dfn></dt>
    <dd>
        The initial layout viewport and the visual viewport are set to the circumscribed 
		rectangle of the physical screen of the device.
    </dd>
</dl>

When setting the size of the bounding box for the viewport on the non-rectangular display, we have to consider the factors like below:

<ul>
    <li>Clipped area which is caused because the area of the viewport bounding box is larger than the area of the display</li>
    <li>Gap between the bounding box for the viewport and the area of the display</li>
</ul>
    
The author can decide which factor is more critical than another. 
If it have to be guaranteed that any part of the web page isn’t hidden, avoiding clipping is more important than having a gap between the bounding box of the viewport and the border of the screen. If the author doesn’t want web pages to be small for the readability, then it would be better to set 'viewport-fit' as ''cover'' and to implement pages with considering the clipped parts.

<div class='example'>

    This example shows the size of the bounding box for the viewport specified with 'viewport-fit' on the rounded display.
    
    When the 'viewport-fit' is specified with ''contain'', the initial viewport is applied to the largest inscribed rectangle of the display.

    <pre class="lang-css">
    @viewport (viewport-fit: contain) {
        /* CSS for the rectangular design */
    }      
    </pre>

    <div class=figure>
        <img src="images/viewport_fit_contain.png" alt="An image about the viewport applied to the bounding box specified with 'viewport-fit: contain'" style="width: 300px; text-align: center"/>
        <figcaption>
            With '<code>viewport-fit: contain</code>'
        </figcaption>
    </div>

    When ''cover'' is given to the 'viewport-fit', the initial viewport is applied to the circumscribed rectangle of the display.

    <pre class="lang-css">
    @viewport {
        viewport-fit: cover;
    }
    @media (shape: round){
        /* styles for the round design */
    }
    @media (shape: rect){
        /* styles for the rectangular design */
    }
    </pre>

    <div class=figure>
        <img src="images/viewport_fit_cover.png" alt="An image about the viewport applied to the bounding box specified with 'viewport-fit: cover'" style="width: 300px; text-align: center"/>
        <figcaption>
            With '<code>viewport-fit: cover</code>'
        </figcaption>
    </div>    
</div>

Aligning content along the display border {#aligning-content}
==================================================

<h3 id="shape-inside-property">The 'shape-inside' property</h3>

CSS Shapes [[CSS-SHAPES-1]] define the 'shape-inside' property that aligns contents along the edge of a possibly non-rectangular wrapping area. Web authors may use this feature to fit contents inside a round display. However, it can be challenging to specify the wrapping area to be identical to the shape of a display. To address such cases, 'shape-inside' is extended with a new value named '<code>display</code>', such an element having this value will have its content (or contained elements) aligned along the display border automatically.

<pre class='link-defaults'>
spec:css21; type:type; text:<uri>
</pre>
<pre class='propdef'>
    Name: shape-inside
    Applies to: block-level elements
    Value: auto | outside-shape | [ <<basic-shape>> || shape-box ] | <<image>> | <code>display</code>
    Initial: auto
    Inherited: no
    Media: visual
    Computed value: computed lengths for <<basic-shape>>, the absolute URI for <<uri>>, otherwise as specified
    Animatable: as specified for <<basic-shape>>, otherwise no
</pre>

The example below shows how the 'shape-inside' property works when it is set to '<code>display</code>'.
Without using Media Queries, contents can be aligned within the display edge automatically.

<div class='example'>
    <pre class="lang-html">
    &lt;style>
        #container {
            shape-inside: display;
            // the same as circle(50% at 50%, 50%) in a regular round display
        }
        #green-box { float: left; }
        #blue-box { float: right; }
    &lt;/style>
    &lt;div id="container">
        &lt;p>
            Some inline content
            &lt;img id="green-box" src="green-box.jpg" />
            with a float left and float right, in a
            &lt;img id="blue-box" src="blue-box.jpg" />
            simple box with a circle shape-inside.
        &lt;/p>
    &lt;/div>
    </pre>
    <br />

    <div class=figure>
        <div class="example-table">
            <div class="desc">
                <img alt="A layout of web contents without shape-inside:display" style="width: 230px" src="images/shape_inside_watch_a.png">
                <p>(A) Without '<code>shape-inside</code>'</p>
            </div>
            <div class="desc">
                <img alt="A layout of web contents with shape-inside: display" style="width: 230px" src="images/shape_inside_watch_b.png">
                <p>(B) With '<code>shape-inside: display</code>'</p>
            </div>
        </div>
        <figcaption>
            Align the content along the display border
        </figcaption>
    </div>
</div>

This property is specially useful for complex shapes (e.g. curved, stelliform, polygonal), that wouldn't be covered by <<basic-shape>> (i.e. circle() or ellipse()), allowing web authors to conveniently align contents with the display edge.

When a containing block is placed on one end of the display and the containing block has 'shape-inside: display', the descendant blocks of the containing block are basically put on the overlapping region between the containing block and the display area. The overlapping region's shape is mostly complicated shape, so it's difficult to define the shape using previous method like basic-shape. The figure 4 describes these circumstances as follows.

<div class=figure>
    <img alt="An image of two examples to show the principle of shape-inside: display" style="width: 500px" src="images/shape_inside_a.png">
    <figcaption>
        Align the content along the display border
    </figcaption>
</div>

<p class="issue">
What if content overflows? Clipping or scrolling?
</p>

Drawing borders around the display border {#drawing-borders}
==================================================

<h3 id="border-boundary-property">The 'border-boundary' property</h3>

We add the 'border-boundary' property to set a boundary constraint that affects the borders of an element.

<pre class='propdef'>
    Name: border-boundary
    Applies to: all elements
    Value: none | parent | display
    Initial: none
    Inherited: yes
    Media: visual
</pre>

When the 'border-boundary' property on an element is set to '<code>parent</code>', additional borders of the element could be drawn where the element's area and the borders of its parent are met. When it is set to '<code>display</code>', additional borders could be drawn where the element's area and the borders of screen are met. The default value is '<code>none</code>', imposing no boundary constraint on the borders.

<div class='example'>
The example below shows how the 'border-boundary' property works on drawing borders. The result is shown in Figure 5B.
    <pre class="lang-html">
    &lt;style>
        #container {
            border-boundary: display;
        }
        #redBox {
            border: 5px red solid;
        }
        #greenBox {
            border: 5px green solid;
        }
        #blueBox {
            border: 5px blue solid;
        }
    &lt;/style>
    &lt;div id="container">
        &lt;div id="redBox">&lt;/div>
        &lt;div id="greenBox">&lt;/div>
        &lt;div id="blueBox">&lt;/div>
    &lt;/div>
    </pre>
    <br />

    <div class=figure>
        <div class="example-table">
            <div class="desc">
                <img alt="An image of circle drawing border lines without border-boundary: display" style="width: 200px" src="images/border_boundary_a.png">
                <p>(A) Without '<code>border-boundary</code>'</p>
            </div>
            <div class="desc">
                <img alt="An image of circle drawing border lines with border-boundary: display" style="width: 200px" src="images/border_boundary_b.png">
                <p>(B) With '<code>border-boundary: display</code>'</p>
            </div>
        </div>
        <figcaption>
            Align the content along the display border
        </figcaption>
    </div>

</div>

<p class="note">Note: If the value of 'border-boundary' is parent or display, border lines of the element are actually just a visual effect. It triggers a layout for rendering in a general way, but in the above cases (border-boundary: parent|display), the layout doesn't occur and it only draws the border lines inward from the containing block's borders. With this situation, the borders might hide contents around the display edge.
</p>

Position the element along the path {#positioning-content-along-a-path}
==================================================

This section introduces specifying a path and positioning the element along it.

A path can be defined with 'offset-path' and 'offset-position'. The position of the element on the path is computed by the value of 'offset-distance' and 'offset-anchor'.

<h3 id="offset-path-property">Define the path: The 'offset-path' property</h3>

<pre class='propdef'>
    Name: offset-path
    Applies to: All elements. In SVG, it applies to <a>container elements</a> excluding the <{defs}> element and all <a>graphics elements</a>
    Value: <<url>> | <<angle>> && contain? | [ <<basic-shape>> | <<path()>> ] || <<geometry-box>> | none
    Initial: 0deg for <<angle>>, otherwise no
    Media: visual
    Inherited: no
    Percentages: N/A
    Animatable: as specified for <a href="https://www.w3.org/TR/css3-transitions/#animatable-types">angle</a>, otherwise no
</pre>

Specifies the <a>path</a> the element gets positioned at. The exact element’s position on the path is determined by the 'offset-distance' property. A <dfn>path</dfn> is either a specified path with one or multiple sub-paths or the geometry of a not styled basic shape. Each shape or path must define an <dfn>initial position</dfn> for the computed value of "0" for 'offset-distance' or the position specified by 'offset-position'. An <dfn>initial direction</dfn> which specifies the rotation of the object on the initial position.

Values have the following meanings:

<dl dfn-for="offset-path">
  <dt><<angle>></dt>
  <dd>
    The path is a straight line that starts from the current position of the element and has the degree of the angle as specified in <<angle>> from the Y-axis. The path ends at the edge of the containing block.

    <dl>
        <dt><dfn>contain</dfn></dt>
        <dd>
           Adjust the value of 'offset-distance' when the element goes out of the path. When overflowing occurs, the distance value is reduced, until the end point of the path is on the edge of the element.
        </dd>
    </dl>
    
    <p class="note">Note: Defining the path with <<angle>>, the element can be positioned in the polar coordinate system. In polar coordinates, a pole is the reference point and points are described as been a certain distance from it, as also a certain angle from the polar axis. In mathematical theory, the polar axis is commonly defined as the positive direction of the x-axis, but we consider the polar axis as the positive direction of the y-axis position as other CSS specifications usually do. Therefore, when the <<angle>> value of 'offset-path' is 0, the element is positioned on the y-axis. If the <<angle>> value increases in the positive direction from 0, the element moves clockwise. The method to determine a direction using the <<angle>> value for 'offset-path' works the same way in [[!CSS3VAL]], <<angle>> value.</p>
  </dd>

  <dt><<basic-shape>></dt>
  <dd>
    The path is a basic shape as specified in CSS Shapes [[CSS-SHAPES-1]]. The initial position and the initial direction for basic shapes are defined as follows:
    <dl>
      <dt><<circle()>></dt>
      <dt><<ellipse()>></dt>
      <dd>The <a>initial position</a> is defined by the point where a virtual tangent to the circle/ellipse would reach the top vertical position. The <a>initial direction</a> is 90 degrees.</dd>
      <dt><<inset()>></dt>
      <dd>The <a>initial position</a> is defined by the left top corner of the rectangle. The <a>initial direction</a> is 0 degree.</dd>
      <dt><<polygon()>></dt>
      <dd>The <a>initial position</a> is defined by the first coordinate pair of the polygon. The <a>initial direction</a> is defined by the vector connecting the initial position with the next following coordinate pair that isn't equal to the initial position. If there is no such unequal coordinate pair, the initial direction is defined with 0 degree.</dd>
    </dl>
  </dd>
  <dt><dfn>path()</dfn> = path([ <<fill-rule>> ,]? <<string>>)</dt>
  <dd>
    <p>The <<string>> represents an SVG Path data string. The path data string must be conform to the grammar and parsing rules of SVG 1.1 [[!SVG11]]. The initial position is defined by the first “move to” argument in the path string. For the initial direction follow SVG 1.1 [[!SVG11]].
    <p><<fill-rule>> - The filling rule used to determine the interior of the path. See 'fill-rule' property in SVG for details. Possible values are ''nonzero'' or ''evenodd''. Default value when omitted is ''nonzero''.
  </dd>
  <dt><<url>></dt>
  <dd>
    References an SVG <a>shape element</a> and uses its geometry as path. See SVG 1.1 for more information about the initial position and initial direction [[!SVG11]].
  </dd>
  <dt dfn-type=value><dfn>none</dfn></dt>
  <dd>No path gets created.</dd>
</dl>

A computed value of other than ''none'' results in the creation of a <a spec="css21">stacking context</a> [[!CSS21]] the same way that CSS 'opacity' [[CSS3COLOR]] does for values other than ''1'', unless the element is an SVG element with out an associated CSS layout box.

A reference that fails to download, is not a reference to an SVG <a>shape element</a> element, or is non-existent is ignored. No path and no stacking context are created.

For SVG elements without associated CSS layout box, the <a>used value</a> for <a value for=mask-clip>content-box</a>, <a value for=mask-clip>padding-box</a>, <a value for=mask-clip>border-box</a> and <a value for=mask-clip>margin-box</a> is <a value for=clip-path>fill-box</a>.

For elements with associated CSS layout box, the <a>used value</a> for <a value for=clip-path>fill-box</a>, <a value for=clip-path>stroke-box</a> and <a value for=clip-path>view-box</a> is <a value for=mask-clip>border-box</a>.

<div class='example'>
    Here are some examples. The first example shows some parts of elements are outside of the path.

    <pre class="lang-html">
        &lt;body>
          &lt;div style="offset-path: 45deg; offset-distance: 100%">&lt;/div>
          &lt;div style="offset-path: 180deg; offset-distance: 100%">&lt;/div>
        &lt;/body>
    </pre>
    <div class=figure> 
        <img alt="An image of elements positioned without ''contain''" src="images/offset_distance_without_contain.png" style="width: 300px;"/>
        <figcaption>
            'offset-path' without 'contain'
        </figcaption>
    </div>

    In the second example, ''contain'', the extent keyword value is added to the 'offset-path' value of each element to avoid overflowing.

    <pre class="lang-html">
        &lt;body>
          &lt;div style="offset-path: 45deg contain; offset-distance: 100%">&lt;/div>
          &lt;div style="offset-path: 180deg contain; offset-distance: 100%">&lt;/div>
        &lt;/body>
    </pre>
    <div class=figure>    
        <img alt="An image of elements positioned without ''contain''" src="images/offset_distance_with_contain.png" style="width: 300px;"/>
        <figcaption>
            'offset-path' with ''contain''
        </figcaption>
    </div>
</div>

<h3 id="offset-position-property">Define the initial position of the path: The 'offset-position' property</h3>
<pre class='propdef'>
    Name: offset-position
    Applies to: all elements
    Value: auto | <<position>>
    Initial: auto
    Media: visual
    Inherited: no
    Percentages: Refer to the size of containing block
    Animatable: as <a href="https://www.w3.org/TR/css3-transitions/#animtype-lpcalc">position</a>
</pre>

Specifies the initial position of the path.

Values are defined as follows:

 <dl dfn-for="offset-position" dfn-type="value">
    <dt>auto</dt>
    <dd>
    Computes to the current position of the element.
    </dd>

    <dt><<position>></dt>
    <dd>
    Values of <<position>> are defined like below:

        <dl>
            <dt><<percentage>></dt>
            <dd>
            A percentage for the horizontal offset is relative to the width of the containing block. A percentage for the vertical offset is relative to height of the containing block.
            </dd>

            <dt><<length>></dt>
            <dd>
            A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the containing block.
            </dd>

            <dt><dfn>top</dfn></dt>
            <dd>
            Computes to 0% for the vertical position.
            </dd>

            <dt><dfn>right</dfn></dt>
            <dd>
            Computes to 100% for the horizontal position.
            </dd>

            <dt><dfn>bottom</dfn></dt>
            <dd>
            Computes to 100% for the vertical position.
            </dd>

            <dt><dfn>left</dfn></dt>
            <dd>
            Computes to 0% for the horizontal position.
            </dd>

            <dt><dfn>center</dfn></dt>
            <dd>
            Computes to 50% (left 50%) for the horizontal position if the horizontal position is not otherwise specified, or 50% (top 50%) for the vertical position if it is.
            </dd>
        </dl>
    </dd>
</dl>

<h3 id="offset-distance-property">Position on the path: The 'offset-distance' property</h3>
<pre class='propdef'>
    Name: offset-distance
    Applies to: All elements
    Value: [ <<length>> | <<percentage>> <<size>>? ]
    Initial: 0
    Media: visual
    Inherited: no
    Percentages: Refer to the total length of the path
    Animatable: yes
</pre>

A distance that describes the position along the specified path.

Values are defined as follows:

<dl>
    <dt><<length>></dt>
    <dd>
       The distance from the initial position of the shape or path to the position of the element. Percentages are relative to the total path length including all sub-paths.
    </dd>

    <dt><<percentage>></dt>
    <dd>
       Is relative to the length of the path. The length is a distance between the initial position and the end position which is the contact point of the edge of the containing block and the path.
    </dd>

    <dt><<size>></dt>
    <dd>Decides a point used for measuring the distance from the initial position of the path.             

        It is defined as

        &nbsp;<b>&lt;size&gt;</b> = [ closest-side | closest-corner | farthest-side | farthest-corner ]

        If omitted it defaults to <var>closest-side</var>.

        <dl>
          <dt><dfn>closet-side</dfn></dt>
          <dd>The distance is measured between the initial position and the closest side of the box from it.</dd>

          <dt><dfn>closest-corner</dfn></dt>
          <dd>The distance is measured between the initial position and the closest corner of the box from it.</dd>

          <dt><dfn>farthest-side</dfn></dt>
          <dd>The distance is measured between the initial position and the farthest side of the box from it.</dd>

          <dt><dfn>farthest-corner</dfn></dt>
          <dd>The distance is measured between the initial position and the farthest corner of the box from it.</dd>
        </dl>
        <p class='note'>Note: When the initial position is at one of the corners of the containing block, the closest side takes the edge where the initial position is on. Even if the offset given by <<length>> or <<percentage>> changes, the position of the element specified with <var>closest-side</var> is the same.</p>
    </dd>
</dl>

See the section Motion processing for how to process a motion position.

<div class='example'>
    This example shows a way to align elements within the polar coordinate system using 'offset-path', 'offset-distance' and 'offset-position'.

    <pre class="lang-html">
        &lt;body>
          &lt;div id="circle1"&lt;/div>
          &lt;div id="circle2"&lt;/div>
          &lt;div id="circle3"&lt;/div>
        &lt;/body>
        &lt;style>
            #circle1 {
               offset-path: 0deg;
               offset-distance: 50%;
            }
            #circle2 {
               offset-path: 90deg;
               offset-distance: 20%;
            }
            #circle3 {
               offset-path: 225deg;
               offset-distance: 100%;
            }
        &lt;/style>
    </pre>
    <div class=figure> 
        <img alt="An image of three elements positioned to polar coordinates" src="images/simple_offset_position.png" style="width: 300px;"/>
        <figcaption>
            An example of positioning element in polar coordinates
        </figcaption>
    </div>
</div>

<h3 id="offset-anchor-property">The anchor of the element: The 'offset-anchor' property</h3>
<pre class='propdef'>
    Name: offset-anchor
    Applies to: All elements
    Value: <<position>>
    Initial: auto
    Media: visual
    Inherited: no
    Percentages: Relative to width and height of an element
    Animatable: as <<position>>
</pre>

Defines an origin of the element in the path. The origin specifies a position which is a representative point of the element and could be set as any point within a content area of the element. The element's point of origin is placed along the path.

Values have the following meanings:

<dl dfn-for="offset-anchor" dfn-type="value">
    <dt>auto</dt>
    <dd>
       Computes to the value from 'offset-position'. When ''auto'' is given to 'offset-anchor', 'offset-position' behaves similar to 'background-position'.
    </dd>

    <dt><<position>></dt>
    <dd>
        <dl>
          <dt><<percentage>></dt>
          <dd>A percentage for the horizontal offset is relative to width of content box area of the element. A percentage for the vertical offset is relative to height of content box area of the element. For example, with a value pair of ''100%, 0%'', an anchor point is on the upper right corner of the element.</dd>

          <dt><<length>></dt>
          <dd>A length value gives a length offset from the upper left corner of the element's content area.</dd>
        </dl>
    </dd>
</dl>

<div class='example'>
    The following explains how to set the origin of the element.

    <pre class="lang-css">
        #plane {
            offset-anchor: center;
        }
    </pre>

    The red dot in the middle of the shape indicates the origin of the shape.
    <div class=figure>
        <img src="images/plane.svg" width="160" height="140" alt="Shape with its origin">
        <figcaption>
            A red dot in the middle of a plane shape indicates the shape's origin.
        </figcaption>
    </div>
</div>

<div class='example'>
    This example shows an alignment of four elements with different origin points.

    <pre class="lang-html">&lt;style>
    
        #item1 {
            offset-path: 45deg;
            offset-distance: 100%;
            offset-anchor: right top;
        }
        #item2 {
            offset-path: 135deg;
            offset-distance: 100%;
            offset-anchor: right bottom;
        }
        #item3 {
            offset-path: 225deg;
            offset-distance: 100%;
            offset-anchor: left bottom;
        }
        #item4 {
            offset-path: 315deg;
            offset-distance: 100%;
            offset-anchor: left top;
        }
    &lt;/style>
    &lt;body>
        &lt;div id="item1">&lt;/div>
        &lt;div id="item2">&lt;/div>
        &lt;div id="item3">&lt;/div>
        &lt;div id="item4">&lt;/div>
    &lt;/body>
    </pre>

    <div class=figure>
        <img src="images/offset_anchor.png" alt="An example of offset-anchor" style="width: 300px;">
        <figcaption>
            An example of 'offset-anchor'
        </figcaption>
    </div>
</div>

<p class="issue">
How can the margin be applied to an element when <code>offset-position: 50% 50%</code> and <code>offset-anchor: 50% 50%</code>?
<br>
Which would be a base point for applying it between the upper left corner or center of a containing block?
With the former, the position of the element changes when the value of the margin changes, while with the latter, the margin value doesn't affect the position of the element.
</p>

<h3 id="offset-rotation-property">Rotation at point: The 'offset-rotation' property</h3>
<pre class='propdef'>
    Name: offset-rotation
    Value: [ auto | reverse ] || <<angle>>
    Initial: 0
    Applies to: All elements. In SVG, it applies to <a href="">container elements</a> excluding the <{defs}> element and all <a>graphics elements</a>
    Inherited: no
    Percentages: n/a
    Computed value: as specified
    Media: visual
    Animatable: yes
</pre>

Defines the direction of the element while positioning along the <a>path</a>.

Values have the following meanings:

<dl dfn-for="offset-rotation" dfn-type="value">
  <dt>auto</dt>
  <dd>Indicates that the object is rotated (over time if 'motion-offset' is animated) by the angle of the direction (i.e., directional tangent vector) of the <a>path</a>. If specified in combination with <<angle>>, the computed value of <<angle>> is added to the computed value of ''auto''.</dd>
  <dt><dfn>reverse</dfn></dt>
  <dd>
    <p>Indicates that the object is rotated (over time if 'motion-offset' is animated) by the angle of the direction (i.e., directional tangent vector) of the <a>path</a> plus 180 degrees. If specified in combination with <<angle>>, the computed value of <<angle>> is added to the computed value of ''reverse''.
      <p class="note">This is the same as specifying ''auto 180deg''.
  </dd>
  <dt><<angle>></dt>
  <dd>Indicates that the element has a constant rotation transformation applied to it by the specified rotation angle. See definitions of ''auto'' or ''reverse'' if specified in combination with either one of the keywords. For the purpose of this argument, ''0deg'' points to the direction of the positive y-axis, and positive angles represent clockwise rotation, so ''90deg'' point toward the direction of the positive x-axis.</dd>

  <p class="issue">
    Between the direction of the positive y-axis and that of the positive x-axis, which ''0deg'' indicates? 
    In mathematical theory, ''0deg'' is commonly defined as the positive direction of the x-axis, but <<angle>> value in [[CSS3VAL]] specifies it as upper or north side on the screen.
  </p>
</dl>

<p class="note">
Note: The rotation described here does not override or replace any rotation defined by the 'transform' property.
</p>

<div class="example">
  <p>When the shape's point of origin is placed at different positions along the path and 'offset-rotation' isn't specified, the shape points to the positive direction of the x-axis.</p>

  <div class=figure>
    <img src="images/offset-rotation-none.svg" width="470" height="120" alt="Path without rotation">
    <figcaption>
        A black plane at different positions on a blue dotted path without rotation transforms.
    </figcaption>
  </div> 

  <p>This shows an example when the 'offset-rotation' property is set to ''auto''. The shape is rotated based on the gradient at the current position and faces the direction of the path at this position.</p>

  <div class=figure>
    <img src="images/offset-rotation-auto.svg" width="470" height="120" alt="Path with auto rotation">
    <figcaption>
        A black plane at different positions on a blue dotted path, rotated in the direction of the path.
    </figcaption>
  </div>

  <p>This example is when the 'offset-rotation' property is set to ''reverse''. The plane faces the opposite direction of the path at each position on the path.
  <div class=figure>
    <img src="images/offset-rotation-reverse.svg" width="470" height="120" alt="Path with reverse auto rotation">
    <figcaption>
        A black plane at different positions on a blue dotted path, rotated in the opposite direction of the path.
    </figcaption>
  </div>

  <p>The last example sets the 'offset-rotation' property to ''45deg''. The shape is rotated by 45 degree once and keeps the rotation at each position on the path.
  <div class=figure>
    <img src="images/offset-rotation-45.svg" width="470" height="120" alt="Path with fixed rotation">
    <figcaption>
        A black plane at different positions on a blue dotted path, rotated by a fixed amount of degree.
    </figcaption>
  </div>
</div>

<div class='example'>
This example shows how ''auto'' or ''reverse'' works specified in combination with <<angle>>. The computed value of <<angle>> is added to the computed value of ''auto'' or ''reverse''.

<pre class="lang-html">&lt;style>

    body {
        border-radius: 50%;
    }
    #item1 {
        offset-path: 0deg;
        offset-distance: 90%;
        offset-rotate: auto 90deg;
	}
    #item2 {
        offset-path: 45deg;
        offset-distance: 90%;
        offset-rotate: auto 90deg;
    }
    #item3 {
        offset-path: 135deg;
        offset-distance: 90%;
        offset-rotate: auto -90deg;
    }
    #item4 {
        offset-path: 180deg;
        offset-distance: 90%;
        offset-rotate: auto -90deg;
    }
    #item5 {
        offset-path: 225deg;
        offset-distance: 90%;
        offset-rotate: auto -90deg;
    }
    #item6 {
        offset-path: -45deg;
        offset-distance: 90%;
        offset-rotate: auto 90deg;
    }
&lt;/style>
&lt;body>
	&lt;div id="item1">1&lt;/div>
	&lt;div id="item2">2&lt;/div>
	&lt;div id="item3">3&lt;/div>
	&lt;div id="item4">4&lt;/div>
	&lt;div id="item5">5&lt;/div>
	&lt;div id="item6">6&lt;/div>
&lt;/body>
</pre>
<div class="figure">
	<img alt="An image of example for offset-rotation" src="images/2d_rotate_function.png" style="width: 250px; text-align: center"/>
	<figcaption>
        The elements are rotated by the value of ''auto'' with a fixed amount of degree.
    </figcaption>
</div>
</div>

<h3 id="position-processing">Position processing</h3>

<h4 id="calculating-the-computed-distance-along-a-path">Calculating the computed distance along a path</h4>

Processing the distance along a path operates differently depending upon whether
the path is open or closed:

*   All basic CSS shapes are closed. 
*   Paths (including references to SVG Paths) are closed only if the final command 
    in the path list is a closepath command ("z" or "Z").
*   References to SVG circles, ellipses, images, polygons and rects are closed.
*   References to SVG lines and polylines are open.
*   References to lines defined with <<angle>> are open.

To determine the <dfn>computed distance</dfn> for a given <var>path</var> and <var>distance</var>:

<div class="switch">

1.  Let the <var>total length</var> be the total length of <var>path</var> with all
    sub-paths.

2.  
    :   If <var>distance</var> is a length:
    ::  Let <var>upper bound</var> be equal to the <var>total length</var>.
    :   Otherwise:
    ::  Let <var>upper bound</var> be equal to 100%.

3.  
    :   If <var>path</var> is a closed path:
    ::  Let <a>computed distance</a> be equal to <var>distance</var> modulus <var>upper bound</var>.
    :   Otherwise:
    ::  Let <a>computed distance</a> be equal to <var>distance</var> clamped by 0 and <var>upper bound</var>.

</div>

<h4 id="calculating-path-transform">Calculating the path transform</h4>

<div class="switch">
1.  Let <var>path</var> be the geometry of the specified basic shape, path or
    SVG <a>shape element</a> reference.
2.  Let <var>distance</var> be the computed value of 'offset-distance'.
3.
    :   If <var>path</var> is a valid path:
    ::  

        1.  Determine the <a>computed distance</a> by invoking the process for
            <a href='#calculating-the-computed-distance-along-a-path' section>
            Calculating the computed distance along a path</a> on
            <var>path</var> and <var>distance</var>.
        2.  Let <var>position</var> be the coordinate pair at 
            <a>computed distance</a> along <var>path</var>.
        3.  Create the supplemental transformation matrix <var>transform</var>
            to the local coordinate system of the element.
        4.  Translate <var>transform</var> by <var>position</var>.
        5.  Let <var>rotate</var> be the computed value of 'offset-rotation'.
        6.  Post-multiply the rotation <var>rotate</var> to <var>transform</var>.
        7.  Post-multiply <var>transform</var> to the local coordinate system of
            the element.

</div>

Use Cases {#usecases}
==================================================

	Use cases are described on
	<a href="https://wiki.csswg.org/ideas/round-display">these</a>.

Changes {#changes}
==================================================

<h3 id="changes_from_Sep_22_2015">
Changes from <a href="https://www.w3.org/TR/2015/WD-css-round-display-1-20150922/">September 22<sup>th</sup> 2015</a> version</h3>

	<ul>
		<li>Added ''polar-anchor''</li>
		<li>Added ''contain'' for polar-distance for avoiding the overflow issue.</li>
		<li>Added ''polar-origin''</li>
		<li>Added extension for 2d rotation function for polar coordinates</li>
		<li>Changed naming of keyword values for 2d rotation function</li>
		<li>Removed ''polar'' value of 'position'. Polar positioning applies to absolute/fixed/sticky/relative positioned elements</li>
		<li>Added ''auto'' value to ''polar-origin'' and make it as initial value</li>
		<li>Added &lt;size> keywords to ''polar-distance''</li>
		<li>Added the Acknowledgements, Use cases, and Changes</li>
	</ul>

Security Considerations {#security-considerations}
==================================================

    There are no known security issues introduced by these features.

Privacy Considerations {#privacy-considerations}
==================================================

    There are no known privacy issues introduced by these features.

Acknowledgements {#acks}
==================================================
	This specification is made possible by input from Dong-Young Lee, Soonbo Han, Florian Rivoal, Joone Hur,
	Kang-Soo Seo, Sangjo Park, Woojun Jung, Chisoon Jeong, Yunbum Sung, Alan Stearns, Brad Kemper, and the CSS Working Group members.
	Thanks also to Adenilson Cavalcanti for editorial input.
