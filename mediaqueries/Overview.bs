<pre class='metadata'>
Title: Media Queries Level 4
Group: csswg
Shortname: mediaqueries
Level: 4
Status: WD
Work Status: Exploring
ED: https://drafts.csswg.org/mediaqueries-4/
TR: http://www.w3.org/TR/mediaqueries-4/
Previous Version: http://www.w3.org/TR/2016/WD-mediaqueries-4-20160126/
Editor: Florian Rivoal, Vivliostyle, florian@rivoal.net, http://vivliostyle.com, w3cid 43241
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact/, w3cid 42199
Former Editor: Håkon Wium Lie, Opera, howcome@opera.com
Former Editor: Tantek Çelik, Mozilla, tantek@cs.standard.edu
Former Editor: Daniel Glazman, Disruptive Innovations, daniel@glazman.org
Former Editor: Anne van Kesteren, Mozilla, annevk@annevk.nl
Abstract: <a>Media Queries</a> allow authors to test and query values or features of the user agent or display device, independent of the document being rendered.  They are used in the CSS @media rule to conditionally apply styles to a document, and in various other contexts and languages, such as HTML and Javascript.
Abstract:
Abstract: Media Queries Level 4 describes the mechanism and syntax of media queries, media types, and media features. It extends and supersedes the features defined in Media Queries Level 3.
Ignored Terms: min-resolution, max-resolution, none, view-mode, mediaText, DOMString
Link Defaults: css-break-3 (property) break-inside
Link Defaults: css-cascade-3 (at-rule) @import
</pre>

<pre class=link-defaults>
spec:css-values-3; type:value; text:in
</pre>

<h2 id="intro">
Introduction</h2>

	<em>This section is not normative.</em>

	HTML4 [[HTML401]] defined a mechanism to support media-dependent style sheets,
	tailored for different <a>media types</a>.
	For example, a document may use different style sheets for screen and for print.
	In HTML, this can be written as:

	<div class="example">
		<pre>
			&lt;link rel="stylesheet" type="text/css" media="screen" href="style.css">
			&lt;link rel="stylesheet" type="text/css" media="print" href="print.css">
		</pre>
	</div>

	CSS adapted and extended this functionality with its ''@media'' and ''@import'' rules,
	adding the ability to query the value of individual features:

	<div class="example">
		Inside a CSS style sheet,
		one can declare that sections apply to certain <a>media types</a>:

		<pre>
			@media screen {
				* { font-family: sans-serif }
			}
		</pre>

		Similarly, stylesheets can be conditionally imported based on media queries:

		<pre>@import "print-styles.css" print;</pre>
	</div>

	<a>Media queries</a> can be used with HTML, XHTML, XML [[XMLSTYLE]] and the @import and @media rules of CSS.

	<div class="example">
		Here is the same example written in HTML, XHTML, XML, @import and @media:

		<pre>
			&lt;link media="screen and (color), projection and (color)"
			      rel="stylesheet" href="example.css">

			&lt;link media="screen and (color), projection and (color)"
			      rel="stylesheet" href="example.css" />

			&lt;?xml-stylesheet media="screen and (color), projection and (color)"
			                 rel="stylesheet" href="example.css" ?>

			@import url(example.css) screen and (color), projection and (color);

			@media screen and (color), projection and (color) { … }
		</pre>

		Note: The [[XMLSTYLE]] specification has not yet been updated to
		use media queries in the <code>media</code> pseudo-attribute.
	</div>

<h3 id="placement">
Module interactions</h3>

	This module replaces and extends the Media Queries, Media Type and Media Features
	defined in [[!CSS21]] sections 7 and in [[!MEDIAQ]].

<h3 id="values">
Values</h3>

	Value types not defined in this specification, such as <<integer>>,
	<<number>> or <<resolution>>, are defined in [[!CSS3VAL]].  Other CSS
	modules may expand the definitions of these value types.

<h3 id="units">
Units</h3>

	The units used in media queries are the same as in other parts of CSS, as
	defined in [[!CSS3VAL]]. For example, the pixel unit represents CSS pixels and
	not physical pixels.

	<a spec="css-values">Relative length</a> units in media queries are based on the <a>initial value</a>, which means
	that units are never based on results of declarations. For example, in HTML,
	the ''em'' unit is relative to the <a>initial value</a> of 'font-size',
	defined by the user agent or the user's preferences,
	not any styling on the page.

<!--
██     ██  ███████
███   ███ ██     ██
████ ████ ██     ██
██ ███ ██ ██     ██
██     ██ ██  ██ ██
██     ██ ██    ██
██     ██  █████ ██
-->


<h2 id="media">
Media Queries</h2>

	A <dfn export>media query</dfn> is a method of testing certain aspects of the user agent
	or device that the document is being displayed in.
	<a>Media queries</a> are (almost) always independent of the contents of the document,
	its styling,
	or any other internal aspect;
	they're only dependent on “external” information
	unless another feature explicitly specifies that it affects the resolution of Media Queries,
	such as the ''@viewport'' rule.

	The syntax of a <a>media query</a> consists of
	an optional <a>media query modifier</a>,
	an optional <a>media type</a>,
	and zero or more <a>media features</a>:

	<pre class='railroad'>
	Or:
		N: media condition
		And:
			Or: 1
				T: only
				S:
				T: not
			N: media type
			Opt:
				And:
					T: and
					N: media condition
	</pre>

	A <a>media query</a> is a logical expression that is either true or false.
	A media query is true if:

	* the <a>media type</a>,
		if specified,
		matches the media type of the device where the user agent is running, and
	* the <a>media condition</a> is true.

	Statements regarding media queries in this section assume the <a href="#mq-syntax">syntax section</a> is followed.
	Media queries that do not conform to the syntax are discussed in [[#error-handling]].
	I.e. the syntax takes precedence over requirements in this section.

	<div class="example">
		Here is a simple example written in HTML:

		<pre>&lt;link rel="stylesheet" media="screen and (color)" href="example.css" /></pre>

		This example expresses that a certain style sheet
		(<code>example.css</code>) applies to devices of a certain media type
		(''screen'') with certain feature (it must be a color screen).

		Here is the same media query written in an @import-rule in CSS:

		<pre>@import url(example.css) screen and (color);</pre>
	</div>

	User agents must re-evaluate <a>media queries</a> in response to changes in the user environment that they're aware of,
	for example if the device is tiled from landscape to portrait orientation,
	and change the behavior of any constructs dependent on those <a>media queries</a> accordingly.

	Unless another feature explicitly specifies that it affects the resolution of Media Queries, it is never necessary to apply a style sheet in order to evaluate expressions.

	Note: CSS Device Adaptation [[CSS-DEVICE-ADAPT]]]
	defines how ''@viewport'' rules interact with Media Queries.

<h3 id='mq-list'>
Combining Media Queries</h3>

	Several <a>media queries</a> can be combined into a comma-separated <dfn export>media query list</dfn>.

	<pre class='railroad'>
	Star:
		N: media query
		T: ,
	</pre>

	A <a>media query list</a> is true if <em>any</em> of its component <a>media queries</a> are true,
	and false only if <em>all</em> of its component <a>media queries</a> are false.

	<div class="example">
		For example, the following <a>media query list</a> is true if either
		the <a>media type</a> is ''screen'' and it's a color device,
		<strong>or</strong> the <a>media type</a> is ''projection'' and it's a color device:

		<pre>
		@media screen and (color), projection and (color) { … }
		</pre>
	</div>

	An empty <a>media query list</a> evaluates to true.

	<div class="example">
		For example, these are equivalent:

		<pre>
		@media all { … }
		@media { … }
		</pre>
	</div>

<h3 id='mq-prefix'>
Media Query Modifiers</h3>

	A <a>media query</a> may optionally be prefixed by a single <dfn export>media query modifier</dfn>,
	which is a single keyword which alters the meaning of the following <a>media query</a>.

<h4 id='mq-not'>
Negating a Media Query: the ''not'' keyword</h4>

	An individual <a>media query</a> can have its result negated
	by prefixing it with the keyword <dfn value for="@media">not</dfn>.
	If the <a>media query</a> would normally evaluate to true,
	prefixing it with ''not'' makes it evaluate to false,
	and vice versa.

	<div class="example">
		For example, the following will apply to everything except color-capable screens.
		Note that the entire media query is negated,
		not just the <a>media type</a>.

		<pre>&lt;link rel="stylesheet" media="not screen and (color)" href="example.css" /></pre>
	</div>

<h4 id='mq-only'>
Hiding a Media Query From Legacy User Agents: the ''only'' keyword</h4>

	The concept of <a>media queries</a> originates from HTML4 [[HTML401]].
	That specification only defined <a>media types</a>,
	but had a forward-compatible syntax that accommodated the addition of future concepts like <a>media features</a>:
	it would consume the characters of a <a>media query</a> up to the first non-alphanumeric character,
	and interpret that as a <a>media type</a>,
	ignoring the rest.
	For example, the <a>media query</a> ''screen and (color)''
	would be truncated to just ''screen''.

	Unfortunately, this means that legacy user agents using this error-handling behavior
	will ignore any <a>media features</a> in a <a>media query</a>,
	even if they're far more important than the <a>media type</a> in the query.
	This can result in styles accidentally being applied in inappropriate situations.

	To hide these <a>media queries</a> from legacy user agents,
	the <a>media query</a> can be prefixed with the keyword <dfn value for="@media">only</dfn>.
	The ''only'' keyword <strong>has no effect</strong> on the <a>media query</a>’s result,
	but will cause the <a>media query</a> to be parsed by legacy user agents
	as specifying the unknown <a>media type</a> “only”,
	and thus be ignored.

	<div class="example">
		In this example, the stylesheet specified by the <code>&lt;link></code> element
		will not be used by legacy user agents,
		even if they would normally match the ''screen'' <a>media type</a>.

		<pre>&lt;link rel="stylesheet" media="only screen and (color)" href="example.css" /></pre>
	</div>

	Note: Note that the ''only'' keyword can only be used before a <a>media type</a>.
	A <a>media query</a> consisting only of <a>media features</a>,
	or one with another <a>media query modifier</a> like ''not'',
	will be treated as false by legacy user agents automatically.

	Note: At the time of publishing this specification,
	such legacy user agents are extremely rare,
	and so using the ''only'' modifier is rarely, if ever, necessary.

<!--
████████ ██    ██ ████████  ████████  ██████
   ██     ██  ██  ██     ██ ██       ██    ██
   ██      ████   ██     ██ ██       ██
   ██       ██    ████████  ██████    ██████
   ██       ██    ██        ██             ██
   ██       ██    ██        ██       ██    ██
   ██       ██    ██        ████████  ██████
-->

<h3 id='media-types'>
Media Types</h3>

	A <dfn export>media type</dfn> is a broad category of user-agent devices
	on which a document may be displayed.
	The original set of <a>media types</a> were defined in HTML4,
	for the <code>media</code> attribute on <code>&lt;link></code> elements.

	Unfortunately, <a>media types</a> have proven insufficient as a way of discriminating between devices with different styling needs.
	Some categories which were originally quite distinct,
	such as ''screen'' and ''handheld'',
	have blended significantly in the years since their invention.
	Others, such as ''tty'' or ''tv'',
	expose useful differences from the norm of a full-featured computer monitor,
	and so are potentially useful to target with different styling,
	but the definition of <a>media types</a> as mutually exclusive
	makes it difficult to use them in a reasonable manner;
	instead, their exclusive aspects are better expressed as <a>media features</a>
	such as 'grid' or 'scan'.

	As such, the following <a>media types</a> are defined for use in <a>media queries</a>:

	<dl dfn-type=value dfn-for="@media">
		<dt><dfn>all</dfn>
		<dd>Matches all devices.

		<dt><dfn>print</dfn>
		<dd>Matches printers, and devices intended to reproduce a printed display,
			such as a web browser showing a document in “Print Preview”.

		<dt><dfn>screen</dfn>
		<dd>Matches all devices that aren't matched by ''print'' or ''speech''.

		<dt><dfn>speech</dfn>
		<dd>Matches screenreaders and similar devices that “read out” a page.
	</dl>

	In addition, the following <strong>deprecated</strong> <a>media types</a> are defined.
	Authors must not use these <a>media types</a>;
	instead, it is recommended that they select appropriate <a>media features</a>
	that better represent the aspect of the device that they are attempting to style against.

	User agents must recognize the following <a>media types</a> as valid,
	but must make them match nothing.

	<ul dfn-type=value dfn-for="@media">
		<li><dfn>tty</dfn>
		<li><dfn>tv</dfn>
		<li><dfn>projection</dfn>
		<li><dfn>handheld</dfn>
		<li><dfn>braille</dfn>
		<li><dfn>embossed</dfn>
		<li><dfn>aural</dfn>
	</ul>

	Note: It is expected that all of the media types will also be deprecated in time,
	as appropriate <a>media features</a> are defined which capture their important differences.

<!--
████████ ████████    ███    ████████ ██     ██ ████████  ████████  ██████
██       ██         ██ ██      ██    ██     ██ ██     ██ ██       ██    ██
██       ██        ██   ██     ██    ██     ██ ██     ██ ██       ██
██████   ██████   ██     ██    ██    ██     ██ ████████  ██████    ██████
██       ██       █████████    ██    ██     ██ ██   ██   ██             ██
██       ██       ██     ██    ██    ██     ██ ██    ██  ██       ██    ██
██       ████████ ██     ██    ██     ███████  ██     ██ ████████  ██████
-->

<h3 id='mq-features'>
Media Features</h3>

	A <dfn export>media feature</dfn> is a more fine-grained test than <a>media types</a>,
	testing a single, specific feature of the user agent or display device.

	Syntactically, <a>media features</a> resemble CSS properties:
	they consist of a feature name, a colon, and a value to test for.
	They may also be written in boolean form as just a feature name,
	or in range form with a comparison operator.

	<pre class='railroad'>
	T: (
	Choice:
		And:
			N: feature name
			T: :
			N: feature value
		N: feature name
		And:
			N: range form
			C: (see below)
	T: )
	</pre>

	There are, however, several important differences between properties and media features:

	<ul>
		<li>
			Properties are used to give information about how to present a document.
			Media features are used to describe requirements of the output device.

		<li>
			Media features are always wrapped in parentheses
			and combined with the ''and'' keyword,
			like ''(color) and (min-width: 600px)'',
			rather than being separated with semicolons.

		<li>
			A media feature may be given with <em>only</em> its name
			(omitting the colon and value)
			to evaluate the feature in a <a>boolean context</a>.
			This is a convenient shorthand for features that have a reasonable value representing 0 or “none”.
			For example, ''(color)'' is true is the 'color' <a>media feature</a> is non-zero.

		<li>
			<a>Media features</a> with “range” type can be written in a <a>range context</a>,
			which uses standard mathematical comparison operators rather than a colon,
			or have their feature names <a href=#mq-min-max>prefixed with “min-” or “max-”</a>.

		<li>
			Properties sometimes accept complex values,
			e.g., calculations that involve several other values.
			<a>Media features</a> only accept single values: one keyword, one number, etc.
	</ul>

	If a <a>media feature</a> references a concept which does not exist on the device where the UA is running
	(for example, speech UAs do not have a concept of “width”),
	the <a>media feature</a> must always evaluate to false.

	<div class="example">
		The media feature ''device-aspect-ratio'' only applies to
		visual devices. On an ''speech'' device, expressions involving
		''device-aspect-ratio'' will therefore always be false:

		<pre>
			&lt;link media="speech and (device-aspect-ratio: 16/9)"
			      rel="stylesheet" href="example.css">
		</pre>
	</div>

<h4 id='mq-ranges'>
Media Feature Types: “range” and “discrete”</h4>

	Every media feature defines its “type” as either “range” or “discrete” in its definition table.

	“Discrete” media features,
	like 'pointer' or 'scripting',
	take their values from a set.
	The values may be keywords
	or boolean numbers (0 and 1),
	but the common factor is that there's no intrinsic “order” to them--
	none of the values are “less than” or “greater than” each other.

	“Range” media features like 'width', on the other hand,
	take their values from a range.
	Any two values can be compared to see which is lesser and which is greater.

	The only significant difference between the two types is that “range” <a>media features</a>
	can be evaluated in a <a>range context</a>
	and accept “min-” and “max-” prefixes on their name.
	Doing either of these changes the meaning of the feature--
	rather than the <a>media feature</a> being true when the feature exactly matches the given value,
	it matches when the feature is greater than/less than/equal to the given value.

	<div class='example'>
		A ''(width >= 600px)'' <a>media feature</a> is true
		when the viewport's width is ''600px'' <em>or more</em>.

		On the other hand, ''(width: 600px)'' by itself is only true
		when the viewport's width is <em>exactly</em> ''600px''.
		If it's less or greater than ''600px'', it'll be false.
	</div>

<!--
████████   ███████   ███████  ██       ████████    ███    ██    ██
██     ██ ██     ██ ██     ██ ██       ██         ██ ██   ███   ██
██     ██ ██     ██ ██     ██ ██       ██        ██   ██  ████  ██
████████  ██     ██ ██     ██ ██       ██████   ██     ██ ██ ██ ██
██     ██ ██     ██ ██     ██ ██       ██       █████████ ██  ████
██     ██ ██     ██ ██     ██ ██       ██       ██     ██ ██   ███
████████   ███████   ███████  ████████ ████████ ██     ██ ██    ██
-->

<h4 id='mq-boolean-context'>
Evaluating Media Features in a Boolean Context</h4>

	While <a>media features</a> normally have a syntax similar to CSS properties,
	they can also be written more simply as just the feature name,
	like ''(color)''.

	When written like this, the <a>media feature</a> is evaluated in a <dfn export>boolean context</dfn>.
	If the feature would be true for any value
	<em>other than</em> the number ''0'',
	a <<dimension>> with the value ''0'',
	or the keyword ''none'',
	the <a>media feature</a> evaluates to true.
	Otherwise, it evaluates to false.

	<div class='example'>
		Some <a>media features</a> are designed to be written like this.

		For example, 'scripting' is typically written as ''(scripting)'' to test if scripting is enabled,
		or ''not (scripting)'' to see if it's disabled.

		It can still be given an explicit value as well,
		with ''(scripting: enabled)'' equal to ''(scripting)'',
		and ''(scripting: none)'' equal to ''not (scripting)''.
	</div>

	<div class='example'>
		Some numeric <a>media features</a>, like 'width',
		are rarely if ever useful to evaluate in a <a>boolean context</a>,
		as their values are almost always greater than zero.
		Others, like 'color', have meaningful zero values:
		''(color)'' is identical to ''(color > 0)'',
		indicating that the device is capable of displaying color at all.
	</div>

	<div class='example'>
		Only some of the <a>media features</a> that accept keywords are meaningful in a <a>boolean context</a>.

		For example, ''(pointer)'' is useful,
		as 'pointer' has a ''pointer/none'' value to indicate there's no pointing device at all on the device.
		On the other hand, ''(scan)'' is just always true or always false
		(depending on whether it applies at all to the device),
		as there's no value that means “false”.
	</div>

<!--
████████     ███    ██    ██  ██████   ████████
██     ██   ██ ██   ███   ██ ██    ██  ██
██     ██  ██   ██  ████  ██ ██        ██
████████  ██     ██ ██ ██ ██ ██   ████ ██████
██   ██   █████████ ██  ████ ██    ██  ██
██    ██  ██     ██ ██   ███ ██    ██  ██
██     ██ ██     ██ ██    ██  ██████   ████████
-->

<h4 id="mq-range-context">
Evaluating Media Features in a Range Context</h4>


	<a>Media features</a> with a “range” type can be alternately written in a <dfn export>range context</dfn>
	that takes advantage of the fact that their values are ordered,
	using ordinary mathematical comparison operators:

	<pre class='railroad'>
	T: (
	Choice:
		Seq:
			N: feature name/value
			Choice: 4
				T: =
				T: <
				T: <=
				T: >
				T: >=
			N: feature value/name
		Seq:
			N: value
			Choice:
				T: <
				T: <=
			N: feature name
			Choice:
				T: <
				T: <=
			N: value
		Seq:
			N: value
			Choice:
				T: >
				T: >=
			N: feature name
			Choice:
				T: >
				T: >=
			N: value
	T: )
	</pre>

	Note: This syntax is new to Level 4 of Mediaqueries,
	and thus is not as widely supported at the moment
	as the ''min-''/''max-'' prefixes.

	The basic form,
	consisting of a feature name,
	a comparison operator,
	and a value,
	returns true if the relationship is true.

	<div class='example'>
		For example, ''(height > 600px)''
		(or ''(600px &lt; height)'')
		returns true if the viewport height is greater than ''600px''.
	</div>

	The remaining forms,
	with the feature name nested between two value comparisons,
	returns true if both comparisons are true.

	<div class='example'>
		For example, ''(400px &lt; width &lt; 1000px)'' returns true if the viewport width is between ''400px'' and ''1000px''
		(but not equal to either).
	</div>

<!--
██     ██ ████ ██    ██       ██ ██     ██    ███    ██     ██
███   ███  ██  ███   ██      ██  ███   ███   ██ ██    ██   ██
████ ████  ██  ████  ██     ██   ████ ████  ██   ██    ██ ██
██ ███ ██  ██  ██ ██ ██    ██    ██ ███ ██ ██     ██    ███
██     ██  ██  ██  ████   ██     ██     ██ █████████   ██ ██
██     ██  ██  ██   ███  ██      ██     ██ ██     ██  ██   ██
██     ██ ████ ██    ██ ██       ██     ██ ██     ██ ██     ██
-->

<h4 id='mq-min-max'>
Using “min-” and “max-” Prefixes On Range Features</h4>

	Rather than evaluating a “range” type <a>media feature</a> in a range context,
	as described above,
	the feature may be written as a normal <a>media feature</a>,
	but with a “min-” or “max-” prefix on the feature name.

	This is equivalent to evaluating the feature in a <a>range context</a>,
	as follows:

	<ul>
		<li>
			Using a “min-” prefix on a feature name is equivalent to using the “>=” operator.
			For example, ''(min-height: 600px)'' is equivalent to ''(height >= 600px)''.

		<li>
			Using a “max-” prefix on a feature name is equivalent to using the “<=” operator.
			For example, ''(max-width: 40em)'' is equivalent to ''(width <= 40em)''.
	</ul>

	“Discrete” type properties do not accept “min-” or “max-” prefixes.
	Adding such a prefix to a “discrete” type <a>media feature</a> simply results in an unknown feature name.

	<div class='example'>
		For example,
		''(min-grid: 1)'' is invalid,
		because 'grid' is a “discrete” <a>media feature</a>,
		and so doesn't accept the prefixes.
		(Even though the 'grid' <a>media feature</a> appears to be numeric,
		as it accepts the values ''0'' and ''1''.)
	</div>

	Attempting to evaluate a min/max prefixed <a>media feature</a> in a <a>boolean context</a>
	is invalid and a syntax error.


Combining Media Features {#media-conditions}
--------------------------------------------

	Multiple <a>media features</a> can be combined together into a <dfn export>media condition</dfn>
	using full boolean algebra
	(not, and, or).

	* Any media feature can be negated by placing ''not'' before it.
		For example, ''not (color)'' inverts the meaning of ''(color)''--
		since ''(color)'' matches a device with any kind of color display,
		''not (color)'' matches a device <em>without</em> any kind of color display.

	* Two or more media features can be chained together,
		such that the query is only true if <em>all</em> of the media features are true,
		by placing ''and'' between them.
		For example, ''(width < 600px) and (height < 600px)''
		only matches devices whose screens are smaller than ''600px'' wide in both dimensions.


	* Alternately, two or more media features can be chained together,
		such that the query is true if <em>any</em> of the media features are true,
		by plaing ''or'' between them.
		For example, ''(update: slow) or (hover: none)''
		matches if the device is slow to update the screen (such as an e-reader)
		<em>or</em> the device has no hover capability,
		perhaps indicating that one should use a layout that displays more information
		rather than compactly hiding it until the user hovers.

	* <a>Media conditions</a> can be grouped by wrapping them in parentheses ''()''
		which can then be nested within a condition the same as a single media query.
		For example, ''(not (color)) or (hover)''
		is true on devices that are monochrome
		and/or that have hover capabilities.
		If one instead wanted to query for a device that was monochrome and <em>didn't</em> have hover capabilities,
		it must instead be written as ''not ((color) or (hover))''
		(or, equivalently, as ''(not (color)) and (not (hover))'').

	It is <em>invalid</em> to mix ''and'' and ''or'' and ''not'' at the same “level” of a media query.
	For example, ''(color) and (pointer) or (hover)'' is illegal,
	as it's unclear what was meant.
	Instead, parentheses can be used to group things using a particular joining keyword,
	yielding either ''(color) and ((pointer) or (hover))''
	or ''((color) and (pointer)) or (hover)''.
	These two have very different meanings:
	if only ''(hover)'' is true,
	the first one evaluates to false
	but the second evaluates to true.

<!--
 ██████  ██    ██ ██    ██ ████████    ███    ██     ██
██    ██  ██  ██  ███   ██    ██      ██ ██    ██   ██
██         ████   ████  ██    ██     ██   ██    ██ ██
 ██████     ██    ██ ██ ██    ██    ██     ██    ███
      ██    ██    ██  ████    ██    █████████   ██ ██
██    ██    ██    ██   ███    ██    ██     ██  ██   ██
 ██████     ██    ██    ██    ██    ██     ██ ██     ██
-->

<h2 id='mq-syntax'>
Syntax</h2>

	Informal descriptions of the media query syntax appear in the prose and railroad diagrams in previous sections.
	The formal media query syntax is described in this section,
	with the rule/property grammar syntax defined in [[!CSS3SYN]] and [[!CSS3VAL]].

	To parse a <dfn>&lt;media-query-list></dfn> production,
	<a>parse a comma-separated list of component values</a>,
	then parse each entry in the returned list as a <<media-query>>.
	Its value is the list of <<media-query>>s so produced.

	Note: This explicit definition of <<media-query-list>> parsing
	is necessary to make the error-recovery behavior of <a>media query lists</a> well-defined.

	Note: This definition of <<media-query-list>> parsing intentionally accepts an empty list.

	<pre>
	<dfn>&lt;media-query></dfn> = <<media-condition>>
	             | [ not | only ]? <<media-type>> [ and <<media-condition-without-or>> ]?
	<dfn>&lt;media-type></dfn> = <<ident>>

	<dfn>&lt;media-condition></dfn> = <<media-not>> | <<media-in-parens>> [ <<media-and>>* | <<media-or>>* ]
	<dfn>&lt;media-condition-without-or></dfn> = <<media-not>> | <<media-in-parens>> <<media-and>>*
	<dfn>&lt;media-not></dfn> = not <<media-in-parens>>
	<dfn>&lt;media-and></dfn> = and <<media-in-parens>>
	<dfn>&lt;media-or></dfn> = or <<media-in-parens>>
	<dfn>&lt;media-in-parens></dfn> = ( <<media-condition>> ) | <<media-feature>> | <<general-enclosed>>

	<dfn>&lt;media-feature></dfn> = ( [ <<mf-plain>> | <<mf-boolean>> | <<mf-range>> ] )
	<dfn>&lt;mf-plain></dfn> = <<mf-name>> : <<mf-value>>
	<dfn>&lt;mf-boolean></dfn> = <<mf-name>>
	<dfn>&lt;mf-range></dfn> = <<mf-name>> [ '<' | '>' ]? '='? <<mf-value>>
	           | <<mf-value>> [ '<' | '>' ]? '='? <<mf-name>>
	           | <<mf-value>> '<' '='? <<mf-name>> '<' '='? <<mf-value>>
	           | <<mf-value>> '>' '='? <<mf-name>> '>' '='? <<mf-value>>
	<dfn>&lt;mf-name></dfn> = <<ident>>
	<dfn>&lt;mf-value></dfn> = <<number>> | <<dimension>> | <<ident>> | <<ratio>>

	<dfn>&lt;general-enclosed></dfn> = [ <<function-token>> <<any-value>> ) ] | ( <<ident>> <<any-value>> )
	</pre>

	The <<media-type>> production does not include the keywords ''only'', ''not'', ''and'', and ''or''.

	No whitespace is allowed between the “<” or “>” <<delim-token>>s and the following “=” <<delim-token>>,
	if it's present.

	Note: Whitespace is required between a ''not'', ''and'', or ''or'' keyword
	and the following ''('' character,
	because without it that would instead parse as a <<function-token>>.
	This is not made explicitly invalid because it's already covered by the above grammar.
	It's fine to have whitespace between a '')'' and a following keyword,
	however.

	When parsing the <<media-in-parens>> production,
	the <<general-enclosed>> branch must only be chosen if the input does not match either of the preceding branches.
	<span class='note'><<general-enclosed>> exists to allow for future expansion of the grammar in a reasonably compatible way.</span>

Evaluating Media Queries {#evaluating}
--------------------------------------

	Each of the major subexpression of <<media-condition>> or <<media-condition-without-or>> is associated with a boolean result, as follows:

	<dl>
		<dt><<media-condition>>
		<dt><<media-condition-without-or>>
		<dd>
			The result is the result of the child subexpression.

		<dt><<media-in-parens>>
		<dd>
			The result is the result of the child term.

		<dt><<media-not>>
		<dd>
			The result is the negation of the <<media-in-parens>> term.
			The negation of unknown is unknown.

		<dt><<media-in-parens>> <<media-and>>*
		<dd>
			The result is true if the <<media-in-parens>> child term
			and all of the <<media-in-parens>> children of the <<media-and>> child terms are true,
			false if at least one of these <<media-in-parens>> terms are false,
			and unknown otherwise.

		<dt><<media-in-parens>> <<media-or>>*
		<dd>
			The result is false if the <<media-in-parens>> child term
			and all of the <<media-in-parens>> children of the <<media-or>> child terms are false,
			true if at least one of these <<media-in-parens>> terms are true,
			and unknown otherwise.

		<dt><<general-enclosed>>
		<dd>
			The result is unknown.

			Authors must not use <<general-enclosed>> in their stylesheets.
			<span class='note'>It exists only for future-compatibility,
			so that new syntax additions do not invalidate too much of a <<media-condition>> in older user agents.</span>

		<dt><<media-feature>>
		<dd>
			The result is the result of evaluating the specified media feature.
	</dl>

	If the result of any of the above productions
	is used in any context that expects a two-valued boolean,
	“unknown” must be converted to “false”.

	Note: This means that,
	for example,
	when a <a>media query</a> is used in a ''@media'' rule,
	if it resolves to “unknown” it's treated as “false”
	and fails to match.

	<div class="note">
		Media Queries use a three-value logic where terms can be “true”, “false”, or “unknown”.
		Specifically, it uses the <a href="http://en.wikipedia.org/wiki/Three-valued_logic#Kleene_and_Priest_logics">Kleene 3-valued logic</a>.
		In this logic, “unknown” means “either true or false, but we're not sure which yet”.

		In general, an unknown value showing up in a formula will cause the formula to be unknown as well,
		as substituting “true” for the unknown will give the formula a different result than substituting “false”.
		The only way to eliminate an unknown value is to use it in a formula that will give the same result
		whether the unknown is replaced with a true or false value.
		This occurs when you have “false AND unknown” (evaluates to false regardless)
		and “true OR unknown” (evaluates to true regardless).

		This logic was adopted because <<general-enclosed>> needs to be assigned a truth value.
		In standard boolean logic, the only reasonable value is “false”,
		but this means that ''not unknown(function)'' is true,
		which can be confusing and unwanted.
		Kleen's 3-valued logic ensures that unknown things will prevent a <a>media query</a> from matching,
		unless their value is irrelevant to the final result.
	</div>


<h3 id="error-handling">
Error Handling</h3>

	A media query that does not match the grammar in the previous section must be replaced by ''not all'' during parsing.

	Note: Note that a grammar mismatch does <strong>not</strong> wipe out an entire <a>media query list</a>,
	just the problematic <a>media query</a>.
	The parsing behavior defined above automatically recovers at the next top-level comma.

	<div class='example'>
		<pre>
			@media (example, all,), speech { /* only applicable to speech devices */ }
			@media &test, speech           { /* only applicable to speech devices */ }
		</pre>

		Both of the above <a>media query lists</a> are turned into ''not all, speech'' during parsing,
		which has the same truth value as just ''speech''.

		Note that error-recovery only happens at the top-level of a <a>media query</a>;
		anything inside of an invalid parenthesized block
		will just get turned into ''not all'' as a group.
		For example:

		<pre>
			@media (example, speech { /* rules for speech devices */ }
		</pre>

		Because the parenthesized block is unclosed,
		it will contain the entire rest of the stylesheet from that point
		(unless it happens to encounter an unmatched “)” character somewhere in the stylesheet),
		and turn the entire thing into a ''not all'' <a>media query</a>.
	</div>

	An unknown <<media-type>> must be treated as not matching.

	<div class='example'>
		For example, the media query ''unknown'' is false,
		as ''unknown'' is an unknown <a>media type</a>.

		But ''not unknown'' is true, as the ''not'' negates the false media type.
	</div>

	<div class='example'>
		Remember that some keywords aren't allowed as <<media-type>>s
		and cause parsing to fail entirely:
		the media query ''or and (color)'' is turned into ''not all'' during parsing,
		rather than just treating the ''or'' as an unknown <a>media type</a>.
	</div>

	An unknown <<mf-name>> or <<mf-value>>, or disallowed <<mf-value>>,
	results in the value “unknown”.
	A <<media-query>> whose value is “unknown” must be replaced with ''not all''.

	<div class="example">
		<pre>&lt;link media="screen and (max-weight: 3kg) and (color), (color)"
		      rel="stylesheet" href="example.css" /&gt;</pre>

		As ''max-weight'' is an unknown <a>media feature</a>,
		this <a>media query list</a> is turned into ''not all, (color)'',
		which is equivalent to just ''(color)''.
	</div>

	<div class="example">
		<pre>@media (min-orientation:portrait) { … }</pre>

		The 'orientation' feature does not accept prefixes,
		so this is considered an unknown <a>media feature</a>,
		and turned into ''not all''.
	</div>

	<div class="example">
		The media query ''(color:20example)'' specifies an unknown value for the 'color' media feature
		and is therefore turned into ''not all''.
	</div>

	<div class="example">
		This media query is turned into ''not all'' because negative lengths are not allowed for the 'width' media feature:

		<pre>@media (min-width: -100px) { … }</pre>
	</div>

	<div class='note'>
		Note that <a>media queries</a> are also subject to the parsing rules of the host language.
		For example, take the following CSS snippet:

		<pre> @media test;,all { body { background:lime } }</pre>

		The media query ''test;,all'' is, parsed by itself,
		equivalent to ''not all, all'', which is always true.
		However, CSS's parsing rules cause the ''@media'' rule,
		and thus the <a>media query</a>,
		to end at the semicolon.
		The remainder of the text is treated as a style rule
		with an invalid selector and contents.
	</div>

<!--
████████  ████ ██     ██ ████████ ██    ██  ██████  ████  ███████  ██    ██  ██████
██     ██  ██  ███   ███ ██       ███   ██ ██    ██  ██  ██     ██ ███   ██ ██    ██
██     ██  ██  ████ ████ ██       ████  ██ ██        ██  ██     ██ ████  ██ ██
██     ██  ██  ██ ███ ██ ██████   ██ ██ ██  ██████   ██  ██     ██ ██ ██ ██  ██████
██     ██  ██  ██     ██ ██       ██  ████       ██  ██  ██     ██ ██  ████       ██
██     ██  ██  ██     ██ ██       ██   ███ ██    ██  ██  ██     ██ ██   ███ ██    ██
████████  ████ ██     ██ ████████ ██    ██  ██████  ████  ███████  ██    ██  ██████
-->

<h2 id="mf-dimensions">
Viewport/Page Dimensions Media Features</h2>

<h3 id="width">
Width: the 'width' feature</h3>

	<pre class='descdef mq'>
	Name: width
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The '@media/width' media feature describes the width of the targeted display area of the output device.
	For continuous media, this is the width of the viewport
	(as described by CSS2, section 9.1.1 [[!CSS21]])
	including the size of a rendered scroll bar (if any).
	For paged media, this is the width of the page box
	(as described by CSS2, section 13.2 [[!CSS21]]).

	<<length>>s are interpreted according to [[#units]].

	Negative <<length>>s are invalid.

	<div class="example">
		For example, this media query expresses that the style sheet is used on printed output wider than 25cm:

		<pre>&lt;link rel="stylesheet" media="print and (min-width: 25cm)" href="http://…" /></pre>
	</div>

	<div class="example">
		This media query expresses that the style sheet is used on devices with viewport
		(the part of the screen/paper where the document is rendered)
		widths between 400 and 700 pixels:

		<pre>@media (400px <= min-width <= 700px) { … }</pre>
	</div>

	<div class="example">
		This media query expresses that style sheet is used if the width of the viewport is greater than 20em.

		<pre>@media (min-width: 20em) { … }</pre>

		The ''em'' value is relative to the <a>initial value</a> of 'font-size'.
	</div>


<h3 id="height">
Height: the 'height' feature</h3>

	<pre class='descdef mq'>
	Name: height
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The 'height' media feature describes the height of the targeted display area of the output device.
	For continuous media, this is the height of the viewport including the size of a rendered scroll bar (if any).
	For paged media, this is the height of the page box.

	<<length>>s are interpreted according to [[#units]].

	Negative <<length>>s are invalid.

<h3 id='aspect-ratio'>
Aspect-Ratio: the 'aspect-ratio' feature</h3>

	<pre class='descdef mq'>
	Name: aspect-ratio
	Value: <<ratio>>
	For: @media
	Type: range
	</pre>

	The 'aspect-ratio' media feature is defined as the ratio of the value of the 'width' media feature
	to the value of the 'height' media feature.

	The <dfn type>&lt;ratio></dfn> value type is a positive (not zero or negative)
	<<integer>> followed by optional whitespace, followed by a solidus ('/'),
	followed by optional whitespace, followed by a positive <<integer>>.
	<<ratio>>s can be ordered or compared by transforming them into the number
	obtained by dividing their first <<integer>> by their second <<integer>>.


<h3 id='orientation'>
Orientation: the 'orientation' feature</h3>

	<pre class='descdef mq'>
	Name: orientation
	Value: portrait | landscape
	For: @media
	Type: discrete
	</pre>

	<dl dfn-type=value dfn-for="@media/orientation">
		<dt><dfn>portrait</dfn>
		<dd>The 'orientation' media feature is ''portrait''
		when the value of the 'height' media feature is greater than or equal to
		the value of the 'width' media feature.
		<dt><dfn>landscape</dfn>
		<dd>Otherwise 'orientation' is ''landscape''.
	</dl>

	<div class="example">
		The following media query tests for “portrait” orientation,
		like a phone held upright.

		<pre>@media (orientation:portrait) { … }</pre>
	</div>

<!--
████████  ████  ██████  ████████         ███████  ██     ██    ███    ██       ████ ████████ ██    ██
██     ██  ██  ██    ██ ██     ██       ██     ██ ██     ██   ██ ██   ██        ██     ██     ██  ██
██     ██  ██  ██       ██     ██       ██     ██ ██     ██  ██   ██  ██        ██     ██      ████
██     ██  ██   ██████  ████████        ██     ██ ██     ██ ██     ██ ██        ██     ██       ██
██     ██  ██        ██ ██              ██  ██ ██ ██     ██ █████████ ██        ██     ██       ██
██     ██  ██  ██    ██ ██              ██    ██  ██     ██ ██     ██ ██        ██     ██       ██
████████  ████  ██████  ██               █████ ██  ███████  ██     ██ ████████ ████    ██       ██
-->

<h2 id='mf-display-quality'>
Display Quality Media Features</h2>

<h3 id="resolution">
Display Resolution: the 'resolution' feature</h3>

	<pre class='descdef mq'>
	Name: resolution
	Value: <<resolution>> | infinite
	For: @media
	Type: range
	</pre>

	The 'resolution' media feature describes the resolution of the output
	device, i.e. the density of the pixels, taking into account the <a spec=cssom-view>page zoom</a>
	but assuming a <a spec=cssom-view>pinch zoom</a> of 1.0.

	When querying media with non-square pixels, 'resolution' queries the density in the vertical dimension.

	For printers, this corresponds to the screening resolution
	(the resolution for printing dots of arbitrary color).
	Printers might have a different resolution for grayscale printing.

	For output mediums that have no physical constraints on resolution
	(such as outputting to vector graphics),
	this feature must match the ''infinite'' value.
	For the purpose of evaluating this media feature in the <a>range context</a>,
	''infinite'' must be treated as larger than any possible <<resolution>>.
	(That is, a query like ''(resolution > 1000dpi)'' will be true for an ''infinite'' media.)

	<div class='example'>
		This media query simply detects “high-resolution” screens
		(those with a hardware pixel to CSS ''px'' ratio of at least 2):

		<pre>@media (resolution >= 2dppx)</pre>
	</div>

	<div class="example">
		For example, this media query expresses that a style sheet is used on devices with resolution greater than 300 dots per CSS ''in'':

		<pre>@media print and (min-resolution: 300dpi) { … }</pre>

		This media query is equivalent, but uses the CSS ''cm'' unit:

		<pre>@media print and (min-resolution: 118dpcm) { … }</pre>
	</div>

	<div class="note">
		<<resolution>> does not refer to the number of device pixels per physical length unit,
		but the number of device pixels per css unit.
		This mapping is done by the user agent,
		so it is always known to the user agent.

		If the user agent either has no knowledge of the geometry of physical pixels,
		or knows about the geometry physical pixels and they are (close enough to)
		square, it would not map a different number of device pixels per css pixels
		along each axis, and the would therefore be no difference between the vertical
		and horizontal resolution.

		Otherwise, if the UA choses to map a different number along each axis,
		this would be to respond to physical pixels not being square either. How
		the UA comes to this knowledge is out of scope, but having enough information
		to take this decision, it can invert the mapping should the device be rotated 90 degrees.
	</div>


<h3 id="scan">
Display Type: the 'scan' feature</h3>

	<pre class='descdef mq'>
	Name: scan
	Value: interlace | progressive
	For: @media
	Type: discrete
	</pre>

	The 'scan' media feature describes the scanning process of some output devices.

	<dl dfn-type=value dfn-for="@media/scan">
		<dt><dfn>interlace</dfn>
		<dd>
			CRT and some types of plasma TV screens used “interlaced” rendering,
			where video frames alternated between specifying only the “even” lines on the screen
			and only the “odd” lines,
			exploiting various automatic mental image-correction abilities to produce smooth motion.
			This allowed them to simulate a higher FPS broadcast at half the bandwidth cost.

			When displaying on interlaced screens,
			authors should avoid very fast movement across the screen to avoid “combing”,
			and should ensure that details on the screen are wider than ''1px'' to avoid <a href="https://en.wikipedia.org/wiki/Interlaced_video#Interline_twitter">“twitter”</a>.

		<dt><dfn>progressive</dfn>
		<dd>
			A screen using “progressive” rendering displays each screen fully,
			and needs no special treatment.

			Most modern screens, and all computer screens, use progressive rendering.
	</dl>

	<div class="example">
		For example, the “feet” of letters in serif fonts are very small features that can provoke “twitter” on interlaced devices.
		The '@media/scan' media feature can be used to detect this,
		and use an alternative font with less chance of “twitter”:

		<pre>@media (scan: interlace) { body { font-family: sans-serif; } }</pre>
	</div>

<h3 id="grid">
Detecting Console Displays: the 'grid' feature</h3>

	<pre class='descdef mq'>
	Name: grid
	Value: <<mq-boolean>>
	For: @media
	Type: discrete
	</pre>

	The 'grid' media feature is used to query whether the output device is grid or bitmap.
	If the output device is grid-based
	(e.g., a “tty” terminal, or a phone display with only one fixed font),
	the value will be 1.
	Otherwise, the value will be 0.

	The <dfn type>&lt;mq-boolean></dfn> value type is an <<integer>>
	with the value ''0'' or ''1''.
	Any other integer value is invalid.
	<span class='note'>Note that ''-0'' is always equivalent to ''0'' in CSS,
	and so is also accepted as a valid <<mq-boolean>> value.</span>

	Note: The <<mq-boolean>> type exists only for legacy purposes.
	If this feature were being designed today,
	it would instead use proper named keywords for its values.

	<div class="example">
		Here is an example that detects a narrow console screen:

		<pre>
		@media (grid) and (max-width: 15em) { … }
		</pre>
	</div>


<h3 id="update">
Display Update Frequency: the 'update' feature</h3>

	<pre class='descdef mq'>
	Name: update
	Value: none | slow | fast
	For: @media
	Type: discrete
	</pre>

	The 'update' media feature is used to query the ability of the output device
	to modify the apearance of content once it has been rendered.
	It accepts the following values:

	<dl dfn-type=value dfn-for="@media/update">
		<dt><dfn>none</dfn>
		<dd>
			Once it has been rendered, the layout can no longer be updated.
			Example: documents printed on paper.

		<dt><dfn>slow</dfn>
		<dd>
			The layout may change dynamically according to the usual rules of CSS,
			but the output device is not able to render or display changes quickly enough
			for them to be percieved as a smooth animation.
			Example: E-ink screens or severely under-powered devices.

		<dt><dfn>fast</dfn>
		<dd>
			The layout may change dynamically according to the usual rules of CSS,
			and the output device is not unusually constrained in speed,
			so regularly-updating things like CSS Animations can be used.
			Example: computer screens.
	</dl>

	<div class='example'>
		For example, if a page styles its links to only add underlines on hover,
		it may want to always display underlines when printed:

		<pre>
		@media (update) {
			a { text-decoration: none; }
			a:hover, a:focus { text-decoration: underline; }
		}
		/* In non-updating UAs, the links get their default underline at all times. */
		</pre>
	</div>

<h3 id='mf-overflow-block'>
Block-Axis Overflow: the 'overflow-block' feature</h3>

	<pre class='descdef mq'>
	Name: overflow-block
	Value: none | scroll | optional-paged | paged
	For: @media
	Type: discrete
	</pre>

	The 'overflow-block' media feature describes the behavior of the device
	when content overflows the initial containing block in the <a>block axis</a>.

	<dl dfn-type=value dfn-for="@media/overflow-block">
		<dt><dfn>none</dfn>
		<dd>
			There is no affordance for overflow in the <a>block axis</a>;
			any overflowing content is simply not displayed.
			Examples: billboards

		<dt><dfn>scroll</dfn>
		<dd>
			Overflowing content in the <a>block axis</a> is exposed by allowing users to scroll to it.
			Examples: computer screens

		<dt><dfn>optional-paged</dfn>
		<dd>
			Overflowing content in the <a>block axis</a> is exposed by allowing users to scroll to it,
			but page breaks can be manually triggered
			(such as via 'break-inside'/etc)
			to cause the following content to display on the following page.
			Examples: slideshows

		<dt><dfn>paged</dfn>
		<dd>
			Content is broken up into discrete pages;
			content that overflows one page in the <a>block axis</a>
			is displayed on the following page.
			Examples: printers, ebook readers
	</dl>

<h3 id='mf-overflow-inline'>
Inline-Axis Overflow: the 'overflow-inline' feature</h3>

	<pre class="descdef mq">
	Name: overflow-inline
	Value: none | scroll
	For: @media
	Type: discrete
	</pre>

	The 'overflow-inline' media feature describes the behavior of the device
	when content overflows the initial containing block in the <a>inline axis</a>.

	<dl dfn-type=value dfn-for="@media/overflow-inline">
		<dt><dfn>none</dfn>
		<dd>
			There is no affordance for overflow in the <a>inline axis</a>;
			any overflowing content is simply not displayed.

		<dt><dfn>scroll</dfn>
		<dd>
			Overflowing content in the <a>inline axis</a> is exposed by allowing users to scroll to it.
	</dl>

	Note: There are no known implementations of paged overflow of inline-overflowing content,
	and the very concept doesn't seem to make much sense,
	so there is intentionally no ''paged'' value for '@media/overflow-inline'.


<!--
 ██████   ███████  ██        ███████  ████████
██    ██ ██     ██ ██       ██     ██ ██     ██
██       ██     ██ ██       ██     ██ ██     ██
██       ██     ██ ██       ██     ██ ████████
██       ██     ██ ██       ██     ██ ██   ██
██    ██ ██     ██ ██       ██     ██ ██    ██
 ██████   ███████  ████████  ███████  ██     ██
-->

<h2 id='mf-colors'>
Color Media Features</h2>


<h3 id="color">
Color Depth: the 'color' feature</h3>

	<pre class='descdef mq'>
	Name: color
	Value: <<integer>>
	For: @media
	Type: range
	</pre>

	The 'color' media feature describes the number of bits per color component of the output device.
	If the device is not a color device, the value is zero.

	Negative <<integer>>s are invalid.

	<div class="example">
		For example, these two media queries express that a style sheet applies to all color devices:

		<pre>
		@media (color) { … }
		@media (min-color: 1) { … }
		</pre>
	</div>

	<div class="example">
		This media query expresses that a style sheet applies to color devices
		with at least 8 bits per color component:

		<pre>@media (color >= 8) { … }</pre>
	</div>

	If different color components are represented by different number of bits,
	the smallest number is used.

	<div class="example">
		For instance, if an 8-bit color system
		represents the red component with 3 bits, the green component with 3 bits, and the blue component with 2 bits,
		the '@media/color' media feature will have a value of 2.
	</div>

	In a device with indexed colors,
	the minimum number of bits per color component in the lookup table is used.

	Note: The described functionality is only able to describe color capabilities at a superficial level.
	If further functionality is required,
	RFC2531 [[RFC2531]] provides more specific media features which may be supported at a later stage.


<h3 id="color-index">
Paletted Color Screens: the 'color-index' feature</h3>

	<pre class='descdef mq'>
	Name: color-index
	Value: <<integer>>
	For: @media
	Type: range
	</pre>

	The 'color-index' media feature describes the number of entries in the color lookup table of the output device.
	If the device does not use a color lookup table, the value is zero.

	Negative <<integer>>s are invalid.

	<div class="example">
		For example, here are two ways to express that a style sheet applies to all color index devices:

		<pre>
		@media (color-index) { … }
		@media (color-index >= 1) { … }
		</pre>
	</div>


	<div class="example">
		This media query expresses that a style sheet applies to a color index device with 256 or more entries:

		<pre>
		&lt;?xml-stylesheet media="(min-color-index: 256)"
			href="http://www.example.com/…" ?>
		</pre>
	</div>

<h3 id="monochrome">
Monochrome Screens: the 'monochrome' feature</h3>

	<pre class='descdef mq'>
	Name: monochrome
	Value: <<integer>>
	For: @media
	Type: range
	</pre>

	The 'monochrome' media feature describes the number of bits per pixel in a monochrome frame buffer.
	If the device is not a monochrome device,
	the output device value will be 0.

	Negative <<integer>>s are invalid.

	<div class="example">
		For example, this is how to express that a style sheet applies to all monochrome devices:

		<pre>@media (monochrome) { … }</pre>
	</div>

	<div class="example">
		Express that a style sheet applies to monochrome devices with more than 2 bits per pixels:

		<pre>@media (monochrome >= 2) { … }</pre>
	</div>


	<div class="example">
		Express that there is one style sheet for color pages and another for monochrome:

		<pre>
		&lt;link rel="stylesheet" media="print and (color)" href="http://…" />
		&lt;link rel="stylesheet" media="print and (monochrome)" href="http://…" />
		</pre>
	</div>

<h3 id="color-gamut">
Color Display Quality: the 'color-gamut' feature</h3>

	<pre class='descdef mq'>
	Name: color-gamut
	Value: srgb | p3 | rec2020
	For: @media
	Type: discrete
	</pre>

	The 'color-gamut' media feature describes the approximate range of colors
	that are supported by the UA and output device.
	That is, if the UA receives content with colors in the specified space
	it can cause the output device to render the appropriate color,
	or something appropriately close enough.

	Note: The query uses approximate ranges for a few reasons.
	Firstly, there are a lot of differences in display hardware.
	For example, a device might claim to support "Rec. 2020",
	but actually renders a significantly lower range of the full gamut.
	Secondly, there are a lot of different color ranges that different devices support,
	and enumerating them all would be tedious.
	In most cases the author does not need to know the exact capabilities of the display,
	just whether it is better than sRGB,
	or significantly better than sRGB.
	That way they can serve appropriate images,
	tagged with color profiles,
	to the user.

	<dl dfn-type=value dfn-for="@media/color-gamut">
		<dt><dfn>srgb</dfn>
		<dd>
			The output device can support approximately the sRGB gamut [[!SRGB]] or more.

			Note: It is expected that the vast majority of color displays
			will be able to return true to a query of this type.

		<dt><dfn>p3</dfn>
		<dd>
			The output device can support approximately the gamut
			specified by the DCI P3 Color Space or more.

			Note: The ''p3'' gamut is larger than and includes the ''srgb'' gamut.

			Issue: Add ref for DCI P3.

		<dt><dfn>rec2020</dfn>
		<dd>
			The output device can support approximately the gamut
			specified by the ITU-R Recommendation BT.2020 Color Space or more.

			Note: The ''rec2020'' gamut is larger than and includes the ''p3'' gamut.

			Issue: Add ref for BT.2020.
	</dl>

	<div class="example">
		For example, this media query applies when the display supports colors
		in the range of DCI P3:

		<pre class="lang-css">
		@media (color-gamut: p3) { … }
		</pre>
	</div>

	Note: An output device can return true for multiple values of this media feature,
	if its full output gamut is large enough,
	or one gamut is a subset of another supported gamut.
	As a result,
	this feature is best used in an "ascending" fashion--
	set a base value when ''(color-gamut: srgb)'' is true,
	then override it if ''(color-gamut: p3)'' is true, etc.

	Note: Some output devices,
	such as monochrome displays,
	cannot support even the ''srgb'' gamut.
	To test for these devices,
	you can use this feature in a negated boolean-context fashion:
	''not (color-gamut)''.

	Issue: Or should we add a value specifically for the "less than sRGB" case,
	like <css>narrow</css>?
	It would have to work differently than the others,
	and only match if the gamut was extra-low.



<!--
████ ██    ██ ████████ ████████ ████████     ███     ██████  ████████ ████  ███████  ██    ██
 ██  ███   ██    ██    ██       ██     ██   ██ ██   ██    ██    ██     ██  ██     ██ ███   ██
 ██  ████  ██    ██    ██       ██     ██  ██   ██  ██          ██     ██  ██     ██ ████  ██
 ██  ██ ██ ██    ██    ██████   ████████  ██     ██ ██          ██     ██  ██     ██ ██ ██ ██
 ██  ██  ████    ██    ██       ██   ██   █████████ ██          ██     ██  ██     ██ ██  ████
 ██  ██   ███    ██    ██       ██    ██  ██     ██ ██    ██    ██     ██  ██     ██ ██   ███
████ ██    ██    ██    ████████ ██     ██ ██     ██  ██████     ██    ████  ███████  ██    ██
-->

<h2 id='mf-interaction'>
Interaction Media Features</h2>

	The “interaction” media features reflect various aspects of how the user interacts with the page.

	<div class='note'>
		Typical examples of devices matching combinations of 'pointer' and 'hover':

		<table class=data>
			<thead>
				<tr>
					<td>
					<th>''pointer: none''
					<th>''pointer: coarse''
					<th>''pointer: fine''
			<tbody>
				<tr>
					<th scope=row>''hover: none''
					<td>keyboard-only controls, sequential/spatial (d-pad) focus navigation
					<td>smartphones, touch screens
					<td>basic stylus digitizers (Cintiq, Wacom, etc)
				<tr>
					<th scope=row>''hover: hover''
					<td>
					<td>Nintendo Wii controller, Kinect
					<td>mouse, touch pad, advanced stylus digitizers (Surface, Samsung Note, Wacom Intuos Pro, etc)
		</table>
		<style>
			#pointer-hover-table { margin: 1em auto; text-align: center; border-collapse: collapse; max-width: 40em; }
			#pointer-hover-table td, #pointer-hover-table th { padding: .5em; }
			#pointer-hover-table thead tr+tr th { border-bottom: 1px solid silver; }
			#pointer-hover-table tbody td:first-of-type { border-left: 1px solid silver; }
		</style>
	</div>

	The 'pointer' and 'hover' features relate to the characteristics of the “primary” input mechanism, 
	while 'any-pointer' and 'any-hover' can be used to query the properties of all potentially available input mechanisms.

	Note: While this specification does not define how User Agents should decide what the “primary” input is, 
	the expectation is that User Agents should make this determination 
	by combining knowledge about the device/environment they are running on, 
	the number and type of input mechanisms available, 
	and a notion of which of these inputs is generally and/or currently being used. 
	User Agents may also decide to dynamically change what type of input is deemed to be primary, 
	in response to changes in the user environment 
	or in the way the user is interacting with the UA.

<h3 id="pointer">
Pointing Device Quality: the 'pointer' feature</h3>

	<pre class='descdef mq'>
	Name: pointer
	Value: none | coarse | fine
	For: @media
	Type: discrete
	</pre>

	The 'pointer' media feature is used to query the presence and accuracy of a pointing device such as a mouse.
	If a device has multiple input mechanisms,
	the 'pointer' media feature must reflect the characteristics of the “primary” input mechanism,
	as determined by the user agent.
	(To query the capabilities of <em>any</em> available input mechanism,
		see the 'any-pointer' media feature.)

	<dl dfn-type=value dfn-for="@media/pointer">
		<dt><dfn>none</dfn>
		<dd>The primary input mechanism of the device does not include a pointing device.

		<dt><dfn>coarse</dfn>
		<dd>The primary input mechanism of the device includes a pointing device of limited accuracy.
			Examples include touchscreens and motion-detection sensors (like the Kinect peripheral for the Xbox.)

		<dt><dfn>fine</dfn>
		<dd>The primary input mechanism of the device includes an accurate pointing device.
			Examples include mice, touchpads, and drawing styluses.
	</dl>

	Both ''coarse'' and ''fine'' indicate the presence of a pointing device,
	but differ in accuracy.
	A pointing device with which it would be difficult or impossible
	to reliably pick one of several small adjacent targets at a zoom factor of 1
	would qualify as ''coarse''.
	Changing the zoom level does not affect the value of this media feature.

	Note: As the UA may provide the user with the ability to zoom,
	or as secondary pointing devices may have a different accuracy,
	the user may be able to perform accurate clicks even if the value of this media feature is ''coarse''.
	This media feature does not indicate that the user will never be able to click accurately,
	only that it is inconvenient for them to do so.
	Authors are expected to react to a value of ''coarse''
	by designing pages that do not rely on accurate clicking to be operated.

	For accessibility reasons,
	even on devices whose pointing device can be described as ''fine'',
	the UA may give a value of ''coarse'' or ''pointer/none'' to this media query,
	to indicate that the user has difficulties manipulating the pointing device accurately or at all.
	In addition, even if the primary input mechanism has ''fine'' pointing accuracy,
	there may be additional ''coarse'' input mechanisms available to the user. Authors may
	wish to query the 'any-pointer' media feature to take these other ''coarse'' potential
	input mechanisms into account.

	<div class="example">
		<pre>
		/* Make radio buttons and check boxes larger if we have an inaccurate pointing device */
		@media (pointer:coarse) {
			input[type="checkbox"], input[type="radio"] {
				min-width:30px;
				min-height:40px;
				background:transparent;
			}
		}
		</pre>
	</div>

<h3 id="hover">
Hover Capability: the 'hover' feature</h3>

	<pre class='descdef mq'>
	Name: hover
	Value: none | hover
	For: @media
	Type: discrete
	</pre>

	The 'hover' media feature is used to query the user's ability to hover over elements on the page.
	If a device has multiple input mechanisms,
	the 'hover' media feature must reflect the characteristics of the “primary” input mechanism,
	as determined by the user agent.
	(To query the capabilities of <em>any</em> available input mechanism,
		see the 'any-hover' media feature.)

	<dl dfn-type=value dfn-for="@media/hover">
		<dt><dfn>none</dfn>
		<dd>
			Indicates that the primary pointing system can't hover,
			or there is no pointing system.
			Examples include touchscreens and screens that use a drawing stylus.

			Pointing systems that can hover,
			but for which doing so is inconvenient and not part of the normal way they are used,
			also match this value.
			For example, a touchscreen where a long press is treated as hovering
			would match ''hover: none''.

		<dt><dfn>hover</dfn>
		<dd>
			Indicates that the primary pointing system can easily hover over parts of the page.
			Examples include mice and devices that physically point at the screen, like the Nintendo Wii controller.
	</dl>

	<div class='example'>
		For example, on a touch screen device that can also be controlled by an optional mouse,
		the 'hover' <a>media feature</a> should match ''hover/none'',
		as the primary interaction mode (touching the screen) can't hover.

		Authors should therefore be careful not to assume that the ':hover' pseudo class
		will never match on device where 'hover:none' is true,
		but they should design layouts that do not depend on hovering to be fully usable.
	</div>

	For accessibility reasons, even on devices that do support hovering,
	the UA may give a value of ''hover: none'' to this media query,
	to opt into layouts that work well without hovering.
	Note that even if the primary input mechanism has 'hover: hover' capability,
	there may be additional input mechanisms available to the user that do not provide hover capabilities.

	<div class="example">
		<pre>
		/* Only use a hover-activated drop down menu on devices that can conveniently hover. */
		@media (hover) {
			.menu > li        {display:inline-block;}
			.menu ul          {display:none; position:absolute;}
			.menu li:hover ul {display:block; list-style:none; padding:0;}
			/* ... */
		}
		</pre>
	</div>

<h3 id='any-input'>
All Available Interaction Capabilities: the 'any-pointer' and 'any-hover' features</h3>

	<pre class='descdef mq'>
	Name: any-pointer
	Value: none | coarse | fine
	For: @media
	Type: discrete
	</pre>

	<pre class='descdef mq'>
	Name: any-hover
	Value: none | hover
	For: @media
	Type: discrete
	</pre>

	The 'any-pointer' and 'any-hover' media features are identical to the 'pointer' and 'hover' media features,
	but they correspond to the union of capabilities of all the pointing devices available to the user.
	More than one of their values can match,
	if different pointing devices have different characteristics.
	They must only match ''none'' if <em>all</em> of the pointing devices would match ''none'' for the corresponding query,
	or there are no pointing devices at all.

	<div class="note">
	While 'pointer' and 'hover' can be used to design the main style and interaction
	mode of the page to suit the primary input mechanism, 'any-pointer' and 'any-hover'
	can be used to potentially take into account all possible types of pointers
	that have been detected.

	Designing a page that relies on hovering or accurate pointing
	only because 'any-hover' or 'any-pointer' indicate that at least one of the available
	input mechanisms has these capabilities	is likely to result in a poor experience.
	However, authors may use this information to inform their decision about the style and
	functionality they wish to provide based on additional input mechanisms that
	are available to the user.
	</div>

	<div class="example">
		A number of smart TVs come with a way to control an on-screen cursor,
		but it is often fairly basic controller which is difficult to operate accurately.

		A browser in such a smart TV would have ''coarse'' as the value of both 'pointer' and 'any-pointer',
		allowing authors to provide a layout with large and easy to reach click targets.

		The user may also have paired a Bluetooth mouse with the TV,
		and occasionally use it for extra convenience,
		but such the mouse is not the main way the TV is operated.
		'pointer' still matches ''coarse'', while 'any-pointer' now both matches ''coarse'' and ''fine''.

		Switching to small click targets based on the fact that ''(any-pointer: fine)'' is now true
		would not be appropriate.
		It would not only surprise the user
		by providing an experience out of line with what they expect on a TV,
		but may also be quite inconvenient:
		the mouse, not being the primary way to control the TV, may be out of reach,
		hidden under one of the cushions on the sofa...

		By contrast, consider scrolling on the same TV.
		Scrollbars are difficult to manipulate without an accurate pointing device.
		Having prepared an alternative way to indicate that there is more content to be seen
		based on ''(pointer: coarse)'' being true,
		an author may want to still show the scrollbars in addition if ''(any-pointer: fine)'' is true,
		or to hide them altogether to reduce visual clutter if ''(any-pointer: fine)'' is false.
	</div>

<!--
 ██████   ██████  ████████  ████ ████████  ████████ ████ ██    ██  ██████
██    ██ ██    ██ ██     ██  ██  ██     ██    ██     ██  ███   ██ ██    ██
██       ██       ██     ██  ██  ██     ██    ██     ██  ████  ██ ██
 ██████  ██       ████████   ██  ████████     ██     ██  ██ ██ ██ ██   ████
      ██ ██       ██   ██    ██  ██           ██     ██  ██  ████ ██    ██
██    ██ ██    ██ ██    ██   ██  ██           ██     ██  ██   ███ ██    ██
 ██████   ██████  ██     ██ ████ ██           ██    ████ ██    ██  ██████
-->

<h2 id='mf-scripting'>
Scripting Media Features</h2>

<h3 id="scripting">
Scripting Support: the 'scripting' feature</h3>

	<pre class='descdef mq'>
	Name: scripting
	Value: none | initial-only | enabled
	For: @media
	Type: discrete
	</pre>

	The 'scripting' media feature is used to query whether scripting languages,
	such as JavaScript,
	are supported on the current document.

	<dl dfn-type=value dfn-for="@media/scripting">
		<dt><dfn>enabled</dfn>
		<dd>
			Indicates that the user agent supports scripting of the page
			and that support is active for the current document.

		<dt><dfn>initial-only</dfn>
		<dd>
			Indicates that scripting is enabled during the initial page load,
			but is not supported afterwards.
			Examples are printed pages,
			or pre-rendering network proxies
			that render a page on a server
			and send a nearly-static version of the page to the user.

			Issue: Should there be an explicit minimum threshold to meet
			before a UA is allowed to claim ''initial-only''?
			Having one would mean authors would know
			what they can depend on,
			and could tailor their scripts accordingly.
			On the other hand, pinpointing that threshold is difficult:
			if it is set too low,
			the scripting facilities that authors can depend on
			may be to constrained to be practical,
			even though actual UAs may potentially
			all support significantly more.
			But trying to set it higher may cause us to exclude
			UAs that do support scripting at loading time,
			but restrict it in some cases based on complex heuristics.
			For instance, conservative definitions likely include at least
			running all inline scripts and firing the DOMContentLoaded event.
			But it does not seem useful for authors to constrain themselves to this
			if most (or maybe all) ''initial-only'' UAs
			also load external scripts (including ''async'' and ''defer'')
			and fire the load event.
			On the other hand,
			requiring external scripts to be loaded
			and the load event to be fired
			could exclude UAs like Opera mini,
			which typically do run them,
			but may decide not to based on timeouts and other heuristics.

		<dt><dfn>none</dfn>
		<dd>
			Indicates that the user agent will not run scripts for this document;
			either it doesn't support a scripting language,
			or the support isn't active for the current document.
	</dl>

	Some user agents have the ability to turn off scripting support on a per script basis or per domain basis,
	allowing some, but not all, scripts to run in a particular document.
	The 'scripting' media feature does not allow fine grained detection of which script is allowed to run.
	In this scenario, the value of the 'scripting' media feature should be ''scripting/enabled''
	if scripts originating on the same domain as the document are allowed to run,
	and ''scripting/none'' otherwise.

	Note: A future level of CSS may extend this media feature to allow fine-grained detection of which script is allowed to run.

<!--
████  ██████   ██████  ██     ██ ████████  ██████
 ██  ██    ██ ██    ██ ██     ██ ██       ██    ██
 ██  ██       ██       ██     ██ ██       ██
 ██   ██████   ██████  ██     ██ ██████    ██████
 ██        ██       ██ ██     ██ ██             ██
 ██  ██    ██ ██    ██ ██     ██ ██       ██    ██
████  ██████   ██████   ███████  ████████  ██████
-->

<!--
<h2 id='assorted-issues'>
Assorted Issues</h2>

	<div class='issue'>
		We need a media feature (or set of media features) to detect the type of keyboard available.
		It should be able to distinguish between full computer keyboards, phone dial pads, tv remotes, or virtual keyboards.
		As an attempt at an exhaustive list is likely to fail,
		finding atomic features to decompose these into would be preferable,
		but these remain to be identified.

		<ul>
			<li>always vs in text forms only
			<li>just numbers vs free alphanumeric input vs full ime support
			<li>work properly vs horrible lag like on a tv remove
		</ul>

		How much is actually useful for styling?
	</div>

	<div class='issue'>
		Example sets of MQs that would match on different types of devices

		<ul>
			<li>printer: update:none, pointer:none, hover:none, overflow-block: paged, overflow-inline: none
			<li>eink with stylus: update: slow, pointer:fine, hover:none, overflow-block: paged, overflow-inline: none
			<li>tv: update: fast, pointer: none, hover: none: overflow-block: none, overflow-inline: none
			<li>tablet: update: fast, pointer coarse, hover none, overflow-block: scroll, overflow-inline: scroll
			<li>wii: update: fast, pointer: coarse, hover: yes, overflow-block: scroll, overflow-inline: scroll
			<li>Chromebook pixel: update: fast, pointer: coarse *and* fine, hover: over, overflow-block: scroll, overflow-inline: scroll
			<li>Glass: update: fast, pointer: coarse, hover: none, overflow-block: none, overflow-inline: none
			<li>XTERM: update: fast, pointer:none, hover:none, grid:1, overflow-block: scroll, overflow-inline: none

		</ul>
	</div>

	<div class='issue'>
		<a href="http://lists.w3.org/Archives/Public/www-style/2013Mar/0448.html">http://lists.w3.org/Archives/Public/www-style/2013Mar/0448.html</a>

		MQ for detecting if the device is willing to display/print backgrounds and other ink-hungry properties.
	</div>

	<p class="issue">
		Another media feature should probably be added to deal with the type of resolution authors want to know to deal with monochrome printing.
-->

<!--
 ██████   ██████   ██████   ███████  ██     ██
██    ██ ██    ██ ██    ██ ██     ██ ███   ███
██       ██       ██       ██     ██ ████ ████
██        ██████   ██████  ██     ██ ██ ███ ██
██             ██       ██ ██     ██ ██     ██
██    ██ ██    ██ ██    ██ ██     ██ ██     ██
 ██████   ██████   ██████   ███████  ██     ██
-->
<!--
<h2 id='custom-mq-cssom'>
CSSOM</h2>

	The <a interface>CSSRule</a> interface is extended as follows:

	<pre class="idl partial">
	partial interface CSSRule {
		const unsigned short CUSTOM_MEDIA_RULE = 17;
	};
	</pre>

	The <a interface>CSSCustomMediaRule</a> interface represents a ''@custom-media'' rule.

	<pre class="idl">
	interface CSSCustomMediaRule : CSSRule {
		attribute DOMString name;
		[SameObject, PutForwards=mediaText] readonly attribute MediaList media;
	};
	</pre>

	<dl dfn-type=attribute dfn-for=CSSCustomMediaRule>
		<dt><dfn>name</dfn>, of type <code>DOMString</code>
		<dd>
			The <a attribute>name</a> attribute on getting must return a <code>DOMString</code> object
			that contains the serialization of the <<extension-name>> defined for the associated rule.

			On setting the <a attribute>name</a> attribute,
			run the following steps:

			<ol>
				<li><a>Parse a component value</a> from the value.

				<li>
					If the returned value is an <<extension-name>>,
					replace the associated rule's name with the <<extension-name>>'s representation.

				<li>
					Otherwise, do nothing.
			</ol>

		<dt><dfn>media</dfn>, of type <a interface>MediaList</a>, readonly
		<dd>
			The <a attribute>media</a> attribute must return a <a interface>MediaList</a> object
			for the <<media-query-list>> specified with the associated rule.
	</dl>
-->
<!--
████████  ████████ ████████  ████████  ████████  ██████     ███    ████████ ████████ ████████
██     ██ ██       ██     ██ ██     ██ ██       ██    ██   ██ ██      ██    ██       ██     ██
██     ██ ██       ██     ██ ██     ██ ██       ██        ██   ██     ██    ██       ██     ██
██     ██ ██████   ████████  ████████  ██████   ██       ██     ██    ██    ██████   ██     ██
██     ██ ██       ██        ██   ██   ██       ██       █████████    ██    ██       ██     ██
██     ██ ██       ██        ██    ██  ██       ██    ██ ██     ██    ██    ██       ██     ██
████████  ████████ ██        ██     ██ ████████  ██████  ██     ██    ██    ████████ ████████
-->

<h2 id='mf-deprecated'>
Appendix A: Deprecated Media Features</h2>

	<p>The following <a>media features</a> are <strong>deprecated</strong>. They
	kept for backward compatibility, but are not appropriate for newly
	written style sheets. Authors must not use them. User agents must support them
	as specified.

	<p class="note">To query for the size of the viewport (or the page box
	on page media), the 'width', 'height' and 'aspect-ratio' <a>media features</a>
	should be used, rather than 'device-width', 'device-height' and
	'device-aspect-ratio', which refer to the physical size of the the device
	regardless of how much space is available for the document being laid out. The
	device-* <a>media features</a> are also sometimes used as a proxy to detect
	mobile devices. Instead, authors should use <a>media features</a> that better
	represent the aspect of the device that they are attempting to style against.

<h3 id="device-width" class="no-toc no-num">
device-width</h3>

	<pre class='descdef mq'>
	Name: device-width
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The 'device-width' media feature describes the width of the rendering surface of the output device.
	For continuous media, this is the width of the <a>Web-exposed screen area</a>.
	For paged media, this is the width of the page sheet size.

	Negative <<length>>s are invalid.

	<div class="example">
		<pre>@media (device-width < 800px) { … }</pre>

		In the example above, the style sheet will apply only to screens
		less than ''800px'' in length.
		The ''px'' unit is of the logical kind,
		as described in the <a href="#units">Units</a> section.
	</div>

	Note: If a device can be used in multiple orientations,
	such as portrait and landscape,
	the 'device-*' media features reflect the current orientation.

<h3 id="device-height" class="no-toc no-num">
device-height</h3>

	<pre class='descdef mq'>
	Name: device-height
	Value: <<length>>
	For: @media
	Type: range
	</pre>

	The 'device-height' media feature describes the height of the rendering surface of the output device.
	For continuous media, this is the height of the <a>Web-exposed screen area</a>.
	For paged media, this is the height of the page sheet size.

	Negative <<length>>s are invalid.

	<div class="example">
		<pre>&lt;link rel="stylesheet" media="(device-height > 600px)" /&gt;</pre>

		In the example above, the style sheet will apply only to screens
		taller than 600 vertical pixels.
		Note that the definition of the ''px'' unit is the same as in other parts of CSS.
	</div>


<h3 id='device-aspect-ratio' class="no-toc no-num">
device-aspect-ratio</h3>

	<pre class='descdef mq'>
	Name: device-aspect-ratio
	Value: <<ratio>>
	For: @media
	Type: range
	</pre>

	The 'device-aspect-ratio media feature is defined as the ratio of
	the value of the 'device-width' media feature to
	the value of the 'device-height media feature.

	<div class="example">
		For example, if a screen device with square pixels
		has 1280 horizontal pixels and 720 vertical pixels
		(commonly referred to as “16:9”),
		the following media queries will all match the device:

		<pre>
		@media (device-aspect-ratio: 16/9) { … }
		@media (device-aspect-ratio: 32/18) { … }
		@media (device-aspect-ratio: 1280/720) { … }
		@media (device-aspect-ratio: 2560/1440) { … }
		</pre>
	</div>


<h2 id="changes" class="no-num">
Changes</h2>
<h3 id="changes-2012">
Changes Since the Media Queries Level 3</h3>

The following changes were made to this specification since the
<a href="https://www.w3.org/TR/css3-mediaqueries/">19 June 2012 Recomendation of Media Queries Level 3</a>:

<ul>
	<li>
		Large editorial rewrite and reorgization of the document.

	<li>
		<a href="#mq-boolean-context">Boolean-context</a> <a>media features</a> are now additionally false
		if they would be true for the keyword ''none''.

	<li>
		<a>Media features</a> with numeric values can now be written in a <a href="#mq-range-context">range context</a>.

	<li>
		The 'scripting', 'pointer', 'hover', 'update', 'overflow-block', and 'overflow-inline' media features were added.

	<li>
		''or'', ''and'', ''only'' and ''not'' are disallowed from being recognized as media types,
		even invalid ones.
		(They'll trigger a syntax error instead.)

	<li>
		White space is required around the keyword “and” as well as after “not” and “only”.

	<li>
		All media types except for ''screen'', ''print'', ''speech'', and ''all'' are deprecated.

	<li>
		Deprecated 'device-width', 'device-height', 'device-aspect-ratio',
		and made them refer to the <a>Web-exposed screen area</a> instead of the screen for privacy and security reasons.
</ul>


<h2 class="no-num" id="acknowledgments">
Acknowledgments</h2>

This specification is the product of the W3C Working Group on
Cascading Style Sheets.

Comments from
 Arve Bersvendsen,
 Björn Höhrmann,
 Chris Lilley,
 Christoph Päper,
 L. David Baron,
 Elika J. Etemad,
 François Remy,
 Melinda Grant,
 Nicholas C. Zakas
 Philipp Hoschka,
 Rick Byers,
 Rijk van Geijtenbeek,
 Roger Gimson,
 Sigurd Lerstad,
 Simon Kissane,
 Simon Pieters,
 Steven Pemberton,
 and Susan Lesch
improved this specification.

Privacy and Security Considerations {#priv-sec}
===============================================

This specification introduces no new security considerations.

Media Queries enable CSS to query various aspects of the page's environment,
including things that can be difficult or impossible to find via scripting.
This is potentially a privacy hazard,
allowing enhanced fingerprinting of a user,
but the risk is generally low.
At minimum, the same information should be <em>inferrable</em>
via scripting by examining the User Agent string.
However, UA string spoofing does not affect Media Queries,
making this a somewhat more robust detection technique.

That said, the information granted by Media Queries is relatively coarse,
and does not contribute much entropy in this regard.

A few legacy Media Features ('device-width', 'device-height', and 'device-aspect-ratio')
expose information about the environment in which the UA is running
without any clear benefit to doing so.
They are retained for compatibility reasons,
but for the sake of privacy and security,
UAs have been allowed to report inacurate information.
