<h1>CSS Basic User Interface Module Level 4</h1>

<pre class='metadata'>
ED: https://drafts.csswg.org/css-ui-4/
Status Text: This specification will include and extend <cite>CSS Basic User Interface Module Level&nbsp;3.</cite> [[CSS3-UI]]
TR: https://www.w3.org/TR/css-ui-4/
Previous Version: https://www.w3.org/TR/2015/WD-css-ui-4-20150922/
Shortname: css-ui
Level: 4
Group: csswg
!Issue Tracking: https://wiki.csswg.org/spec/css4-ui#css4-ui-issues-list
Status: ED
Work Status: Exploring
Editor: Florian Rivoal, On behalf of Bloomberg, florian@rivoal.net, http://florian.rivoal.net/
Ignored Terms: box-sizing, resize, text-overflow, caret-color, nav-up, nav-down, nav-left, nav-right
Link Defaults: css-position-3 (property) position
Link Defaults: css21 (property) float
Link Defaults: css21 (property) clear
Link Defaults: selectors-4 (selector) :checked
Link Defaults: selectors-4 (selector) :enabled
Link Defaults: selectors-4 (selector) :disabled
Abstract: This specification describes user interface related
          properties and values to style HTML and XML (including XHTML).
          It includes and extends user interface related features
          from the properties and values of previous CSS levels.
          It uses various properties and values
          to style basic user interface elements in a document.
At risk: Applicability of 'user-select' to ''::before'' and ''::after''
</pre>

<h2 id="intro">Introduction</h2>

This module describes CSS properties which enable authors
to style user interface related properties and values.

<a href="https://www.w3.org/TR/REC-CSS1#anchor-pseudo-classes">Section 2.1 of CSS1</a> [[CSS1]]
and <a href="https://www.w3.org/TR/CSS2/ui.html">Chapter 18 of CSS2</a> [[CSS21]]
introduced several user interface related properties and values.
<a href="https://www.w3.org/TR/2000/WD-css3-userint-20000216">User Interface for CSS3 (16 February 2000)</a> introduced several new user interface related features.

[[CSS3-UI]] was later introduced to incorporates, extends, and supersedes these.
This specification continues this work, and in turn replaces [[CSS3-UI]].

Note: At the time of writing, [[CSS3-UI]] is not completely finalized yet.
To avoid accidental divergences and maintenance overhead,
This specification is written as a delta specification over CSS-UI Level 3.
Once the level 3 specification is final,
its content will be integrated into this specification,
which will then replace it.
Until then, CSS-UI Level 4 only contains additions and extensions to level 3.

<h3 id="purpose">Purpose</h3>

The purpose of this specification is to achieve the following objectives:
<ul>
<li>Extend the user interface features in CSS2.1 and [[CSS3-UI]]
<li>Provide additional CSS mechanisms to augment or replace other
dynamic presentation related features in HTML.
<li>Introduce directional navigation properties to assist in the construction of
user interfaces which make use of a directional navigation model.
</ul>

<h2 id="interaction">Module Interactions</h2>

This document defines new features not present in earlier specifications.
In addition, it replaces and supersedes [[!CSS3-UI]],
which itself replaced and superseded the following:

<ul>
<li><a href="https://www.w3.org/TR/CSS21/ui.html#cursor-props">Section 18.1</a>,
<a href="https://www.w3.org/TR/CSS21/ui.html#dynamic-outlines">section 18.4</a>,
and Information on the stacking of outlines defined in
<a href="https://www.w3.org/TR/CSS21/zindex.html">Appendix E</a>
of Cascading Style Sheets, level 2, revision 1 [[CSS21]]
<li><a href="https://www.w3.org/TR/2000/WD-css3-userint-20000216">User Interface for CSS3 (16 February 2000)</a> [[CSSUI]]
</ul>

<h2 id="box-model">Box Model addition</h2>

<h3 id="box-sizing">'box-sizing' property</h3>

	Issue: Add final level 3 content

<h2 id="outline-props">Outline properties</h2>

	Issue: Add final level 3 content

<h3 id="outline">'outline' property</h3>

	Issue: Add final level 3 content

<h3 id="outline-width">'outline-width' property</h3>

	Issue: Add final level 3 content

<h3 id="outline-style">'outline-style' property</h3>

	Issue: Add final level 3 content

<h3 id="outline-color">'outline-color' property</h3>

	Issue: Add final level 3 content

<h2 id="resizing-and-overflow">Resizing &amp; Overflow</h2>

	Issue: Add final level 3 content

<h3 id="resize">'resize' property</h3>

	Issue: Add final level 3 content

In addition to elements
whose computed 'overflow' value
is something other than ''visible'',
the 'resize' property also applies
regardless of the value of the ''overflow'' property,
to:
<ul>
	<li>Replaced elements representing images or videos, such as <{img}>, <{video}>, <{picture}>, <{svg}>, <{object}>, or <{canvas}>.
	<li>The <{iframe}> element.
</ul>

<h3 id="text-overflow"> Overflow Ellipsis: the 'text-overflow' property</h3>

	Issue: Add final level 3 content

This specification introduces a new value to the 'text-overflow' property:
''text-overflow/fade'', as well as its functional notation variant ''fade()''.

<pre class='partial propdef'>
    Name: text-overflow
    New values: ''fade'' | <<fade()>>
    Computed value: As specified, with <<length>> converted to absolute units
    </pre>

<dl dfn-type=value dfn-for=text-overflow>
    <dt dfn-type=function><dfn>fade( <<length>> | <<percentage>> )</dfn></dt>
    <dd>Clip inline content that overflows its line box.
    Characters may be only partially rendered.
    In addition, the UA must apply a fade out effect
    near the edge of the line box,
    reaching complete transparency at the edge.

    Issue: Do we need to define the way
    the fade out is calculated
    so that the fading is identical across browsers?
    It should probably be something like
    ''mask-image: linear-gradient(to right, rgba(0,0,0,1), rgba(0,0,0,0))'',
    except applied to the relevant portion of the line only.
    
    The argument determines the distance
    over which the fade effect is applied.
    The <<percentage>> is resolved against the width of the line box.
    Values lower than 0 are clipped to 0.
    Values greater than the width of the line box are clipped to the width of the line box.

    Issue: If the line box is too short
    to display the fade effect at the desired length,
    should we drop the effect,
    or shrink the distance it is applied over until it fits,
    or clip the end of the fade?

    <dt><dfn>fade</dfn></dt>
    <dd>Same as ''fade()'',
    but the distance over which the fading effect is applied
    is determined by the UA.
    ''1em'' is suggested as a reasonable value.
</dl>

Issue: How should we deal with
things overflowing out of the line box,
or overlapping onto it?
Should fade apply to the logical content of the line,
or to the physical area of the line box,
or the intersection of both?

<div class="example">

	<style>
</style>
<table style="color:#000;background:#fff" id="awesome-table"><tbody>
<tr><th>HTML</th><th>sample rendering</th><th>your browser</th></tr>

<tr>
<td><pre><code class="lang-markup">&lt;div style="<strong>text-overflow:fade;</strong> overflow:hidden"&gt;
CSS IS AWESOME, YES
&lt;/div&gt;
</code></pre></td>

<td>
<object type="image/png" data="images/cssisfade.png">
a box with the text fading out on overflow.
</object></td>

<td>
<div style="width:3.1em; border:solid .1em black; padding:.2em; font-family:Helvetica,sans-serif; line-height:1.1; overflow:hidden;text-overflow:clip;">CSS IS AWESOME, YES</div>
</td>
</tr>
</table>

</div>
 



<h2 id="pointing-keyboard">Pointing Devices and Keyboards</h2>

<h3 id="pointer-interaction">Pointer interaction</h3>

<h4 id="cursor">'cursor' property</h4>

	Issue: Add final level 3 content

	Issue: Amend the definition of ''cursor/auto''
	to show ''cursor/default'' rather than ''cursor/text''
	over text when 'user-select' is ''user-select/none''.

<h3 id="insertion-caret">Insertion caret</h3>

<h4 id="caret-color">Coloring the insertion caret: 'caret-color'</h4>

	Issue: Add final level 3 content

	Issue: Amend the definition of ''caret-color/auto'' to highlight
	the fact that when 'caret-shape' is ''caret-shape/block'',
	ensuring good visibility and contrast means not using
	currentColor.

<!--
<h4 id="caret-animation">Animation of the insertion caret: 'caret-animation'</h4>

<pre class='propdef'>
Name: caret-animation
Value: auto | blink | none | fade
Initial: auto
Applies to: elements that accept input
Inherited: yes
Percentages: N/A
Media: interactive
Computed value: Same as specified value.
Animatable: no
</pre>

On most platforms and in most UAs,
the text insertion caret blinks.
This property allows the author
to control the speed at which it blinks,
or to turn off blinking entirely.


<dl dfn-type=value dfn-for=caret-animation>
        <dt><dfn>auto</dfn>
        <dd>The UA determines how the caret should be animated, if at all.
        It should match platform conventions,
        and may be adjusted based on context.

        Note: This is typically rendered as a blinking caret.

        <dt><dfn>blink</dfn>
        <dd>The UA must display a blinking caret.
        For accessibility reasons, and based on user preferences,
        The UA may display a non animated caret instead.

        <dt><dfn>none</dfn>
        <dd>The UA must not animate the caret.

        Note: This is only about UA driven animations of the caret.
        If CSS animations are used to animate the caret color,
        these should still apply normally.

        <dt><dfn>fade</dfn>
        <dd>The UA must display a caret repeatedly fading in and out,
        similarly to ''caret-animation/blink'' except it appears and
        disappears progressively rather than suddenly.
        For accessibility reasons, and based on user preferences,
        The UA may display a non animated caret instead.
</dl>

        Issue: Do we need the accessibility escape hatch on blink and fade?
        Would it be enough instead to expect the UI to put
        <code>caret-animation:fixed !important</code> in the
        user stylesheet when it wants to prevent the caret
        from blinking?

The UA determines the speed at which the cursor blinks or fades.
It should follow platform conventions and settings.

Note: It is recommended to stop the caret from blinking or fading
using ''caret-animation: none''
when applying custom animations using [[CSS3-ANIMATIONS]],
to prevent the blinking or fading and the css animation to interfere.

Note: See <a href="https://www.w3.org/TR/WCAG20/#seizure">Guideline 2.3: Seizures: Do not design content in a way that is known to cause seizures</a> [[WCAG20]].

<div class=example>
	A user who is disturbed by or has adverse reactions to blinking or flashing visuals
	may want to make all carets static and non-blinking,
	regardless of platform defaults or author settings.
	This can be accomplished by with the folliwing rule in the user stylesheet.

	<pre><code class="lang-css">
/* prevent the caret from blinking/flashing */
:read-write { caret-animation: none !important; }

/* prevent changes of caret-color, including animations */
:read-write { caret-color:auto !important; }
	</code></pre>
</div>

UAs that do not have an editable user stylesheet
should provide a setting to disable
<a href="https://www.w3.org/TR/WCAG20/#blinksdef">blinking</a>,
<a href="https://www.w3.org/TR/WCAG20/#flash-def">flashing</a>
and animated carets.
UAs that do have an editable user stylesheet may want to provide this setting as well.
See [[WCAG]] <a href="https://www.w3.org/TR/WCAG20/#time-limits-pause">Guideline 2.2</a>
and <a href="https://www.w3.org/TR/WCAG20/#seizure">Guideline 2.3</a>
for details.

<div class=example>
	Normally, the caret blinks between on and off.
	This makes it alternate between 2 colors.
	<pre><code class="lang-css">
textarea {
        caret-animation: none;
        caret-color: blue;
        animation: caret-alternate 2s step-end infinite;
}
@keyframes caret-alternate {
	50% { caret-color: red; }
}
	</code></pre>

	The simulated rendering below illustrates how this should look.
	<style>
@-webkit-keyframes caret-alternate-ref { 50% { border-color: red; } }
@keyframes caret-alternate-ref { 50% { border-color: red; } }
	</style>
	<div style="border:inset; background: white; width: 10em;">
		Text area
		with color-alternating caret<span style="border-right: 2px solid blue; animation: caret-alternate-ref 2s step-end infinite;-webkit-animation: caret-alternate-ref 2s step-end infinite;"></span>
	</div>

	Focus the element below to see how your browser renders it.
<style>
@keyframes caret-alternate-test {
	50% { caret-color: red; }
}
</style>
	<div contentEditable=true
	     style="border:inset; background: white; width: 10em;
	            caret-animation: none;
	            caret-color: blue;
	            animation: caret-alternate-test 2s step-end infinite;"
	>Text area with color-alternating caret</div>
</div>
-->


<h4 id="caret-shape">Shape of the insertion caret: 'caret-shape'</h4>

<pre class='propdef'>
Name: caret-shape
Value: ''auto'' | ''bar'' | ''block'' | ''underscore''
Initial: auto
Applies to: elements that accept input
Inherited: yes
Percentages: N/A
Media: interactive
Computed value: Same as specified value
Animatable: no
</pre>

This property allows authors to specify
the desired shape of the text insertion caret.

Within the context of this definition, <dfn>character</dfn> is
to be understood as <em>extended grapheme cluster</em>,
as defined in [[!UAX29]], and <dfn>visible character</dfn>
means a character with a non-zero advance measure.

<dl dfn-type=value dfn-for=caret-shape>
	<dt><dfn>auto</dfn>
	<dd>The UA determines the shape of the caret.
	It should match platform conventions,
	and may be adjusted based on context.
	For example, if a UA switches between insert mode and overtype mode when the
	user presses the <em>insert</em> key on their keyboard,
	it may show a ''caret-shape/bar'' caret in insert mode,
	and a ''caret-shape/block'' caret in overtype mode.
	<dt><dfn>bar</dfn>
	<dd>The UA must render the text insertion caret
	as a thin bar placed at the insertion point.
	This means it is between, before, or after characters, not over them.
	It should be perpendicular to the inline progression direction,
	although UAs may render it slanted when inserting italic or oblique text.
	<dt><dfn>block</dfn>
	<dd>The UA must render the text insertion caret
	as a rectangle overlapping the next visible character following the insertion point.
	If there is no visible character after the insertion point,
	the UA must render the caret after the last visible character.
	UAs may render it as a slanted rectangle when inserting italic or oblique text.
	<dt><dfn>underscore</dfn>
	<dd>The UA must render the text insertion caret
	as a thin line <a>under</a> (as defined in [[!CSS-WRITING-MODES-3]]
	the next visible character following the insertion point.
	If there is no visible character after the insertion point,
	the UA must render the caret after the last visible character.
</dl>

The width of the ''caret-shape/block'' and ''caret-shape/underscore'' carets
should be the advance measure of the next visible character after the insertion point,
or ''1ch'' if there is no next visible character
or if this information is impractical to determine.

When determining the orientation and appearance of the caret,
UAs must take into account the <a>writing mode</a> [[!CSS-WRITING-MODES-3]]
and must apply transformations [[!CSS-TRANSFORMS-1]].
If the edited text is laid out out on a path,
for instance by using the SVG <{textPath}> element,
UAs should also account for this.

The stacking position of the caret is left undefined, within the following constraints:
<ul>
	<li>The caret must not be obscured by the background of the element
	<li>UAs must render ''caret-shape/block'' carets so that the
	character it overlaps with is not obscured by the caret
</ul>

<div class=example>
	This illustrates the typical appearance of the various caret shapes.
	In each of the sample renderings below,
	the insertion point is between the letters u and m.

	<style>
@-webkit-keyframes caret-bar-ref { 50% { outline-color: transparent; } }
@-webkit-keyframes caret-block-ref { 50% { background: transparent; } }
@-webkit-keyframes caret-underscore-ref { 50% { border-color: transparent; } }
@keyframes caret-bar-ref { 50% { outline-color: transparent; } }
@keyframes caret-block-ref { 50% { background: transparent; } }
@keyframes caret-underscore-ref { 50% { border-color: transparent; } }
#caret-shape-example {
	min-width: 25em;
}
#caret-shape-example,
#caret-shape-example td,
#caret-shape-example th {
	border: solid 1px;
}
#caret-shape-example td+td {
	background:white;
}
	</style>
	<table id="caret-shape-example">
		<tr><th>'caret-shape'<th>Sample rendering<th>Your browser<br>(focus each cell to see the caret)
		<tr><td>''bar''<td>Lorem ipsu<span style="outline: 1px solid black;animation: caret-bar-ref 2s step-end infinite;-webkit-animation: caret-bar-ref 2s step-end infinite;">&#8203;</span>m<td style contentEditable=true style="caret-shape: bar">Lorem Ipsum
		<tr><td>''block''<td>Lorem ipsu<span style="background: #bbb; -webkit-animation: caret-block-ref 2s step-end infinite;animation: caret-block-ref 2s step-end infinite;">m</span><td contentEditable=true style="caret-shape: block">Lorem Ipsum
		<tr><td>''underscore''<td>Lorem ispu<span style="border-bottom: 2px solid black; -webkit-animation: caret-underscore-ref 2s step-end infinite; animation: caret-underscore-ref 2s step-end infinite;">m</span><td contentEditable=true style="caret-shape: underscore">Lorem Ipsum
	</table>
</div>


<div class=example>
	''caret-shape/underscore'' or ''caret-shape/block'' carets are commonly used
	in terminals and command lines,
	as in this example.
	<pre><code class="lang-css">
.console {
	caret-shape: underscore;
	background: black;
	color: white;
	font-family: monospace;
	padding: 1ex;
}
	</code></pre>

	The simulated rendering below illustrates how this should look.
	<style>
@-webkit-keyframes terminal-caret-ref { 50% { border-color: transparent; } }
@keyframes terminal-caret-ref { 50% { border-color: transparent; } }
	</style>
	<pre style="background: black; color: white; font-family: monospace; padding: 1ex">
	user@host:css-ui-4 $ ls -a
	. .. Overview.bs Overview.html
	user@host:css-ui-4 $ <span style="border-bottom: 2px solid white;animation: terminal-caret-ref 2s step-end infinite;-webkit-animation: terminal-caret-ref 2s step-end infinite;">&nbsp;</span>
	</pre>

	Focus the element below to see how your browser renders it.
	<pre contentEditable=true style="background: black; color: white; font-family: monospace; padding: 1ex; caret-shape: underscore;">
	user@host:css-ui-4 $ ls -a
	. .. Overview.bs Overview.html
	user@host:css-ui-4 $ 
	</pre>

</div>

<h4 id="caret">Insertion caret shorthand: 'caret'</h4>

<!-- Value: <<'caret-color'>> || <<'caret-animation'>> || <<'caret-shape'>> -->
<pre class='propdef'>
Name: caret
Value: <<'caret-color'>> || <<'caret-shape'>>
Initial: auto
Applies to: elements that accept input
Inherited: yes
Percentages: N/A
Media: interactive
Computed value: See individual properties
Animatable: See individual properties
</pre>

This property is a shorthand for setting
'caret-color' <!--, 'caret-animation'--> and 'caret-shape' in one declaration.
Omitted values are set to their initial values.

<!--
<div class=example>
	This example illustrates using the various caret related properties
	in combination.
	They are used here to simulate the appearance of the caret
	on an old phosphor computer monitor.

	<pre><code class="lang-css">
#old-screen {
	caret: block none;
	animation: old-caret 2s infinite;
	/*styling of the screen omitted for brevity */
}
@keyframes old-caret {
	from, 50% { caret-color: green; }
	75%, to { caret-color: transparent; }
}
	</code></pre>

	The simulated rendering below illustrates how this should look.
	<style>
.old-screen {
	border-radius: 1em;
	padding: 1em;
	color: green;
	font-family: monospace;
	white-space: pre;
	background: repeating-linear-gradient(#030 0px, #030 1px, #020 1px, #020 3px);
}
.old-screen span {
	display:inline-block;
	white-space: pre;
	caret: block 0s;
	animation: caret-old-ref 2s  infinite;
	-webkit-animation: caret-old-ref 2s  infinite;

}
@keyframes caret-old-ref {
	from, 50% { background-color: green; }
	75%, to { background-color: transparent; }
}
@-webkit-keyframes caret-old-ref {
	from, 50% { background-color: green; }
	75%, to { background-color: transparent; }
}
	</style>
	<div class="old-screen" style="height: 100px">&gt; <span>&nbsp;</span></div>

	Focus the element below to see how your browser renders it.
	<div class="old-screen" contentEditable="true" style="height: 100px">&gt; </div>
</div>
-->

<h3 id="keyboard">Keyboard control</h3>

<h4 id="nav-dir">Directional focus navigation: the 'nav-up', 'nav-right', 'nav-down', 'nav-left' properties</h4>

	Issue: Add final level 3 content

<h4 id="input-method-editor">Obsolete: the ime-mode property</h4>

	Issue: Add final level 3 content

<h2 id="user-interaction">User Interaction</h2>

<h3 id="content-selection">Controlling content selection</h3>

	The 'user-select' property enables authors to specify
	which elements in the document can be selected by the user and how.
	This allows for easier interactions when not
	all elements are equally useful to select,
	avoiding accidental selections of neighbouring content.

	<pre class='propdef'>
		Name: user-select
		Value: auto | text | none | contain | all
		Initial: auto
		Inherited: no
		Applies to: all elements, and optionally to the ''::before'' and ''::after'' pseudo elements
		Media: interactive
		Computed value: See below
	</pre>

	User Agents must not apply the 'user-select' property to
	the ''::first-line'' and ''::first-letter'' pseudo elements.

	Note: The UA may apply this property to the ''::before'' and ''::after'' pseudo elements.
	If it does, ''user-select/auto'' value computes to ''user-select/none'' on these pseudos,
	but other values can be specified.
	This preserves the legacy behavior of generated content not being selectable or copyable,
	which is appropriate when these pseudos are used for decorative purposes.
	However, this property allows them to become selectable and copyable,
	as the user would expect in cases where they are used to generate part of the content,
	such as the issue numbers in this document.
	<strong class="advisement">To the extent possible,
	authors should avoid using generated content
	for non decorative purposes,
	and should prefer including all the content in the DOM.</strong>
	<em>This feature is at risk.</em>

	Issue: if we allow user-select to change to a value other than ''user-select/none'',
	we need to figure out what this means for copyability, and DOM APIs.

	When generated content in pseudo elements becomes selectable
	through this mechanism,
	UAs should also make this content findable through their search function.

	Issue: Should it also apply to ''::marker''? To <a>page-margin boxes</a>?
	Should the computed value of '''user-select/auto'' also be ''user-select/none'',
	or would ''user-select/text'' be more appropriate?

	The computed value is the specified value,
	except:
	<ol>
		<li>on <a>editable element</a>s
		where the computed value is always ''user-select/contain''
		regardless of the specified value
		<li>when the specified value is ''user-select/auto'',
		which computes one of the other values as defined below
	</ol>

	For the purpose of this specification,
	an <dfn>editable element</dfn> is either
	an <a href="https://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#editing-host">editing host</a>
	or a <a href="https://www.w3.org/TR/html/forms.html#mutability">mutable</a> form control with textual content,
	such as <{textarea}>.

	Issue: Should there be constraints
	on what happens to the computed value
	on elements that are editable descendants of editing hosts?
	The semantics are not obvious.
	Maybe ''user-select/none'' should compute to ''text'',
	or maybe all values should compute to ''text''.

	<dl dfn-type=value dfn-for=user-select>
		<dt><dfn>auto</dfn>
		<dd>The computed value of ''user-select/auto'' is determined as follows:
		<ul>
			<li>On the ''::before'' and ''::after'' pseudo elements,
			the computed value is ''user-select/none''
			<li>If the element is an <a>editable element</a>,
			the computed value is ''contain''
			<li>Otherwise,
			if the computed value of 'user-select' on the parent of this element is ''all'',
			the computed value is ''all''
			<li>Otherwise,
			if the computed value of 'user-select' on the parent of this element is ''user-select/none'',
			the computed value is ''user-select/none''
			<li>Otherwise, the computed value is ''text''
		</ul>

		Note: This unusual combination of a non inherited property with an initial value of ''user-select/auto''
		whose computed value depends on the parent element
		makes it possible to create what is effectively selective inheritance.
		This was initially proposed by Microsoft in IE to introduce a behavior similar to inheritance
		except that the ''contain'' value does not inherit.

		<dt><dfn>text</dfn>
		<dd>The element imposes no constraint on the selection.

		<dt><dfn>none</dfn>
		<dd>
		The UA must not allow selections to be started in this element.

		A selection started outside of this element must not end in this element.
		If the user attempts to create such a selection,
		the UA must instead end the selection range at the element boundary.

		Note: As of the time of writing, experimental implementations do not all behave like this.
		Firefox does.
		Chrome and Safari almost do: for a selection started after the element
		and trying to go backwards into the element
		they behave as specified here,
		but for a selection started before the element
		and trying to go into the element
		they behave as if the element has ''all'' and select it entirely.
		IE does not restrict selections started outside of the element
		from going into it at all.
		Another difference is that in Chrome and Safari,
		if the user attempts to start a selection inside a ''user-select: none'',
		and to end the selection out of it,
		a selection will be created from the boundary of the element
		to the user-designated end-point.
		Firefox and Internet explorer behave as prescribed in this specification
		and do not create a selection at all.

		However, if this element has descendants on which the computed value of 'user-select' is not ''user-select/none'',
		selections that start and end within these descendants are allowed.

		The UA must allow selections to extend across this element,
		and must exclude this element from such a selection.
		An exception is made for UAs which do not support multiple ranges per selection,
		and they may include this element.
		If the element has descendants on which 'user-select' does not compute to ''user-select/none'',
		these descendants must be included in a selection extending across the element.
		<span class=note>This specification makes no normative requirement
		about the behavior of the clipboard.
		however, UAs are encouraged to keep the visual selection consistent
		with what would get copied to the clipboard when copying.
		Copying text that does not appear to be selected, or vice versa,
		is highligh confusing to users.</span>

		Attempting to start a selection in an element where 'user-select' is ''user-select/none'',
		such as by clicking in it or starting a drag in it,
		must not cause a pre-existing selection to become unselected or to be affected in any way.

		As 'user-select' is a UI convenience mechanism,
		not a copy protection mechanism,
		the UA may provide an alternative way for the user
		to explicitly select the text even when 'user-select' is ''user-select/none''.

		Note: ''user-select/none'' is not a copy protection mechanism,
		and using it as such is ineffective:
		User Agents are allowed to provide ways to bypass it,
		it will have no effect on legacy User Agents that do not support it,
		and the user can disable it through the user style sheet or equivalent mechanisms
		on UAs that do anyway.
		Instead, ''user-select/none'' is meant to
		make it easier for the user to select the content they want,
		by letting the author disable selection on UI elements
		that are not useful to select.
		Tools such as CSS validators, linters or in-browser developer tools
		are encouraged to use heuristics
		to detect and warn against incorrect or abusive usage
		that would hamper usability
		or violate common user expectations.

		<dt><dfn>contain</dfn>
		<dd>UAs must not allow a selection which is started in this element
		to be extended outside of this element.

		A selection started outside of this element must not end in this element.
		If the user attempts to create such a selection,
		the UA must instead end the selection range at the element boundary.

		The UA must allow selections to extend across this element,
		and such selections must include the content of the element.

		Note: At the time of writing, experimental implementations behave differently from eachother
		about selections started outside and selections going into the element.
		The behavior can be observed even on browsers that do not explicitly support ''contain''
		by trying to select into a <{textarea}> or a contenteditable element.

		Note: This was initially introduced
		as an experimental feature in Internet Explorer,
		under the name <code>user-select: element</code>.

		<dt><dfn>all</dfn>
		<dd>The content of the element must be selected atomically:
		If a selection would contain part of the element,
		then the selection must contain the entire element including all its descendants.
		If the element is selected
		and the computed value of 'user-select' on its parent is ''all'',
		then the parent must be included in the selection, recursively.

		If this element has descendants on which the computed value of 'user-select' is not ''all''
		and if a selection is entirely contained in these descendants,
		then the selection is not extended to include this whole element.
	</dl>

	Note: Selections can include more than just text and extend over images, tables, videos, etc.
	The behavior when copying and pasting a such selections is out of scope for this specification.

	The following additions are made to the UA stylesheet for HTML:
	<pre><code class="lang-css">
	button, meter, progress, select { user-select: none; }
	</code></pre>

	Issue: the list above is incomplete, and needs to include
	at least the various button-like variants of <{input}>.

	For compatibility with legacy content,
	UAs that support 'user-select' must also support ''-webkit-user-select'' as an alias.

	Note: The details of the aliasing aliasing mechanism is intentionally left up to the UA.
	Making ''-webkit-user-select'' a shorthand property of 'user-select'
	is known to be an effective approach,
	and new implementers should consider it.
	However UAs supporting ''-webkit-user-select'' as an alias of 'user-select' through other means exist,
	without adverse consequences to compatibility,
	so this specification allows flexibility.

<h2 id="form-styling">Form Control Styling</h2>

<h3 id="appearance-switching">Switching appearance</h3>

While the way most elements in a document look can be fully controlled by CSS,
form controls are typically rendered by UAs using native UI controls of the host operating system,
which can neither be replicated nor styled using CSS.

This specification introduces the 'appearance' property
to provide some control over this behavior.
Using ''appearance: none'' allows authors
to suppress the native style of form controls,
so that CSS can be used to fully restyle them.

<pre class="propdef">
Name: appearance
Value: ''auto'' | ''none''
Initial: auto
Applies To: all elements
Inherited: no
Computed value: As specified
Media: all
</pre>

Issue: Should ''appearance/auto'' compute to ''appearance/none'' on regular elements?
I would say no:
If we did that,
to be consistent,
every time we introduced a new value,
we would change what ''appearance/auto'' computes to on some elements,
which doesn't sounds desirable.

Note: This specification intentionally refrains from making the appearance
of all possible form controls and sub-controls available as values,
as had previously been attempted by earlier proposals for this property
and by several UA vendors in experimental implementations.
Experience has shown that such a list would be very long and not practical to maintain,
and UAs would need to add non-standard values
to account for the behavior of non-standard pseudo-elements
sometimes used to implement form controls.
Moreover, many values of such an enumeration only make sense
on a single element or pseudo-element,
and are never used outside of the UA stylesheet.
Instead, this specification only provides
''appearance/auto'', ''appearance/none''.
UAs cannot therefore use the 'appearance' property
in the UA stylesheet to give each control its native look and feel,
and must use ''appearance:auto'' instead.

Issue: IE supports -webkit-appearance, and also includes the textfield and button values.
Presumably this was done due to compatibility problems,
so we may need to include it as well.

<dl dfn-type=value dfn-for=appearance>
	<dt><dfn>auto</dfn>
	<dd>UAs may render form controls using native controls of the host operating system
	or with a look and feel not otherwise expressible in CSS.

	Elements other than form controls must be rendered as if ''appearance/none'' had been specified.
	<dt><dfn>none</dfn>
	<dd> The element is rendered following the usual rules of CSS.
	Replaced elements other than form controls are not affected by this,
	and remain replaced elements.
	Form controls are <em>not</em> made to look like native controls of the host operating system.
	See below for details.

	Issue: Shouldn't this be called "normal" instead?
	''appearance/none'' makes it sound like the targeted element will disappear.
</dl>

On form control elements where the computed value is ''appearance/auto''
UAs may disregard some CSS properties
to ensure that the intended appearance is preserved,
or because these properties may not be meaningful for the chosen appearance.
However, the following properties must not be disregarded:
<ul>
	<li>'appearance'
	<li>'display'
	<li>'visibility'
	<li>'position'
	<li>'top'
	<li>'right'
	<li>'bottom'
	<li>'left'
	<li>'float'
	<li>'clear'
	<li>'margin' and related long-hand properties
	<li>'unicode-bidi'
	<li>'direction'
	<li>'all' <span class=note>This does not imply a requirement to apply all the properties reset by 'all'</span>
	<li>'cursor'
	<li>'z-index'
</ul>

Issue: Are there more properties should include in this list?
Should we remove some?
Should whitelist the properties that are ok to ignore instead of
blacklisting those that are not?
Either way, UAs do ignore some properties when rendering form controls,
so this specification needs to say something about this.

All decorative visual aspects of a form control which are not caused by a CSS style rule
must be suppressed when the appearance is changed using 'appearance',
even if the UA's internal representation for this element
was composed of multiple elements or pseudo elements combined together.
For example, <{select}> is often rendered with an arrow on the right side
indicating that the list will be expanded if the element is clicked.
If the computed value of 'appearance' is ''appearance/none'', this
must disappear.

However, the UA must preserve aspects of the form control
which are necessary to operate the control with its original semantics.
This does not include aspects of a control which are merely needed to observe the state the control is in,
only those that are needed for the user to be able to modify the state of the control.
The UA may however give them a different look and feel
as long as it remains possible to operate the control.
For example,
the slider of an <code class="lang-markup">&lt;input type=range></code> is preserved
(or replaced by an equivalent mechanism)
even if 'appearance' is ''appearance/none''
as it would otherwise not be possible to change the value of the range with the mouse or touchscreen.
On the other hand,
the check mark in an <code class="lang-markup">&lt;input type=checkbox checked></code>
must be suppressed,
as it merely indicates the state the element is in,
which can be styled in different ways using the '':checked'' selector.

Issue: UAs are inconsistent about the preceding two paragraphs.
What is specified here attempts to give some logic
to what is preserved and what is not,
based on the use-cases for 'appearance'.

UAs should include in their User Agent stylesheet style rules
to give form controls a recognizable shape when 'appearance' is ''appearance/none''.

Note: Authors may therefore need to override these UA style rules to get the styling
they intended, possibly by using ''all: unset''.

Issue: This usage of the 'all' property would remove focus indicators
created by the 'outline' property,
which seems undesirable.
Using ''all: revert'' would not solve it, as it would fail to remove
the UA styles as intended.
How can we mitigate this?

The behavior and semantics of elements remain defined by the host language,
and are not influenced by this property.
For example, regardless of the computed value of 'appearance':
<ul>
	<li>Elements which can be in different states keep this ability,
	and the relevant pseudo-classes match as usual.
	<li>If a <{select}> element is activated,
	the UI to choose one of the associated <{option}> elements is shown
	(although it may look different).
	<li>Event handlers attached to the element trigger as usual.
</ul>

Conversely, changing the appearance of an element must not cause it
to acquire new semantics, pseudo classes, event handlers, etc
that it did not initially have.
The ability for an element to be focused
is also not changed by the 'appearance' property.

<div class=example>
	An author wanting to customize the look and feel of check boxes in HTML could use the following:
	<pre><code class="lang-css">
input[type=checkbox] {
	appearance: none;
	all: unset;
	width: 1em;
	height: 1em;
	display: inline-block;
	background: red;
}
input[type=checkbox]:checked {
	border-radius: 50%;
	background: green;
}
	</code></pre>

	<code class="lang-markup">&lt;input type="checkbox"></code> would be rendered as
	<span style="display: inline-block; width: 1em; height: 1em; background: red;"></span>,
	while <code class="lang-markup">&lt;input type="checkbox" checked></code> would be rendered as
	<span style="display: inline-block; width: 1em; height: 1em; background: green; border-radius: 50%;"></span>,
	and activating (for example by clicking) the element would toggle the state as usual.
</div>

<hr title="Separator from footer">


<h2 class="no-num" id="acknowledgments">Appendix A. Acknowledgments</h2>

This appendix is <em>informative</em>.

This specification builds upon [[CSS3-UI]],
which was edited and written for the most part
by Tantek Çelik from 1999 to the present,
first while representing Microsoft, then as an Invited Expert,
and most recently while representing Mozilla.

Thanks to feedback and contributions from
<span class="h-card">Rossen Atanassov</span>,
<span class="h-card">Tab Atkins</span>,
<span class="h-card">L. David Baron</span>,
<span class="h-card">Bert Bos</span>,
<span class="h-card">Matthew Brealey</span>,
<span class="h-card">Rick Byers</span>,
<span class="h-card">Ada Chan</span>,
<span class="h-card">James Craig</span>,
<span class="h-card">Michael Cooper</span>,
<span class="h-card">Axel Dahmen</span>,
<span class="h-card">Michael Day</span>,
<span class="h-card">Micah Dubinko</span>,
<span class="h-card">Elika E.</span>,
<span class="h-card">Steve Falkenburg</span>,
<span class="h-card">Andrew Fedoniouk</span>,
<span class="h-card">Al Gilman</span>,
<span class="h-card">Ian Hickson</span>,
<span class="h-card">Bjoern Hoehrmann</span>,
<span class="h-card">Alan Hogan</span>,
<span class="h-card">David Hyatt</span>,
<span class="h-card">Richard Ishida</span>,
<span class="h-card">Sho Kuwamoto</span>,
<span class="h-card">Yves Lafon</span>,
<span class="h-card">Stuart Langridge</span>,
<span class="h-card">Susan Lesch</span>,
<span class="h-card">Peter Linss</span>,
<span class="h-card">Kang-Hao Lu</span>,
<span class="h-card">Masayuki Nakano</span>,
<span class="h-card">Mats Palmgren</span>,
<span class="h-card">Brad Pettit</span>,
<span class="h-card">François Remy</span>,
<span class="h-card">Andrey Rybka</span>,
<span class="h-card">Simon Sapin</span>,
<span class="h-card">Alexander Savenkov</span>,
<span class="h-card">Sebastian Schnitzenbaumer</span>,
<span class="h-card">Lea Verou</span>,
<span class="h-card">Etan Wexler</span>,
<span class="h-card">David Woolley</span>,
<span class="h-card">Frank Yan</span>,
<span class="h-card">Boris Zbarsky</span>,
and
<span class="h-card">Domel</span>.

<h2 class="no-num" id="changes">Appendix B. Changes</h2>

This appendix is <em>informative</em>.

This appendix describes functional changes from the 
<a href="https://www.w3.org/TR/2015/WD-css-ui-4-20150922/"
   >22 Sep 2015 First Public Working Draft</a>.

<ul>
	<li>The caret-animation property have been removed.
	It may be reintroduced later given sufficient evidence for use cases.
	<li>The ''resize'' property now also applies to
	    replaced elements representing images or videos,
	    and to iframes.
</ul>

<h2 class="no-num" id="security-privacy-considerations">Appendix C. Considerations for Security and Privacy</h2>

This appendix is <em>informative</em>.

The W3C TAG is developing a
<a href="https://w3ctag.github.io/security-questionnaire/">Self-Review Questionnaire: Security and Privacy</a>
for editors of specifications to informatively answer.

Per the <a href="https://w3ctag.github.io/security-questionnaire/#questions">Questions to Consider</a>

<ol>
<li>Does this specification deal with personally-identifiable information?
<p>No.</p>
</li>

<li>Does this specification deal with high-value data?
<p>No.</p>
</li>

<li>Does this specification introduce new state for an origin that persists across browsing sessions?
<p>No.</p>
</li>

<li>Does this specification expose persistent, cross-origin state to the web?
<p>No.</p>
</li>

<li>Does this specification expose any other data to an origin that it doesn’t currently have access to?
<p>No.</p>
</li>

<li>Does this specification enable new script execution/loading mechanisms?
<p>No.</p>
</li>

<li>Does this specification allow an origin access to a user’s location?
<p>No.</p>
</li>

<li>Does this specification allow an origin access to sensors on a user’s device?
<p>Yes. The directional focus navigation properties indirectly allow access to the device's keyboard navigation input mechanism such as arrow keys.</p>
</li>

<li>Does this specification allow an origin access to aspects of a user’s local computing environment?
<p>No.</p>
</li>

<li>Does this specification allow an origin access to other devices?
<p>No.</p>
</li>

<li>Does this specification allow an origin some measure of control over a user agent’s native UI?
<p>Yes. The 'cursor' and 'caret-*' properties enable the page to change the display of the cursor and text insertion caret of the user agent’s native UI. In addition the 'outline-style' property’s ''outline-style/auto'' value (and thus 'outline' shorthand) enable the page to potentially display a native focused element outline presentation around any element.</p>
<p>The 'appearance' property also allows author to turn off native styling and replace it with css based styling.
</li>

<li>Does this specification expose temporary identifiers to the web?
<p>No.</p>
</li>

<li>Does this specification distinguish between behavior in first-party and third-party contexts?
<p>No.</p>
</li>

<li>How should this specification work in the context of a user agent’s "incognito" mode?
<p>No differently.</p>
</li>

<li>Does this specification persist data to a user’s local device?
<p>No.</p>
</li>

<li>Does this specification have a "Security Considerations" and "Privacy Considerations" section?
<p>Yes.</p>
</li>

<li>Does this specification allow downgrading default security characteristics?
<p>No.</p>
</li>
</ol>

<h2 class="no-num" id="default-style-sheet">Appendix D. Default style sheet additions for HTML</h2>

	Issue: Add final level 3 content
