<pre class='metadata'>
Title: CSS Lists Module Level 3
Shortname: css-lists
Level: 3
Group: CSSWG
Status: ED
Work Status: Exploring
ED: https://drafts.csswg.org/css-lists-3/
TR: https://www.w3.org/TR/css-lists-3/
Editor: Tab Atkins, Google, http://xanthir.com/contact/
Former Editor: Ian Hickson, Google, ian@hixie.ch
Former Editor: Tantek Çel&#x0131;&#x0307;k, Formerly of Microsoft, tantekc@microsoft.com
Previous Version: https://www.w3.org/TR/2014/WD-css-lists-3-20140320/
Previous Version: https://www.w3.org/TR/2011/WD-css3-lists-20110524/
!Contributors: Simon Montagu, AOL-TW/Netscape, <a href="mailto:smontagu@netscape.com">smontagu@netscape.com</a>
!Contributors: Daniel Yacob, <a href="mailto:yacob@geez.org">yacob@geez.org</a>
!Contributors: Christopher Hoess, <a href="mailto:choess@stwing.upenn.edu">choess@stwing.upenn.edu</a>
!Contributors: Daniel Glazman, AOL-TW/Netscape, <a href="mailto:glazman@netscape.com">glazman@netscape.com</a>
Abstract: This draft contains the features of CSS level&nbsp;3 relating to list styling. It includes and extends the functionality of CSS level&nbsp;2 [[!CSS21]]. The main extensions compared to level&nbsp;2 are a pseudo-element representing the list marker, and some new ways to position markers.
Warning: not ready
</pre>

<pre class='link-defaults'>
spec:css-pseudo-4; type:selector; text:::before
</pre>

<h2 id='intro'>
Introduction</h2>

	This specification defines the ''::marker'' pseudo-element,
	the ''list-item'' 'display' value that generates markers,
	and several properties controlling the placement and styling of markers.

	It also defines <a>counters</a>,
	which are special numerical objects
	often used to generate the default contents of markers.

	<div class="example">
		For instance, the following example illustrates
		how markers can be used to add parentheses around each numbered list item:

		<xmp highlight=html>
			<style>
			li::marker { content: "(" counter(list-item, lower-roman) ")"; }
			li { display: list-item; }
			</style>
			<ol>
				<li>This is the first item.
				<li>This is the second item.
				<li>This is the third item.
			</ol>
		</xmp>

			It should produce something like this:

		<pre>
			  (i) This is the first item.
			 (ii) This is the second item.
			(iii) This is the third item.
		</pre>

		Note: Note that this example is far more verbose than is usually needed in HTML,
		as the UA default style sheet takes care of most of the necessary styling.
	</div>

	With descendant selectors and child selectors,
	it's possible to specify different marker types depending on the depth of embedded lists.

<h2 id='declaring-a-list-item'>
Declaring a List Item</h2>

	A <dfn export>list item</dfn> is any element with its 'display' property set to ''list-item''.
	<a>List items</a> generate ''::marker'' pseudo-elements;
	no other elements do.

	Additionally, <a>list items</a> automatically increment the special ''list-item'' <a>counter</a>.
	Unless the 'counter-increment' property manually specifies a different increment for the ''list-item'' <a>counter</a>,
	it must be incremented by 1 on every <a>list item</a>,
	at the same time that <a>counters</a> are normally incremented.
	(This has no effect on the values of the 'counter-*' properties.)

	If a <a>list item</a> generates an <a>inline box</a>,
	such as through ''display: inline list-item'',
	the ''outside'' value of 'list-style-position'
	must compute to ''inside'' on the element.

<!-- Big Text: markers -->

<h2 id='markers'>
Markers</h2>

	The defining feature of a <a>list item</a> is its <dfn export>marker</dfn>,
	a symbol or ordinal that helps denote the beginning of each <a>list item</a> in a list.

<h3 id='marker-pseudo'>
The ''::marker'' Pseudo-Element</h3>

	The ''::marker'' pseudo-element is automatically generated by a <a>list item</a>,
	and is automatically filled with content
	according to the <a>list item’s</a> 'list-style' property
	(or its subproperties).

	The ''::marker'' pseudo-element is generated as the first child of the <a>list item</a>,
	before the ''::before'' pseudo-element
	(if that exists on the element).
	''::marker''s are <a>inline</a> by default,
	tho 'list-style-position' can cause them become <a>absolutely positioned</a>.

	The ''::marker'' pseudo-element only exists on <a>list items</a>.
	On any other element,
	the ''::marker'' pseudo-element's 'content' property must compute to ''content/none'',
	which suppresses its creation.

	Only a limited set of properties can be used on the ''::marker'' pseudo-element.
	This list is defined in [[css-pseudo-4#marker-pseudo]].

	<div class="example">
		In the following example,
		the content is centered within a marker box of a fixed width.

	<div class="example">
		In this example, markers are used to number paragraphs that are designated as "notes":

		<xmp highlight=html>
			<style>
			p { margin-left: 12 em; }
			p.note {
				display: list-item;
				counter-increment: note-counter;
			}
			p.note::marker {
				content: "Note " counter(note-counter) ":";
				text-align: left;
				width: 10em;
			}
			</style>
			<p>This is the first paragraph in this document.
			<p class="note">This is a very short document.
			<p>This is the end.
		</xmp>

		It should render something like this:

		<pre>
		            This is the first paragraph
		            in this document.

		  Note 1:   This is a very short
		            document.

		            This is the end.
		</pre>
	</div>

	<div class="example">
		By using the ''::marker'' pseudo-element,
		a list's markers can be positioned much more flexibly,
		and even be styled independently from the text of the list item itself:

		<xmp highlight=html>
			<style>
			p { margin-left: 8em } /* Make space for counters */
			li { list-style-type: lower-roman; }
			li::marker { color: blue; font-weight:bold; }
			</style>
			<p>This is a long preceding paragraph ...
			<ol>
				<li>This is the first item.
				<li>This is the second item.
				<li>This is the third item.
			</ol>
			<p>This is a long following paragraph ...
		</xmp>

		The preceding document should render something like this:

		<pre>
		        This is a long preceding
		        paragraph ...

		   <span style=color:blue;font-weight:bold;>i.</span>   This is the first item.
		  <span style=color:blue;font-weight:bold;>ii.</span>   This is the second item.
		 <span style=color:blue;font-weight:bold;>iii.</span>   This is the third item.

		        This is a long following
		        paragraph ...
		</pre>

		Previously the only way to style a marker was through inheritance;
		one had to put the desired marker styling on the list item,
		and then revert that on a wrapper element around the list item's actual contents.
	</div>

<h3 id='content-property'>
Generating The ''::marker'' Boxes</h3>

	The ''::marker'' pseudo-element
	generates different contents
	(always <a>anonymous</a>)
	according to the 'list-style-image' and 'list-style-type' properties
	on its <a>originating element</a>,
	depending on the first of these conditions that is true:

	<dl class=switch>
		<dt>'list-style-image' is a <a>valid image</a>
		<dd>
			The contents of the ''::marker''
			are an <a>anonymous</a> <a>inline</a> <a>replaced element</a>
			representing the <<image>>,
			followed by a <a>text run</a> containing a single space (U+0020 SPACE).

		<dt>'list-style-type' is a <<string>>
		<dd>
			The contents of the ''::marker''
			are a <a>text run</a> containing the <<string>>.

		<dt>'list-style-type' is a <<counter-style>>
		<dd>
			The contents of the ''::marker''
			are a <a>text run</a> containing the ''@counter-style/prefix'' of the <<counter-style>>,
			followed by the result of <a lt="generate a counter representation">generating a counter representation</a>
			for the <<counter-style>>
			and the value of the <css>list-item</css> counter on the <a>originating element</a>,
			followed by a <a>text run</a> containing the ''@counter-style/suffix'' of the <<counter-style>>.

		<dt>otherwise
		<dd>
			The ''::marker'' has no contents.
	</dl>

<h3 id='image-markers'>
Image Markers: the 'list-style-image' property</h3>

	<pre class="propdef">
	Name: list-style-image
	Value: <<image>> | none
	Initial: none
	Applies to: <a>list items</a>
	Inherited: yes
	Percentages: n/a
	Media: visual
	Computed value: computed value of the <<image>>, or ''list-style-image/none''
	</pre>

	The 'list-style-image' property specifies an image
	that will be used to fill the ''::marker'' pseudo-element.
	The values are as follows:

	<dl dfn-type="value" dfn-for="list-style-image">
		<dt><dfn><<image>></dfn>
		<dd>
			Specifies that the ''::marker'' for the <a>list item</a>
			should show the specified <<image>>.

			If the <<image>> ends up being an <a>invalid image</a>,
			this value instead does nothing
			(like ''list-style-image/none'').

		<dt><dfn>none</dfn>
		<dd>
			Does nothing.
			Instead, 'list-style-type' will be consulted
			to determine how to fill the ''::marker''.
	</dl>

	<div class="example">
		The following example sets the marker at the beginning of each list item to
		be the image "ellipse.png".

		<pre highlight=css>li { list-style-image: url("http://www.example.com/ellipse.png") }</pre>
	</div>

<h3 id='text-markers'>
Text-based Markers: the 'list-style-type' property</h3>

	<pre class="propdef">
	Name: list-style-type
	Value: <<counter-style>> | <<string>> | none
	Initial: disc
	Applies to: <a>list items</a>
	Inherited: yes
	Percentages: n/a
	Media: visual
	Computed value: specified value
	</pre>

	When the value of 'list-style-image' is ''list-style-image/none''
	or an <a>invalid image</a>,
	the 'list-style-type' property instead specifies how to fill the ''::marker''.
	The values are as follows:

	<dl dfn-type="value" dfn-for="list-style-type">
		<dt><dfn><<counter-style>></dfn>
		<dd>
			The ''::marker''‘s contents will be generated
			according to the rules for that <a>counter style</a>. [[!CSS-COUNTER-STYLES-3]]

		<dt><dfn><<string>></dfn>
		<dd>
			The ''::marker'' will contain the <<string>>.

		<dt><dfn>none</dfn>
		<dd>
			The ''::marker'' will not contain anything.
	</dl>

	<div class='example'>
		The following examples illustrate how to set markers to various values:

		<pre highlight=css>
			ul { list-style-type: "★"; }
			/* Sets the marker to a "star" character */

			p.note {
				display: list-item;
				list-style-type: "Note: ";
				list-style-position: inside;
			}
			/* Gives note paragraphs a marker consisting of the string "Note: " */

			ol { list-style-type: upper-roman; }
			/* Sets all ordered lists to use the upper-roman counter-style
			   (defined in the Counter Styles specification [[CSS-COUNTER-STYLES]]) */

			ul { list-style-type: symbols(repeating '○' '●'); }
			/* Sets all unordered list items to alternate between empty and
			   filled circles for their markers. */

			ul { list-style-type: none; }
			/* Suppresses the marker entirely, unless list-style-image is specified
			   with a valid image. */
		</pre>
	</div>


<h3 id='list-style-position-property'>
Positioning Markers: The 'list-style-position' property</h3>

	<pre class="propdef">
	Name: list-style-position
	Value: inside | outside
	Initial: outside
	Applies to: <a>list items</a>
	Inherited: yes
	Percentages: n/a
	Media: visual
	Computed value: specified value (but see prose)
	</pre>

	This property dictates whether the ''::marker'' is rendered inline,
	or positioned just outside of the <a>list item</a>.
	The values are as follows:

	<dl dfn-type=value dfn-for=list-style-position>
		<dt><dfn>inside</dfn>
		<dd>
			No special effect.
			(The ''::marker'' is an inline element at the start of the <a>list item's</a> contents.)

		<dt><dfn id='list-style-position-outside'>outside</dfn>
		<dd>
			The 'position' property on the marker computes to ''marker''.
			Additionally, the base directionality of the marker
			(used as an input to the bidi resolution algorithm)
			must be taken from the marker's <a>marker positioning reference element</a>.

			If the <a>list item</a> is <a>inline</a>,
			this value instead computes to ''inside''.
	</dl>

	<div class=example>
		For example:

		<pre>
			&lt;style>
				ul.compact { list-style: inside; }
				ul         { list-style: outside; }
			&lt;/style>
			&lt;ul class=compact>
				&lt;li>first "inside" list item comes first&lt;/li>
				&lt;li>second "inside" list item comes first&lt;/li>
			&lt;/ul>
			&lt;hr>
			&lt;ul>
				&lt;li>first "outside" list item comes first&lt;/li>
				&lt;li>second "outside" list item comes first&lt;/li>
			&lt;/ul>
		</pre>

		The above example may be formatted as:

		<pre>
			  * first "inside" list
			  item comes first
			  * second "inside" list
			  item comes second

			========================

			* first "outside" list
			  item comes first
			* second "outside" list
			  item comes second</pre>
	</div>


<h3 id='list-style-property'>
Styling Markers: the 'list-style' shorthand property</h3>

	<pre class='propdef'>
	Name: list-style
	Value: <<'list-style-type'>> || <<'list-style-position'>> || <<'list-style-image'>>
	Initial: see individual properties
	Applies to: <a>list items</a>
	Inherited: see individual properties
	Percentages: see individual properties
	Media: visual
	Computed value: see individual properties
	</pre>

	The 'list-style' property is a shorthand notation
	for setting the three properties 'list-style-type', 'list-style-image', and 'list-style-position'
	at the same place in the style sheet.

	<div class="example">
		For example:

		<pre highlight=css>
			ul { list-style: upper-roman inside }  /* Any UL */
			ul ul { list-style: circle outside } /* Any UL child of a UL */
		</pre>
	</div>

	Using a value of <css>none</css> in the shorthand is potentially ambiguous,
	as <css>none</css> is a valid value for both 'list-style-image' and 'list-style-type'.
	To resolve this ambiguity,
	a value of <css>none</css> in the shorthand must be applied to whichever of the two properties aren't otherwise set by the shorthand.

	<div class='example'>
		<pre highlight=css>
			list-style: none disc;
			/* Sets the image to "none" and the type to "disc". */

			list-style: none url(bullet.png);
			/* Sets the image to "url(bullet.png)" and the type to "none". */

			list-style: none;
			/* Sets both image and type to "none". */

			list-style: none disc url(bullet.png);
			/* Syntax error */
		</pre>
	</div>


	<div class=example highlight=css>
		Although authors may specify 'list-style' information directly on list item elements
		(e.g., <{li}> in HTML),
		they should do so with care.
		Consider the following rules:

		<pre>
			ol.alpha li { list-style: lower-alpha; }
			ul li       { list-style: disc; }
		</pre>

		The above won't work as expected.
		If you nest a <{ul}> into an <a element lt="ol">ol class=alpha</a>,
		the first rule's specificity will make the <{ul}>’s list items use the lower-alpha style.

		<pre>
			ol.alpha > li { list-style: lower-alpha; }
			ul > li       { list-style: disc; }
		</pre>

		These work as intended.

		<pre>
			ol.alpha { list-style: lower-alpha; }
			ul       { list-style: disc; }
		</pre>

		These are even better,
		since inheritance will transfer the 'list-style' value to the list items.
	</div>


<h2 id='positioning'>
Marker Positioning</h2>

	<p class='issue'><strong>
		This section is not ready for implementation.
		It is an unreviewed rough draft that hasn't even been properly checked for Web-compatibility.
		Feel free to send feedback, but DON'T USE THIS PART OF THE SPEC.</strong>

<h3 id='position-marker'>
The ''marker'' value for 'position'</h3>

	This section introduces a new positioning scheme,
	designed to model the way in which ''list-style-position:outside'' list markers were traditionally positioned in CSS 2.1.
	Outside list markers now have their positioning defined	in terms of this new value.

	The new positioning scheme defined in this section can be used on all elements,
	not just ''::marker'' pseudo-elements.
	For example, this can be used to position explicit elements serving as markers in a legal document,
	so that the list item has a marker whose value is guaranteed to be correct regardless of whether the CSS is applied
	(often a requirement in legal documents),
	but which is positioned like a native CSS marker.

	<pre class="propdef partial">
	Name: position
	New values: marker
	Computed value: see prose, otherwise same as normal
	</pre>

	The <dfn value for=position>marker</dfn> value for 'position' depends on the element it is set on having a <a>list item</a> ancestor.
	If the specified value of 'position' is ''position/marker''
	and the element does not have a <a>list item</a> ancestor,
	'position' must compute to ''position/relative'' on the element.
	An element with ''position:marker'' counts as <a>absolutely positioned</a>.

	To calculate the marker's position, we must first define a few terms:

	<dl>
		<dt><dfn>ancestor list item</dfn>
		<dd>The <a>ancestor list item</a> is the marker's nearest list item ancestor element.

		<dt><dfn>marker positioning reference element</dfn>
		<dd>
			If the <a>ancestor list item</a> has ''marker-side:list-item'',
			the <a>marker positioning reference element</a> is the <a>ancestor list item</a>.

			Otherwise, if the <a>ancestor list item</a> has ''marker-side:list-container'' and has a parent element,
			the <a>marker positioning reference element</a> is that parent.

			Otherwise, the <a>marker positioning reference element</a> is the <a>ancestor list item</a>.


		<dt><dfn>list item positioning edge</dfn>
		<dd>
			The border edge of the <a>ancestor list item</a> corresponding to the "inline-start" edge of the <a>marker positioning reference element</a>.

		<dt><dfn>marker positioning edge</dfn>
		<dd>
			The outer edge of the marker that's on the opposite side from the <a>list item positioning edge</a>.
			For example, if the <a>list item positioning edge</a> ended up being the left border edge of the <a>ancestor list item</a>,
			the <a>marker positioning edge</a> would be the right margin edge of the marker.
	</dl>

	The marker's position in the <a>ancestor list item</a>’s block axis
	is calculated according to the <a href="https://www.w3.org/TR/CSS21/visuren.html#normal-flow">normal flow</a>.

	The marker's position in the <a>ancestor list item's</a> inline axis must be set such that
	the <a>marker positioning edge</a> is flush with the <a>list item positioning edge</a>.

	Note: The purpose of this somewhat convoluted definition is to position the marker flush against its list item,
	and then when "marker-side:list-container",
	keep all the markers for a given list on the same side of their list items even in mixed-direction text,
	so that authors can specify padding on only one side of the list container and still ensure their markers are visible.
	And on top of all that,
	do something reasonable in the face of potentially differing writing-modes
	on the marker, list item, and container.

	All elements or pseudo-elements with ''position:marker''
	that share a common <a>ancestor list item</a>
	are known as <dfn lt='associated marker'>markers associated with that list item</dfn>.

	The 'top', 'right', 'bottom', and 'left' properties specify offsets
	relative to the top, right, bottom, and left edges (respectively) of the element itself,
	similar to how relative positioning works.

	<div class='example'>
		''position:marker'' can be used when the precise list marker is important for the content,
		not a stylistic choice,
		but the normal <em>appearance</em> of lists is still desired.
		For example, this trimmed snippet of the US Code of Laws may be marked up as the following in HTML:

		<pre highlight=html>
			&lt;style>
			ol { list-style: none; }
			.marker { position: marker; }
			&lt;/style>
			&lt;ol>
			  &lt;li>
			    &lt;span class='marker'>(a)&lt;/span> Definitions.— For purposes of this section—
			    &lt;ol>
			      &lt;li>&lt;span class='marker'>(1)&lt;/span> the term “agency” means agency as...
			      &lt;li>&lt;span class='marker'>(2)&lt;/span> the term “individual” means a citizen...
			    &lt;/ol>
			  &lt;li>
			    &lt;span class='marker'>(b)&lt;/span> Conditions of Disclosure.— No agency shall disclose...
			    &lt;ol>
			      &lt;li>&lt;span class='marker'>(1)&lt;/span> to those officers and employees of the agency...
			      &lt;li>&lt;span class='marker'>(2)&lt;/span> required under section 552 of this title;
			    &lt;/ol>
			&lt;/ol>
		</pre>

		The preceding document should render something like this:

		<pre>
			(a) Definitions.— For purposes of this section—
			    (1) the term “agency” means agency as...
			    (2) the term “individual” means a citizen...
			(b) Conditions of Disclosure.— No agency shall disclose...
			    (1) to those officers and employees of the agency...
			    (2) required under section 552 of this title;
		</pre>

		Importantly, even if the stylesheet is unavailable,
		the list markers will appear the same
		(though they will be positioned slightly differently),
		so other documents can refer to those list markers
		and be confident that the reference will always be resolvable.
	</div>

<h3 id='marker-side'>
The 'marker-side' property</h3>

	By default, elements or ''::marker'' pseudo-elements with ''position:marker''
	position themselves according to their list item's directionality.
	However, if the list item is grouped with several other list items which may have different directionality
	(for example, multiple &lt;li>s with different "dir" attributes in an &lt;ol> in HTML),
	it is sometimes more useful to have all the markers line up on one side,
	so the author can specify a single "gutter" on that side
	and be assured that all the markers will lie in that gutter and be visible.
	The 'marker-side' property defined in this section allows an author to control this,
	switching list items to positioning their markers based off the list container's directionality instead.

	<pre class='propdef'>
	Name: marker-side
	Value: list-item | list-container
	Initial: list-item
	Applies to: <a>list items</a>
	Inherited: yes
	Percentages: n/a
	Media: visual
	Computed value: specified value
	</pre>

	<dl dfn-type=value dfn-for=marker-side>
		<dt><dfn>list-item</dfn>
		<dd>
			Any <a>associated markers</a> base their positioning off of the directionality of the list item.

		<dt><dfn>list-container</dfn>
		<dd>
			The <a>associated markers</a> instead base their positioning off of the directionality of the list item's parent element.
			The normative meaning of this is specified in the section defining <a href="#position-marker">position:marker</a>.
	</dl>

	<div class='example'>
		Here is an example of the effect that 'marker-side' can have on a list.
		Both of the following example renderings are generated from the following HTML,
		with the only difference being the value of 'marker-side' on the list:

		<pre highlight=html>
			&lt;ul>
			  &lt;li>english one
			  &lt;li dir=rtl>OWT WERBEH
			  &lt;li>english three
			  &lt;li dir=rtl>RUOF WERBEH
			&lt;/ul>
		</pre>

		<table class=data style="width: 35em;">
			<thead>
				<tr>
					<th>list-item
					<th>list-container
			<tbody>
				<tr>
					<td style="border-right: thin solid">
						<pre>
* english one
		 OWT WERBEH *
* english three
		RUOF WERBEH *</pre>
					<td>
						<pre>
* english one
*    OWT WERBEH
* english three
*   RUOF WERBEH</pre>
		</table>
	</div>



<!-- ===================================================================== -->

<h2 id='auto-numbering'>
Automatic Numbering With Counters</h2>

	A <dfn export>counter</dfn> is a special concept
	used, among other things, to automatically number list items in CSS.
	Every element has a collection of zero or more counters,
	which are inherited through the document tree in a way similar to inherited property values.
	They are created and manipulated with the 'counter-increment', 'counter-set' and 'counter-reset' properties,
	and used with the ''counter()'' and ''counters()'' functions.
	Counters have a name,
	an integer value,
	a creator element,
	and possibly another counter nested inside themselves.

<h3 id='counter-properties'>
Manipulating Counters: the 'counter-increment', 'counter-set' and 'counter-reset' properties</h2>

	<pre class="propdef">
	Name: counter-reset
	Value: [ <<custom-ident>> <<integer>>? ]+ | none
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: all
	Computed value: specified value
	</pre>

	The 'counter-reset' property <a lt="create a new counter">creates new counters</a> on an element.
	Its values are defined as follows:

	<dl dfn-type=value dfn-for=counter-reset>
		<dt><dfn>none</dfn>
		<dd>
			This element does not create any new counters.

		<dt><dfn><<custom-ident>> <<integer>>?</dfn>
		<dd>
			The element <a lt="create a new counter">creates one or more new counters</a>.
			Each <<custom-ident>> names a new counter to be created.

			If an <<integer>> is provided after an <<custom-ident>>,
			the starting value of the new counter is that integer.
			Otherwise, the starting value of the new counter is ''0''.

			Implementations may have implementation-specific limits
			on the maximum or minimum value of a counter.
			If an increment would push the counter's value beyond these limits,
			the increment must be ignored,
			and the counter's value remain unchanged.
	</dl>

	<pre class='propdef'>
	Name: counter-set
	Value: [ <<custom-ident>> <<integer>>? ]+ | none
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: all
	Computed value: specified value
	</pre>

	<pre class='propdef'>
	Name: counter-increment
	Value: [ <<custom-ident>> <<integer>>? ]+ | none
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: n/a
	Media: all
	Computed value: specified value
	</pre>

	The 'counter-set' and 'counter-increment' properties
	manipulate the value of existing counters.
	They only create new counters if there is no counter of the given name on the element yet.
	Their values are defined as follows:

	<dl dfn-type=value dfn-for="counter-set counter-increment">
		<dt><dfn>none</dfn>
		<dd>
			This element does not alter the value of any counters.

		<dt><dfn><<custom-ident>> <<integer>>?</dfn>
		<dd>
			The element alters the value of one or more counters on it.
			If there is not currently a counter of the given name on the element,
			the element <a lt="create a new counter">creates a new counter</a> of the given name
			with a starting value of ''0''
			(though it may then immediately set or increment that value to something different).

			If an <<integer>> is provided after an <<custom-ident>>,
			it sets the innermost counter of the given name's value to that integer (for 'counter-set')
			or increments the value of the innermost counter of the given name by that integer (for 'counter-increment').
			Otherwise,
			the innermost counter of the given name's value is set to ''0'' (for 'counter-set')
			or incremented by ''1'' (for 'counter-increment').
	</dl>

	<div class="example">
		<p>This example shows a way to number chapters and sections with "Chapter 1", "1.1", "1.2", etc.

		<pre highlight=css>
			h1::before {
					content: "Chapter " counter(chapter) ". ";
					counter-increment: chapter;  /* Add 1 to chapter */
					counter-reset: section;      /* Set section to 0 */
			}
			h2::before {
					content: counter(chapter) "." counter(section) " ";
					counter-increment: section;
			}
		</pre>
	</div>

	Inheriting counters must be done <em>before</em> resetting counters,
	which must be done <em>before</em> setting counters,
	which must be done <em>before</em> incrementing counters,
	which must be done <em>before</em> using counters
	(for example, in the 'content' property).

	<div class='note' highlight=css>
		The counter properties follow the cascading rules as normal.
		Thus, due to cascading, the following style sheet:

		<div class='example'>
			<pre>
				h1 { counter-reset: section -1 }
				h1 { counter-reset: imagenum 99 }
			</pre>
		</div>

		will only reset ''imagenum''.
		To reset both counters,
		they have to be specified together:

		<div class='example'>
			<pre>H1 { counter-reset: section -1 imagenum 99 }</pre>
		</div>

		The same principles apply to the 'counter-set' and 'counter-increment' properties.
	</div>


<h3 id="creating-counters">
Creating and Inheriting Counters</h3>

	Every element has a (possibly empty) set of counters.
	Like many other CSS values,
	an element can inherit counters from another element.
	However, unlike other CSS values,
	the method that counters are inherited is somewhat complex.
	A counter and its value are inherited <em>separately</em>,
	possibly from different elements.

	If an element has a previous sibling,
	it must inherit all of the sibling's counters.
	Otherwise, if the element has a parent,
	it must inherit all of the parent's counters.
	Otherwise, the element must have an empty set of counters.

	The element then inherits counter <em>values</em>
	from the immediately preceding element <strong>in document order</strong>.
	This must be done by examining the set of counters that the immediately preceding element has,
	and, for every counter that exists in both the element's set and the preceding element's set,
	giving the element's counter the same value.
	(If an element is the first element in the document,
	and thus has no immediately preceding element,
	it also doesn't have a parent or a previous sibling,
	and thus no counters to begin with.)

	<div class='example' id='counter-inheritance-example'>
		Take the following code as an example:

		<pre highlight=html>
			&lt;ul style='counter-reset: example 0;'>
				<b class='foo'>&lt;li id='foo' style='counter-increment: example;'></b>
					foo
					<b class='bar'>&lt;div id='bar' style='counter-increment: example;'>bar&lt;/div></b>
				&lt;/li>
				<b class='baz'>&lt;li id='baz'></b>
					baz
				&lt;/li>
			&lt;/ul>
		</pre>

		Recall that "in document order" turns a document tree into an ordered list,
		where an element comes before its children,
		and its children come before its next sibling.
		In other words,
		for a language like HTML,
		its the order in which the parser encounters start tags as it reads the document.

		In here, the <code>&lt;ul></code> element establishes a new counter named "example",
		and sets its value to 0.
		The <b class='foo'>"foo"</b> element, being the first child of the <code>&lt;ul></code>,
		inherits this counter.
		Its parent is also its immediately preceding element in document order,
		so it inherits the value 0 with it,
		and then immediately increments the value to 1.

		The same happens with the <b class='bar'>"bar"</b> element.
		It inherits the "example" counter from <b class='foo'>"foo"</b>,
		and inherits the value 1 from it as well
		and increments it to 2.

		However, the <b class='baz'>"baz"</b> element is a bit different.
		It inherits the "example" counter from the <b class='foo'>"foo"</b> element,
		its previous sibling.
		However, rather than inheriting the value 1 from <b class='foo'>"foo"</b> along with the counter,
		in inherits the value 2 from <b class='bar'>"bar"</b>, the previous element in document order.

		This behavior allows a single counter to be used throughout a document,
		continuously incrementing,
		without the author having to worry about the nested structure of their document.
	</div>
	<style>
	#counter-inheritance-example b.foo { color: hsl(0, 80%, 40%); }
	#counter-inheritance-example b.bar { color: hsl(120, 80%, 30%); }
	#counter-inheritance-example b.baz { color: hsl(240, 80%, 50%); }
	</style>

	Elements can create additional counters on themselves,
	which can then be passed onto siblings or children.
	To <dfn>create a new counter</dfn>,
	specify an element that's creating it,
	a name,
	and a starting value.
	The effect depends on what other counters of that name exist on the element:

	<ul>
		<li>
			If no counters of that name exist on the element,
			create a new counter with that name on the element.

		<li>
			Otherwise, if a counter of that name exists on the element,
			and it was created by a preceding sibling,
			replace the innermost counter of that name on the element
			with a newly-created counter with that name.

		<li>
			Otherwise, create a new counter with that name
			and nest it inside of the innermost counter with that name.
	</ul>

	Regardless, the value of the new counter is set to the provided starting value.

<h3 id='nested-counters'>
Nested Counters</h3>

	Counters are "self-nesting";
	<a lt="create a new counter">creating a new counter</a> in an element
	which already has a counter with the same name
	simply creates a new counter of the same name,
	nested inside the existing counter.
	This is important for situations like lists in HTML,
	where lists can be nested inside lists to arbitrary depth.
	It would be impossible to define uniquely named counters for each level.
	As explained in a later section,
	the ''counter()'' function only uses the innermost counter of a given name on the element,
	but the ''counters()'' function uses all counters of a given name that contain the element.

	<div class="example">
		Thus, the following suffices to number nested list items.
		The result is very similar to that of setting ''display:list-item'' and ''list-style: inside'' on the LI element:

		<pre highlight=css>
			ol { counter-reset: item }
			li { display: block }
			li::before { content: counter(item) ". "; counter-increment: item }
		</pre>

		In this example,
		an <a element>ol</a> will create a counter,
		and all children of the <a element>ol</a> will refer to that counter.
	</div>


	<div class="example" id='counter-nesting-example'>

		If we denote the <var>n</var><sup>th</sup> instance of the "item" counter by item[<var>n</var>],
		then the following HTML fragment will use the indicated counters.
		(We assume the style sheet as given in the example above).

		<div class='ol'>
			<div class='ol'><code>&lt;ol></code> item[0] is created, set to 0
				<div class='li'><code>&lt;li></code> item[0] is incremented to 1</div>
				<div class='li'><code>&lt;li></code> item[0] is incremented to 2
					<div class='ol'><code>&lt;ol></code> item[1] is created, set to 0, nested in item[0]
						<div class='li'><code>&lt;li></code> item[1] is incremented to 1</div>
						<div class='li'><code>&lt;li></code> item[1] is incremented to 2</div>
						<div class='li'><code>&lt;li></code> item[1] is incremented to 3
							<div class='ol'><code>&lt;ol></code> item[2] is created, set to 0, nested in item[1]
								<div class='li'><code>&lt;li></code> item[2] is incremented to 1</div>
							</div>
						</div>
						<div class='li'><code>&lt;li></code> item[1] is incremented to 4
							<div class='ol'><code>&lt;ol></code> item[3] is created, set to 0, nested in item[1]
								<div class='li'><code>&lt;li></code> item[3] is incremented to 1</div>
							</div>
						</div>
						<div class='li'><code>&lt;li></code> item[1] is incremented to 5</div>
					</div>
				</div>
				<div class='li'><code>&lt;li></code> item[0] is incremented to 3</div>
				<div class='li'><code>&lt;li></code> item[0] is incremented to 4</div>
			</div>
			<div class='ol'><code>&lt;ol></code> item[4] is created, set to 0
				<div class='li'><code>&lt;li></code> item[4] is incremented to 1</div>
				<div class='li'><code>&lt;li></code> item[4] is incremented to 2</div>
			</div>
		</div>
		<style>
		#counter-nesting-example .ol { background: rgba(0,0,0,.1); margin: .5em 0; padding: .2em .5em; }
		#counter-nesting-example .li > .ol { margin: 0 0 0 1em; }
		#counter-nesting-example .li { list-style: none; margin-left: 1em;}
		</style>
	</div>


<h3 id='counters-without-boxes'>
Counters in elements that do not generate boxes</h3>

	An element that does not generate a box
	(for example, an element with 'display' set to ''display/none'', or a pseudo-element with 'content' set to ''content/none'')
	cannot set, reset, or increment  a counter.
	The counter properties are still valid on such an element,
	but they must have no effect.

	<div class="example">
			For example, with the following style sheet,
			H2s with class "secret" do not increment ''count2''.

		<pre highlight=css>
			h2 { counter-increment: count2; }
			h2.secret { display: none; }
		</pre>
	</div>

	Other methods of "hiding" elements,
	such as setting 'visibility' to ''visibility/hidden'',
	still cause the element to generate a box,
	and so do not apply here.


<h3 id='counter-functions'>
Outputting Counters: the ''counter()'' and ''counters()'' functions</h3>

	Counters have no visible effect by themselves,
	but their values can be used with the ''counter()'' and ''counters()'' functions.
	This happens automatically in ''::marker'' pseudo-elements,
	but can be used by an author anywhere that accepts a <<string>>.  Their syntax is:

	<pre>
		<dfn>counter()</dfn>  =  counter( <<ident>>, [ <<counter-style>> | none ]? )
		<dfn>counters()</dfn> = counters( <<ident>>, <<string>>, [ <<counter-style>> | none ]? )
	</pre>

	For both functions, the first argument represents the name of a counter,
	and if the last argument is omitted it defaults to ''decimal''.

	A ''counter()'' represents a <<string>>,
	obtained as follows:

	<ul>
		<li>
			If the second argument to the function is <css>none</css>,
			the function represents the empty string.

		<li>
			Otherwise, the function represents the string returned when one <a lt="generate a counter representation">generates a counter representation</a>
			for the value of the innermost counter of that name on the element
			(or ''0'' if the element has no counter of that name)
			using the <<counter-style>> specified by the second argument.
	</ul>

	<div class="example">
		<pre>
			H1::before        { content: counter(chno, upper-latin) ". " }
			/* Generates headings like "A. A History of Discontent" */

			H2::before        { content: counter(section, upper-roman) " - " }
			/* Generates headings like "II - The Discontent Part" */

			BLOCKQUOTE::after { content: " [" counter(bq, decimal) "]" }
			/* Generates blockquotes that end like "... [3]" */

			DIV.note::before  { content: counter(notecntr, disc) " " }
			/* Simply generates a bullet before every div.note */

			P::before         { content: counter(p, none) }
			/* inserts nothing */
		</pre>
	</div>

	A ''counters()'' represents a <<string>>,
	obtained as follows:

	<ul>
		<li>
			If the third argument to the function is <css>none</css>,
			the function represents the empty string.

		<li>
			Otherwise, if the element has no counters of that name,
			the function represents the string returned when one <a lt="generate a counter representation">generates a counter representation</a>
			for ''0''
			using the <<counter-style>> specified by the third argument.

		<li>
			Otherwise, if the element has a single counter of that name,
			the function represents the string returned when one <a lt="generate a counter representation">generates a counter representation</a>
			for that counter's value
			using the <<counter-style>> specified by the third argument.

		<li>
			Otherwise,
			<a>generate a counter representation</a>
			for the values of all counters of the given name on the element
			using the <<counter-style>> specified by the third argument.
			Sort the resulting strings by the nesting depth of the counters they were generated from,
			with the outermost counter first and the innermost last.
			Join the list into a single string,
			inserting the <<string>> specified by the second argument between each item in the list.
			The function represents the string thus produced.
	</ul>

	Issue: Counter representations don't have to be strings,
	they can be images sometimes instead.
	What to do?

	<div class='example'>
		The following example shows a simple use of the ''counters()'' function:

		<pre highlight=html>
			&lt;ul>
				&lt;li>one&lt;/li>
				&lt;li>two
					&lt;ul>
						&lt;li>nested one&lt;/li>
						&lt;li>nested two&lt;/li>
					&lt;/ul>
				&lt;/li>
				&lt;li>three&lt;/li>
			&lt;/ul>
			&lt;style>
			ul { counter-reset: list-item; }
			li { counter-increment: list-item; }
			li::marker { content: '(' counters(list-item,'.') ') '; }
			&lt;/style>
		</pre>

		The preceding document should render something like this:

		<pre>
			(1) one
			(2) two
				 (2.1) nested one
				 (2.2) nested two
			(3) three
		</pre>
	</div>

	<div class='example'>
		Because counters inherit to siblings as well,
		they can be used to number headings and subheadings,
		which aren't nested within each other.
		Unfortunately,
		this prevents the use of ''counters()'' as counters from siblings don't nest,
		but one can create multiple counters and manually concatenate them instead:

		<pre highlight=html>
			&lt;h1>First H1&lt;/h1>
			...
			&lt;h2>First H2 in H1&lt;/h2>
			...
			&lt;h2>Second H2 in H1&lt;/h2>
			...
			&lt;h3>First H3 in H2&lt;/h3>
			...
			&lt;h1>Second H1&lt;/h1>
			...
			&lt;h2>First H2 in H1&lt;/h2>
			...
			&lt;style>
			body { counter-reset: h1 h2 h3; }
			h1   { counter-increment: h1; counter-reset: h2 h3;}
			h2   { counter-increment: h2; counter-reset:    h3; }
			h3   { counter-increment: h3; }
			h1::before { content: counter(h1,upper-alpha) ' '; }
			h2::before { content: counter(h1,upper-alpha) '.'
														counter(h2,decimal) ' '; }
			h3::before { content: counter(h1,upper-alpha) '.'
			                      counter(h2,decimal) '.'
			                      counter(h3,lower-roman) ' '; }
			&lt;/style>
		</pre>

		The preceding document should render something like this:

		<pre>
			A First H1
			...
			A.1 First H2 in H1
			...
			A.2 Second H2 in H1
			...
			A.2.i First H3 in H2
			...
			B Second H1
			...
			B.1 First H2 in H1
			...
		</pre>
	</div>

	<div class=issue>
		Counters are sometimes useful for things other than printing markers.
		In general, they provide the ability to number elements in sequence,
		which can be useful for other properties to reference.
		For example, using 'order' to put an element between two other specific elements
		currently requires you to explicitly put 'order' on every element before and/or after the desired insertion point.
		If you can set the 'order' value of everything to a counter, tho,
		you can more easily insert an element into an arbitrary spot between two others.

		Other use-cases involve nested or sibling elements with transforms that are meant to be slightly different from each other.
		Today you have to use a preprocessor to do this in a reasonable way,
		but a counter would make it work well in "plain" CSS.

		(You can built up successive values in the nested case today
		by using <a>custom properties</a> and stacking up nested ''calc()''s,
		but this is a *little bit* clumsy,
		and doesn't work for siblings.)

		Suggestion is to add a <css>counter-value(<<ident>>)</css> function,
		which returns the value of the named counter as an integer,
		rather than returning a string.
	</div>



<h2 id='ua-stylesheet'>
Appendix A: Sample Style Sheet For HTML</h2>

	<em>This section is informative, not normative.
	HTML itself defines the actual default properties that apply to HTML lists.</em>

	<pre>
		/* Set up list items */
		li {
			display: list-item;
			/* counter-increment: list-item; (implied by display: list-item) */
		}

		/* Set up ol and ul so that they reset the list-item counter */
		ol, ul {
			counter-reset: list-item;
		}

		/* Default list style types for ordered lists */
		ol {
			list-style-type: decimal;
		}

		/* Default list style types for unordered lists up to 3 deep */
		ul { list-style-type: disc; }
		ul ul { list-style-type: square; }
		ul ul ul { list-style-type: circle; }
		/* Alternately, if Values & Units Level 3 is supported, replace
			 the above three lines with: */
		ul { list-style-type: disc; }
		ul ul { list-style-type: cycle(disc, square, circle); }

		/* The type attribute on ol and ul elements */
		ul[type="disc"] { list-style-type: disc; }
		ul[type="circle"] { list-style-type: circle; }
		ul[type="square"] { list-style-type: square; }
		ol[type="1"] { list-style-type: decimal; }
		ol[type="a"] { list-style-type: lower-alpha; }
		ol[type="A"] { list-style-type: upper-alpha; }
		ol[type="i"] { list-style-type: lower-roman; }
		ol[type="I"] { list-style-type: upper-roman; }

		/* The start attribute on ol elements */
		ol[start] {
			counter-reset: list-item calc(attr(start integer, 1) - 1);
		}

		/* The value attribute on li elements */
		li[value] {
			counter-set: list-item attr(value integer, 1);
			counter-increment: none; /* Turn off default increase */
		}

		/* Handling reversed lists */
		ol[reversed] {
			counter-reset: list-item calc(attr(start integer, **magic**) + 1);
			/* Where **magic** is the number of child &lt;li> elements. */
		}
		ol[reversed] > li {
			counter-increment: list-item -1;
		}

		/* Box Model Rules */
		ol, ul {
			display: block;
			margin: 1em 0;
			marker-side: list-container;
		}

		ol:dir(ltr), ul:dir(ltr) {
			padding-left: 40px;
		}
		ol:dir(rtl), ul:dir(rtl) {
			padding-right: 40px;
		}

		ol ol, ol ul, ul ul, ul ol {
			margin-top: 0;
			margin-bottom: 0;
		}

		li {
			text-align: match-parent;
		}

		li::marker {
			display: inline;
			text-align: end;
			unicode-bidi: isolate;
			/* 'position' computes to "static" or "marker" depending on list-style-position */
		}
	</pre>


<h2 class="no-num" id="acknowledgments">
Acknowledgments</h2>

	<p>The following people and documentation they wrote were very useful
	for defining the numbering systems: <!-- alphabetical by full name -->
	Alexander Savenkov,
	Arron Eicholz,
	Aryeh Gregor,
	Frank Tang,
	Jonathan Rosenne,
	Karl Ove Hufthammer,
	Musheg Arakelyan,
	Nariné Renard Karapetyan,
	Randall Bart,
	Richard Ishida,
	Simon Montagu (Mozilla, smontagu@smontagu.org)


<h2 class="no-num" id="changes">
Changes From CSS2.1</h2>

	<p>As described in the introduction section, there are significant changes in this module when
	compared to CSS2.1.

	<ol>
		<li>The ''::marker'' pseudo-element has been introduced to allow styling of the list marker directly.

		<li>The ''marker'' value for 'position' has been added, to allow elements in the document to position themselves similarly to how markers do.

		<li>'list-style-type' now accepts a <<string>>.

		<li>The list-item predefined counter identifier has been introduced.
	</ol>

