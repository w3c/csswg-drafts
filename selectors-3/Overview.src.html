<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset=utf8>
  <title>Selectors Level 3</title>
  <link href="../default.css" type="text/css" rel="stylesheet">
  <link href="https://www.w3.org/StyleSheets/TR/W3C-WD.css" type="text/css" rel="stylesheet">
  <script defer="" src="https://test.csswg.org/harness/annotate.js#!selectors-3_dev/selectors-3" type="text/javascript"></script>
 </head>
 <body>
  <div class="head">
   <!--logo-->

   <h1 id=title>Selectors Level 3</h1>

   <h2 class="no-num no-toc">[LONGSTATUS] [DATE]</h2>

   <dl>

    <dt>This version:

    <dd>
    <!-- <a href="[VERSION]">
             https://www.w3.org/TR/[YEAR]/REC-[SHORTNAME]-[CDATE]</a> -->
    <a href="https://drafts.csswg.org/selectors3">
             https://drafts.csswg.org/selectors3</a>

    <dt>Latest version:

    <dd><a href="https://www.w3.org/TR/css3-selectors">
                 https://www.w3.org/TR/css3-selectors</a>

    <dt>Previous version:

    <dd><a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/">
                 http://www.w3.org/TR/2011/REC-css3-selectors-20110929/</a>

    <dt>Feedback:
      <dd><a href="mailto:www-style@w3.org?subject=%5Bselectors3%5D%20feedback">www-style@w3.org</a>
          with subject line &ldquo;<kbd>[selectors3] <var>&hellip; message topic &hellip;</var></kbd>&rdquo;
          (<a rel="discussion" href="http://lists.w3.org/Archives/Public/www-style/">archives</a>)

    <dt id="editors-list">Editors:</dt>

    <dd class="vcard"><a lang="tr" class="url fn" href="http://www.tantek.com/">Tantek &Ccedil;elik</a> (Invited Expert)

    <dd class="vcard"><a class="url fn" href="http://fantasai.inkedblade.net/contact">Elika J. Etemad</a> (Invited Expert)

    <dd class="vcard"><span class="fn">Daniel Glazman</span> (Disruptive Innovations SARL)</dd>

    <dd class="vcard"><a href="mailto:ian@hixie.ch" class="url fn">Ian Hickson</a> (<span
    class="company"><a href="http://www.google.com/">Google</a></span>)

    <dd class="vcard"><span class="fn">Peter Linss</span> (former editor, <span class="company"><a
    href="http://www.netscape.com/">Netscape/AOL</a></span>)

    <dd class="vcard"><span class="fn">John Williams</span> (former editor, <span class="company"><a
    href="http://www.quark.com/">Quark, Inc.</a></span>)

   </dl>

   <!--copyright-->

   <hr title="Separator for header">

  </div>

  <h2 class="no-num no-toc" id=abstract>Abstract</h2>

  <p><em>Selectors</em> are patterns that match against elements in a
  tree, and as such form one of several technologies that can be used
  to select nodes in an XML document. Selectors have been optimized for
  use with HTML and XML, and are designed to be usable in
  performance-critical code.</p>

  <p><abbr title="Cascading Style Sheets">CSS</abbr> (Cascading
  Style Sheets) is a language for describing the rendering of <abbr
  title="Hypertext Markup Language">HTML</abbr> and <abbr
  title="Extensible Markup Language">XML</abbr> documents on
  screen, on paper, in speech, etc. CSS uses Selectors for binding
  style properties to elements in the document.</p>

  <p>This document describes the selectors that already exist in <abbr
  title="CSS level 1">CSS1</abbr> [[CSS1]] and <abbr title="CSS level
  2">CSS2</abbr> [[!CSS21]], and further introduces new selectors for
  <abbr title="CSS level 3">CSS3</abbr> and other languages that may
  need them.</p>

  <p>Selectors define the following function:</p>

  <pre>expression &#x2217; element &rarr; boolean</pre>

  <p>That is, given an element and a selector, this specification
  defines whether that element matches the selector.</p>

  <p>These expressions can also be used, for instance, to select a set
  of elements, or a single element from a set of elements, by
  evaluating the expression across all the elements in a
  subtree. <abbr title="Simple Tree Transformation
  Sheets">STTS</abbr> (Simple Tree Transformation Sheets), a
  language for transforming XML trees, uses this mechanism. [[STTS3]]</p>

  <h2 class="no-num no-toc" id=status>Status of this document</h2>

  <!--status-->

  <p>This Candidate Recommendation is identical to the
      <a href="http://www.w3.org/TR/2011/REC-css3-selectors-20110929/">
        29 September 2011 W3C Recommendation</a> except that the
        <a href="https://www.w3.org/Style/2011/REC-css3-selectors-20110929-errata.html">errata</a>
        have been incorporated, as noted in the <a href="#changes">changes section</a>.
        One of these is a technical change; a
        <a href="http://test.csswg.org/harness/test/selectors-3_dev/single/selector-structural-pseudo-root/format/html5/">
        test</a> is available for that change, and is
        <a href="http://test.csswg.org/harness/details/selectors-3_dev/selector-structural-pseudo-root/">
        passed by two or more implementations</a>.
      </p>

  <p>A separate <a href="https://test.csswg.org/harness/suite/selectors-3_dev/">test
  suite</a> and <a
  href="https://test.csswg.org/harness/results/selectors-3_dev/grouped/">
  implementation report</a> is available.

  <nav id="toc">
  <h2 class="no-num no-toc" id="contents">Table of contents</h2>
  <!--toc-->
  </nav>

  <h2 id=context>Introduction</h2>

  <p>Selectors Level 1 and Selectors Level 2 are defined as the subsets of selector
    functionality defined in the <a href="https://www.w3.org/TR/REC-CSS1">CSS1</a>
    and <a href="https://www.w3.org/TR/CSS21/">CSS2.1</a> specifications,
    respectively.</p>

  <h3 id=dependencies>Dependencies</h3>

  <p>Some features of this specification are specific to CSS, or have
  particular limitations or rules specific to CSS. In this
  specification, these have been described in terms of CSS2.1. [[!CSS21]]</p>

  <h3 id=terminology>Terminology</h3>

  <p>All of the text of this specification is normative except
  examples, notes, and sections explicitly marked as
  non-normative.</p>

  <p>Additional terminology is defined in the
  <a href="https://www.w3.org/TR/CSS21/conform.html#defs">Definitions</a>
  section of [[!CSS21]].
  Examples of document source code and fragments are given in XML
  [[XML10]] or HTML [[HTML401]][[HTML5]]
  syntax.

  <h3 id=changesFromCSS2>Changes from CSS2</h3>

  <p><em>This section is non-normative.</em></p>

  <p>The main differences between the selectors in CSS2 and those in
  Selectors are:

  <ul>

   <li>the list of basic definitions (selector, group of selectors,
   simple selector, etc.) has been changed; in particular, what was
   referred to in CSS2 as a simple selector is now called a sequence
   of simple selectors, and the term "simple selector" is now used for
   the components of this sequence</li>

   <li>an optional namespace component is now allowed in element type
   selectors, the universal selector and attribute selectors</li>

   <li>a <a href="#general-sibling-combinators">new combinator</a> has been introduced</li>

   <li>new simple selectors including substring matching attribute
   selectors, and new pseudo-classes</li>

   <li>new pseudo-elements, and introduction of the "::" convention
   for pseudo-elements</li>

   <li>the grammar has been rewritten</li>

   <li>profiles to be added to specifications integrating Selectors
   and defining the set of selectors which is actually supported by
   each specification</li>

   <li>Selectors are now a CSS3 Module and an independent
   specification; other specifications can now refer to this document
   independently of CSS</li>

   <li>the specification now has its own test suite</li>

  </ul>

<h2 id=selectors>Selectors</h2>

<p><em>This section is non-normative, as it merely summarizes the
following sections.</em></p>

<p>A Selector represents a structure. This structure can be used as a
condition (e.g. in a CSS rule) that determines which elements a
selector matches in the document tree, or as a flat description of the
HTML or XML fragment corresponding to that structure.</p>

<p>Selectors may range from simple element names to rich contextual
representations.</p>

<p>The following table summarizes the Selector syntax:</p>

<table class="selectorsReview">
  <thead>
  <tr>
    <th class="pattern">Pattern</th>
    <th class="meaning">Represents</th>
    <th class="described">Description</th>
    <th class="origin">Level</th></tr>
  <tbody>
  <tr>
    <td class="pattern">*</td>
    <td class="meaning">any element</td>
    <td class="described"><a
      href="#universal-selector">Universal
      selector</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E</td>
    <td class="meaning">an element of type E</td>
    <td class="described"><a
      href="#type-selectors">Type selector</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E[foo]</td>
    <td class="meaning">an E element with a "foo" attribute</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value is exactly
      equal to "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo~="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value is a list of
      whitespace-separated values, one of which is exactly equal to "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E[foo^="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value begins exactly
      with the string "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo$="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value ends exactly
      with the string "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo*="bar"]</td>
    <td class="meaning">an E element whose "foo" attribute value contains the
      substring "bar"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E[foo|="en"]</td>
    <td class="meaning">an E element whose "foo" attribute has a hyphen-separated
      list of values beginning (from the left) with "en"</td>
    <td class="described"><a
      href="#attribute-selectors">Attribute
      selectors</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:root</td>
    <td class="meaning">an E element, root of the document</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-child(n)</td>
    <td class="meaning">an E element, the n-th child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-last-child(n)</td>
    <td class="meaning">an E element, the n-th child of its parent, counting
      from the last one</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-of-type(n)</td>
    <td class="meaning">an E element, the n-th sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:nth-last-of-type(n)</td>
    <td class="meaning">an E element, the n-th sibling of its type, counting
      from the last one</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:first-child</td>
    <td class="meaning">an E element, first child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:last-child</td>
    <td class="meaning">an E element, last child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:first-of-type</td>
    <td class="meaning">an E element, first sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:last-of-type</td>
    <td class="meaning">an E element, last sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:only-child</td>
    <td class="meaning">an E element, only child of its parent</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:only-of-type</td>
    <td class="meaning">an E element, only sibling of its type</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:empty</td>
    <td class="meaning">an E element that has no children (including text
    nodes)</td>
    <td class="described"><a
      href="#structural-pseudos">Structural
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:link<br>E:visited</td>
    <td class="meaning">an E element being the source anchor of a hyperlink of
      which the target is not yet visited (:link) or already visited
    (:visited)</td>
    <td class="described"><a
      href="#link">The link
      pseudo-classes</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E:active<br>E:hover<br>E:focus</td>
    <td class="meaning">an E element during certain user actions</td>
    <td class="described"><a
      href="#useraction-pseudos">The user
      action pseudo-classes</a></td>
    <td class="origin">1 and 2</td></tr>
  <tr>
    <td class="pattern">E:target</td>
    <td class="meaning">an E element being the target of the referring URI</td>
    <td class="described"><a
      href="#target-pseudo">The target
      pseudo-class</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:lang(fr)</td>
    <td class="meaning">an element of type E in language "fr" (the document
      language specifies how language is determined)</td>
    <td class="described"><a
      href="#lang-pseudo">The :lang()
      pseudo-class</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E:enabled<br>E:disabled</td>
    <td class="meaning">a user interface element E which is enabled or
    disabled</td>
    <td class="described"><a
      href="#UIstates">The UI element states
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E:checked<!--<br>E:indeterminate--></td>
    <td class="meaning">a user interface element E which is checked<!-- or in an
      indeterminate state--> (for instance a radio-button or checkbox)</td>
    <td class="described"><a
      href="#UIstates">The UI element states
      pseudo-classes</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E::first-line</td>
    <td class="meaning">the first formatted line of an E element</td>
    <td class="described"><a
      href="#first-line">The ::first-line
      pseudo-element</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E::first-letter</td>
    <td class="meaning">the first formatted letter of an E element</td>
    <td class="described"><a
      href="#first-letter">The ::first-letter
      pseudo-element</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E::before</td>
    <td class="meaning">generated content before an E element</td>
    <td class="described"><a
      href="#gen-content">The ::before
      pseudo-element</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E::after</td>
    <td class="meaning">generated content after an E element</td>
    <td class="described"><a
      href="#gen-content">The ::after
      pseudo-element</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E.warning</td>
    <td class="meaning">an E element whose class is
"warning" (the document language specifies how class is determined).</td>
    <td class="described"><a
      href="#class-html">Class
    selectors</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E#myid</td>
    <td class="meaning">an E element with ID equal to "myid".</td>
    <td class="described"><a
      href="#id-selectors">ID
    selectors</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E:not(s)</td>
    <td class="meaning">an E element that does not match simple selector s</td>
    <td class="described"><a
      href="#negation">Negation
      pseudo-class</a></td>
    <td class="origin">3</td></tr>
  <tr>
    <td class="pattern">E F</td>
    <td class="meaning">an F element descendant of an E element</td>
    <td class="described"><a
      href="#descendant-combinators">Descendant
      combinator</a></td>
    <td class="origin">1</td></tr>
  <tr>
    <td class="pattern">E &gt; F</td>
    <td class="meaning">an F element child of an E element</td>
    <td class="described"><a
      href="#child-combinators">Child
      combinator</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E + F</td>
    <td class="meaning">an F element immediately preceded by an E element</td>
    <td class="described"><a
      href="#adjacent-sibling-combinators">Next-sibling combinator</a></td>
    <td class="origin">2</td></tr>
  <tr>
    <td class="pattern">E ~ F</td>
    <td class="meaning">an F element preceded by an E element</td>
    <td class="described"><a
      href="#general-sibling-combinators">Subsequent-sibling combinator</a></td>
    <td class="origin">3</td></tr></tbody></table>

<h2 id=casesens>Case sensitivity</h2>

<p>All Selectors syntax is case-insensitive within the ASCII range
(i.e. [a-z]  and [A-Z] are equivalent), except for parts that are
not under the control of Selectors. The case sensitivity of document
language element names, attribute names, and attribute values in
selectors depends on the document language. For example, in HTML,
element names are case-insensitive, but in XML, they are
case-sensitive. Case sensitivity of namespace prefixes is defined in
[[!CSS3NAMESPACE]].</p>

<h2 id=selector-syntax>Selector syntax</h2>

<p>A <dfn>selector</dfn> is a chain of one
or more <a href="#sequence">sequences of simple selectors</a>
separated by <a href="#combinators">combinators</a>.  One <a
href="#pseudo-elements">pseudo-element</a> may be appended to the last
sequence of simple selectors in a selector.</p>

<p>A <dfn><a name=sequence>sequence of simple selectors</a></dfn>
is a chain of <a href="#simple-selectors-dfn">simple selectors</a>
that are not separated by a <a href="#combinators">combinator</a>. It
always begins with a <a href="#type-selectors">type selector</a> or a
<a href="#universal-selector">universal selector</a>. No other type
selector or universal selector is allowed in the sequence.</p>

<p>A <dfn><a name=simple-selectors-dfn></a><a
href="#simple-selectors">simple selector</a></dfn> is either a <a
href="#type-selectors">type selector</a>, <a
href="#universal-selector">universal selector</a>, <a
href="#attribute-selectors">attribute selector</a>, <a
href="#class-html">class selector</a>, <a
href="#id-selectors">ID selector</a>, or <a
href="#pseudo-classes">pseudo-class</a>.</p>

<p><dfn>Combinators</dfn> are: whitespace, &quot;greater-than
sign&quot; (U+003E, <code>&gt;</code>), &quot;plus sign&quot; (U+002B,
<code>+</code>) and &quot;tilde&quot; (U+007E, <code>~</code>).  White
space may appear between a combinator and the simple selectors around
it. <a name=whitespace></a>Only the characters "space" (U+0020), "tab"
(U+0009), "line feed" (U+000A), "carriage return" (U+000D), and "form
feed" (U+000C) can occur in whitespace. Other space-like characters,
such as "em-space" (U+2003) and "ideographic space" (U+3000), are
never part of whitespace.</p>

<p>The elements of a document tree that are represented by a selector
are the <dfn><a name=subject></a>subjects of the selector</dfn>. A
selector consisting of a single sequence of simple selectors
represents any element satisfying its requirements. Prepending another
sequence of simple selectors and a combinator to a sequence imposes
additional matching constraints, so the subjects of a selector are
always a subset of the elements represented by the last sequence of
simple selectors.</p>

<p>An empty selector, containing no sequence of simple selectors and
no pseudo-element, is an <a href="#Conformance">invalid
selector</a>.</p>

<p>Characters in Selectors can be escaped with a backslash according
to the same <a href="https://www.w3.org/TR/CSS21/syndata.html#characters">escaping
rules</a> as CSS. [[!CSS21]].</p>

<p id="nsdecl">Certain selectors support namespace prefixes. The
mechanism by which namespace prefixes are <dfn>declared</dfn> should
be specified by the language that uses Selectors. If the language does
not specify a namespace prefix declaration mechanism, then no prefixes
are declared. In CSS, namespace prefixes are declared with the
<a href="https://www.w3.org/TR/css3-namespace/#declaration"><code>@namespace</code></a>
rule. [[!CSS3NAMESPACE]]</p>


<h2 id=grouping>Groups of selectors</h2>

<p>A comma-separated list of selectors represents the union of all
elements selected by each of the individual selectors in the list.
(A comma is U+002C.) For example, in CSS when several selectors share
the same declarations, they may be grouped into a comma-separated
list. White space may appear before and/or after the comma.</p>

<div class="example">
<p>CSS example:</p>
<p>In this example, we condense three rules with identical
declarations into one. Thus,</p>
<pre>h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>
<p>is equivalent to:</p>
<pre>h1, h2, h3 { font-family: sans-serif }</pre>
</div>

<p><strong>Warning</strong>: the equivalence is true in this example
because all the selectors are valid selectors. If just one of these
selectors were invalid, the entire group of selectors would be
invalid. This would invalidate the rule for all three heading
elements, whereas in the former case only one of the three individual
heading rules would be invalidated.</p>

<div class="example">
<p>Invalid CSS example:</p>
<pre>h1 { font-family: sans-serif }
h2..foo { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>
<p>is not equivalent to:</p>
<pre>h1, h2..foo, h3 { font-family: sans-serif }</pre>
<p>because the above selector (<code>h1, h2..foo, h3</code>)
is entirely invalid and the entire style rule is dropped. (When
the selectors are not grouped, only the rule for <code>h2..foo</code>
is dropped.)</p>
</div>

<h2 id=simple-selectors>Simple selectors</h2>

<h3 id=type-selectors>Type selector</h3>

<p>A <dfn>type selector</dfn> is the name of a document language
element type written using the syntax of
<a href="https://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
names</a> [[!CSS3NAMESPACE]]. A type selector represents
an instance of the element type in the document tree. </p>

<div class="example">
 <p>Example:</p>
 <p>The following selector represents an <code>h1</code> element in the document tree:</p>
 <pre>h1</pre>
</div>


<h4 id=typenmsp>Type selectors and namespaces</h4>

<p>Type selectors allow an optional namespace component: a namespace
prefix that has been previously <a href="#nsdecl">declared</a> may be
prepended to the element name separated by the namespace separator
&quot;vertical bar&quot; (U+007C, <code>|</code>). (See, e.g., [[XML-NAMES]] for the use of namespaces in
XML.)</p>

<p>The namespace component may be left empty (no prefix before the
namespace separator) to indicate that the selector is only to
represent elements with no namespace.</p>

<p>An asterisk may be used for the namespace prefix, indicating that
the selector represents elements in any namespace (including elements
with no namespace).</p>

<p>Element type selectors that have no namespace component (no
namespace separator) represent elements without regard to the
element's namespace (equivalent to "<code>*|</code>") unless a default
namespace has been <a href="#nsdecl">declared</a>  for namespaced selectors (e.g. in CSS, in
the style sheet). If a default namespace has been declared, such
selectors will represent only elements in the default namespace.</p>

<p>A type selector containing a namespace prefix that has not been
previously <a href="#nsdecl">declared</a> for namespaced selectors is
an <a href="#Conformance">invalid</a> selector.</p>

<p>In a namespace-aware client, the name part of element type
selectors (the part after the namespace separator, if it is present)
will only match against the <a
href="https://www.w3.org/TR/REC-xml-names/#NT-LocalPart">local part</a>
of the element's <a
href="https://www.w3.org/TR/REC-xml-names/#ns-qualnames">qualified
name</a>.</p>

<p>In summary:</p>

<dl>
  <dt><code>ns|E</code></dt>
  <dd>elements with name E in namespace ns</dd>
  <dt><code>*|E</code></dt>
  <dd>elements with name E in any namespace, including those without a
  namespace</dd>
  <dt><code>|E</code></dt>
  <dd>elements with name E without a namespace</dd>
  <dt><code>E</code></dt>
  <dd>if no default namespace has been <a href="#nsdecl">declared</a>  for selectors, this is
  equivalent to *|E.  Otherwise it is equivalent to ns|E where ns is
  the default namespace.</dd>
</dl>

<div class="example">
 <p>CSS examples:</p>

 <pre>@namespace foo url(http://www.example.com);
 foo|h1 { color: blue }  /* first rule */
 foo|* { color: yellow } /* second rule */
 |h1 { color: red }      /* ...*/
 *|h1 { color: green }
 h1 { color: green }</pre>

 <p>The first rule (not counting the <code>@namespace</code> at-rule)
 will match only <code>h1</code> elements in the
 "http://www.example.com" namespace.</p>

 <p>The second rule will match all elements in the
 "http://www.example.com" namespace.</p>

 <p>The third rule will match only <code>h1</code> elements with
 no namespace.</p>

 <p>The fourth rule will match <code>h1</code> elements in any
 namespace (including those without any namespace).</p>

 <p>The last rule is equivalent to the fourth rule because no default
 namespace has been defined.</p>

</div>

<h3 id=universal-selector>Universal selector </h3>

<p>The <dfn>universal selector</dfn>, written as a
<a href="https://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
name</a> [[!CSS3NAMESPACE]] with an asterisk (<dfn data-dfn-type="selector" data-export>*</dfn>
U+002A) as the local name, represents the qualified name of any element
type. It represents any single element in the document tree in any
namespace (including those without a namespace) if no default
namespace has been specified for selectors. If a default namespace has
been specified, see <a href="#univnmsp">Universal selector and
Namespaces</a> below.</p>

<p>If a universal selector represented by <code>*</code> (i.e. without a
namespace prefix) is not the only component of a <a href="#sequence">sequence
of simple selectors</a> selectors or is immediately followed by a
<a href="#pseudo-elements">pseudo-element</a>, then the <code>*</code> may
be omitted and the universal selector's presence implied.</p>

<div class="example">
 <p>Examples:</p>
 <ul>
  <li><code>*[hreflang|=en]</code> and <code>[hreflang|=en]</code> are equivalent,</li>
  <li><code>*.warning</code> and <code>.warning</code> are equivalent,</li>
  <li><code>*#myid</code> and <code>#myid</code> are equivalent.</li>
 </ul>
</div>

<p class="note"><strong>Note:</strong> it is recommended that the
<code>*</code> not be omitted, because it decreases the potential
confusion between, for example,
<code style="white-space: nowrap">div :first-child</code>
and <code style="white-space: nowrap">div:first-child</code>.
Here, <code style="white-space: nowrap">div *:first-child</code>
is more readable.</p>

<h4 id=univnmsp>Universal selector and namespaces</h4>

<p>The universal selector allows an optional namespace component. It
is used as follows:</p>

<dl>
 <dt><code>ns|*</code></dt>
 <dd>all elements in namespace ns</dd>
 <dt><code>*|*</code></dt>
 <dd>all elements</dd>
 <dt><code>|*</code></dt>
 <dd>all elements without a namespace</dd>
 <dt><code>*</code></dt>
 <dd>if no default namespace has been specified, this is equivalent to *|*.
 Otherwise it is equivalent to ns|* where ns is the default namespace.</dd>
</dl>

<p>A universal selector containing a namespace prefix that has not
been previously <a href="#nsdecl">declared</a> is an <a
href="#Conformance">invalid</a> selector.</p>


<h3 id=attribute-selectors>Attribute selectors</h3>

<p>Selectors allow the representation of an elementâ€™s attributes. When
a selector is used as an expression to match against an element,
attribute selectors must be considered to match an element if that
element has an attribute that matches the attribute represented by the
attribute selector.</p>

<h4 id=attribute-representation>Attribute presence and value selectors</h4>

<p>CSS2 introduced four attribute selectors:</p>

<dl>
  <dt><code>[att]</code>
  <dd>Represents an element with the <code>att</code> attribute, whatever the value of
  the attribute.</dd>
  <dt><code>[att=val]</code></dt>
  <dd>Represents an element with the <code>att</code> attribute whose value is exactly
  "val".</dd>
  <dt><code>[att~=val]</code></dt>
  <dd>Represents an element with the <code>att</code> attribute whose value is a <a
  href="#whitespace">whitespace</a>-separated list of words, one of
  which is exactly "val". If "val" contains whitespace, it will never
  represent anything (since the words are <em>separated</em> by
  spaces). Also if "val" is the empty string, it will never represent
  anything.</dd>
  <dt><code>[att|=val]</code>
  <dd>Represents an element with the <code>att</code> attribute, its
  value either being exactly "val" or beginning with "val" immediately
  followed by "-" (U+002D).  This is primarily intended to allow
  language subcode matches (e.g., the <code>hreflang</code> attribute
  on the <code>a</code> element in HTML) as described in BCP 47 ([[BCP47]]) or its successor.  For
  <code>lang</code> (or <code>xml:lang</code>) language subcode
  matching, please see <a href="#lang-pseudo">the <code>:lang</code>
  pseudo-class</a>.</dd>
</dl>

<p>Attribute values must be CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>
or <a href="https://www.w3.org/TR/CSS21/syndata.html#strings">strings</a>. [[!CSS21]]
The case-sensitivity of attribute names and values in selectors depends on
the document language.</p>

<div class="example">

  <p>Examples:</p>

  <p>The following attribute selector represents an <code>h1</code>
  element that carries the <code>title</code> attribute, whatever its
  value:</p>

  <pre>h1[title]</pre>

  <p>In the following example, the selector represents a
  <code>span</code> element whose <code>class</code> attribute has
  exactly the value "example":</p>

  <pre>span[class="example"]</pre>

  <p>Multiple attribute selectors can be used to represent several
  attributes of an element, or several conditions on the same
  attribute. Here, the selector represents a <code>span</code> element
  whose <code>hello</code> attribute has exactly the value "Cleveland"
  and whose <code>goodbye</code> attribute has exactly the value
  "Columbus":</p>

  <pre>span[hello="Cleveland"][goodbye="Columbus"]</pre>

  <p>The following CSS rules illustrate the differences between
  "=" and "~=".  The first selector would match, for example, an
  <code>a</code> element with the value "copyright copyleft
  copyeditor" on a <code>rel</code> attribute. The second selector
  would only match an <code>a</code> element with an <code>href</code>
  attribute having the exact value "http://www.w3.org/".</p>

  <pre>a[rel~="copyright"] { ... }
a[href="http://www.w3.org/"] { ... }</pre>

  <p>The following selector represents an <code>a</code> element
  whose <code>hreflang</code> attribute is exactly "fr".</p>

  <pre>a[hreflang=fr]</pre>

  <p>The following selector represents an <code>a</code> element for
  which the value of the <code>hreflang</code> attribute begins with
  "en", including "en", "en-US", and "en-scouse":</p>

  <pre>a[hreflang|="en"]</pre>

  <p>The following selectors represent a <code>DIALOGUE</code> element
  whenever it has one of two different values for an attribute
  <code>character</code>:</p>

  <pre>DIALOGUE[character=romeo]
DIALOGUE[character=juliet]</pre>

</div>

<h4 id=attribute-substrings>Substring matching attribute
selectors</h4>

<p>Three additional attribute selectors are provided for matching
substrings in the value of an attribute:</p>

<dl>
  <dt><code>[att^=val]</code></dt>
  <dd>Represents an element with the <code>att</code> attribute whose value begins
  with the prefix "val". If "val" is the empty string then the selector does not
  represent anything.</dd>
  <dt><code>[att$=val]</code>
  <dd>Represents an element with the <code>att</code> attribute whose value ends with
  the suffix "val". If "val" is the empty string then the selector does not represent
  anything.</dd>
  <dt><code>[att*=val]</code>
  <dd>Represents an element with the <code>att</code> attribute whose value contains
  at least one instance of the substring "val". If "val" is the empty string then
  the selector does not represent anything.</dd>
</dl>

<p>Attribute values must be CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>
or <a href="https://www.w3.org/TR/CSS21/syndata.html#strings">strings</a>. [[!CSS21]]
The case-sensitivity of attribute names in selectors depends on the
document language.</p>

<div class="example">
 <p>Examples:</p>
 <p>The following selector represents an HTML <code>object</code>, referencing an
 image:</p>
 <pre>object[type^="image/"]</pre>
 <p>The following selector represents an HTML anchor <code>a</code> with an
 <code>href</code> attribute whose value ends with ".html".</p>
 <pre>a[href$=".html"]</pre>
 <p>The following selector represents an HTML paragraph with a <code>title</code>
 attribute whose value contains the substring "hello"</p>
 <pre>p[title*="hello"]</pre>
</div>

<h4 id=attrnmsp>Attribute selectors and namespaces</h4>

<p>The attribute name in an attribute selector is given as a
<a href="https://www.w3.org/TR/css3-namespace/#css-qnames">CSS qualified
name</a>: a namespace prefix that has been previously <a href="#nsdecl">declared</a>
may be prepended to the attribute name separated by the namespace
separator &quot;vertical bar&quot; (<code>|</code>). In keeping with
the Namespaces in the XML recommendation, default namespaces do not
apply to attributes, therefore attribute selectors without a namespace
component apply only to attributes that have no namespace (equivalent
to "<code>|attr</code>"). An asterisk may be used for
the namespace prefix indicating that the selector is to match all
attribute names without regard to the attribute's namespace.

<p>An attribute selector with an attribute name containing a namespace
prefix that has not been previously <a href="#nsdecl">declared</a> is
an <a href="#Conformance">invalid</a> selector.</p>

<div class="example">
  <p>CSS examples:</p>
  <pre>@namespace foo "http://www.example.com";
[foo|att=val] { color: blue }
[*|att] { color: yellow }
[|att] { color: green }
[att] { color: green }</pre>

  <p>The first rule will match only elements with the attribute
  <code>att</code> in the "http://www.example.com" namespace with the
  value "val".</p>

  <p>The second rule will match only elements with the attribute
  <code>att</code> regardless of the namespace of the attribute
  (including no namespace).</p>

  <p>The last two rules are equivalent and will match only elements
  with the attribute <code>att</code> where the attribute is not
  in a namespace.</p>

</div>

<h4 id=def-values>Default attribute values in DTDs</h4>

<p>Attribute selectors represent attribute values in the document tree.
How that document tree is constructed is outside the scope of Selectors.
In some document formats default attribute values can be defined in a DTD or
elsewhere, but these can only be selected by attribute selectors if they
appear in the document tree. Selectors should be designed so that they
work whether or not the default values are included in the document tree.</p>

<p>For example, a XML UA may, but is <em>not</em> required to read an "external
subset" of the DTD but <em>is</em> required to look for default
attribute values in the document's "internal subset." (See, e.g., [[XML10]] for definitions of these subsets.) Depending
on the UA, a default attribute value defined in the external subset of the
DTD might or might not appear in the document tree.</p>

<p>A UA that recognizes an XML namespace may, but is not required to use its
knowledge of that namespace to treat default attribute values as if
they were present in the document. (For example, an XHTML UA is not
required to use its built-in knowledge of the XHTML DTD. See, e.g., [[XML-NAMES]] for details on namespaces in XML
1.0.)</p>

<p class="note"><strong>Note:</strong> Typically, implementations
choose to ignore external subsets. This corresponds to the behavior
of non-validating processors as defined by the XML specification.</p>

<div class="example">
<p>Example:</p>

<p>Consider an element <code>EXAMPLE</code> with an attribute <code>radix</code>
that has a default value of <code>"decimal"</code>. The DTD fragment might be</p>

<pre class="dtd-example">&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"></pre>

<p>If the style sheet contains the rules</p>

<pre>EXAMPLE[radix=decimal] { /*... default property settings ...*/ }
EXAMPLE[radix=octal]   { /*... other settings...*/ }</pre>

<p>the first rule might not match elements whose <code>radix</code> attribute is
set by default, i.e. not set explicitly. To catch all cases, the
attribute selector for the default value must be dropped:</p>

<pre>EXAMPLE                { /*... default property settings ...*/ }
EXAMPLE[radix=octal]   { /*... other settings...*/ }</pre>

<p>Here, because the selector <code>EXAMPLE[radix=octal]</code> is
more specific than the type selector alone, the style declarations in
the second rule will override those in the first for elements that
have a <code>radix</code> attribute value of <code>"octal"</code>. Care has to be taken that
all property declarations that are to apply only to the default case
are overridden in the non-default cases' style rules.</p>

</div>

<h3 id=class-html>Class selectors</h3>

<p>Working with HTML, authors may use the "period" notation (also
known as "full stop", U+002E, <code>.</code>) as an alternative to the
<code>~=</code> notation when representing the <code>class</code>
attribute. Thus, for HTML, <code>div.value</code> and
<code>div[class~=value]</code> have the same meaning. The attribute
value must immediately follow the full stop
(<code>.</code>).</p>

<p>UAs may apply selectors using the period (.) notation in XML
documents if the UA has namespace-specific knowledge that allows it to
determine which attribute is the "class" attribute for the
respective namespace. One such example of namespace-specific knowledge
is the prose in the specification for a particular namespace (e.g. SVG
1.1 [[SVG11]] describes the <a
href="https://www.w3.org/TR/SVG11/styling.html#ClassAttribute">SVG
<code>class</code> attribute</a> and how a UA should interpret it, and
similarly MathML [[MATHML3]] describes the <a
href="https://www.w3.org/TR/MathML3/chapter2.html#fund.globatt">MathML
<code>class</code> attribute</a>.)</p>

<div class="example">
 <p>CSS examples:</p>

 <p>We can assign style information to all elements with
 <code>class~="pastoral"</code> as follows:</p>

  <pre>*.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

  <p>or just</p>

  <pre>.pastoral { color: green }  /* all elements with class~=pastoral */</pre>

  <p>The following assigns style only to H1 elements with
  <code>class~="pastoral"</code>:</p>

  <pre>H1.pastoral { color: green }  /* H1 elements with class~=pastoral */</pre>

  <p>Given these rules, the first <code>H1</code> instance below would not have
  green text, while the second would:</p>

  <pre>&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;</pre>

  <p>The following rule matches any <code>P</code> element whose <code>class</code>
  attribute has been assigned a list of <a
  href="#whitespace">whitespace</a>-separated values that includes both
  <code>pastoral</code> and <code>marine</code>:</p>

  <pre>p.pastoral.marine { color: green }</pre>

  <p>This rule matches when <code>class="pastoral blue aqua
  marine"</code> but does not match for <code>class="pastoral
  blue"</code>.</p>

</div>

<p class="note"><strong>Note:</strong> Because CSS gives considerable
power to the "class" attribute, authors could conceivably design their
own "document language" based on elements with almost no associated
presentation (such as <code>DIV</code> and <code>SPAN</code> in HTML)
and assigning style
information through the "class" attribute.  Authors should avoid this
practice since the structural elements of a document language often
have recognized and accepted meanings and author-defined classes may
not.</p>

<p class="note"><strong>Note:</strong> If an element has multiple
class attributes, their values must be concatenated with spaces
between the values before searching for the class. As of this time the
working group is not aware of any manner in which this situation can
be reached, however, so this behavior is explicitly non-normative in
this specification.</p>

<h3 id=id-selectors>ID selectors</h3>

<p>Document languages may contain attributes that are declared to be
of type ID. What makes attributes of type ID special is that no two
such attributes can have the same value in a conformant document,
regardless of the type of the elements that carry them; whatever the
document language, an ID typed attribute can be used to uniquely
identify its element. In HTML all ID attributes are named "id"; XML
applications may name ID attributes differently, but the same
restriction applies.</p>

<p>An ID-typed attribute of a document language allows authors to
assign an identifier to one element instance in the document tree. An
ID selector contains a &quot;number sign&quot; (U+0023,
<code>#</code>) immediately followed by the ID value, which must be an
CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifiers</a>.
An ID selector represents an element instance that has an
identifier that matches the identifier in the ID selector.</p>

<p>Selectors does not specify how a UA knows the ID-typed attribute of
an element. The UA may, e.g., read a document's DTD, have the
information hard-coded or ask the user.

<div class="example">
  <p>Examples:</p>
  <p>The following ID selector represents an <code>h1</code> element
  whose ID-typed attribute has the value "chapter1":</p>
  <pre>h1#chapter1</pre>
  <p>The following ID selector represents any element whose ID-typed
  attribute has the value "chapter1":</p>
  <pre>#chapter1</pre>
  <p>The following selector represents any element whose ID-typed
  attribute has the value "z98y".</p>
  <pre>*#z98y</pre>
</div>

<p class="note"><strong>Note:</strong> In XML 1.0 [[XML10]], the information about which attribute
contains an element's IDs is contained in a DTD or a schema. When
parsing XML, UAs do not always read the DTD, and thus may not know
what the ID of an element is (though a UA may have namespace-specific
knowledge that allows it to determine which attribute is the ID
attribute for that namespace). If a style sheet author knows or
suspects that a UA may not know what the ID of an element is, he
should use normal attribute selectors instead:
<code>[name=p371]</code> instead of <code>#p371</code>.</p>

<p>If an element has multiple ID attributes, all of them must be
treated as IDs for that element for the purposes of the ID
selector. Such a situation could be reached using mixtures of xml:id,
DOM, XML DTDs, and namespace-specific knowledge.</p>

<h3 id="pseudo-classes">Pseudo-classes</h3>

<p>The pseudo-class concept is introduced to permit selection based on
information that lies outside of the document tree or that cannot be
expressed using the other simple selectors.</p>

<p>A pseudo-class always consists of a &quot;colon&quot;
(<code>:</code>) followed by the name of the pseudo-class and
optionally by a value between parentheses.</p>

<p>Pseudo-classes are allowed in all sequences of simple selectors
contained in a selector. Pseudo-classes are allowed anywhere in
sequences of simple selectors, after the leading type selector or
universal selector (possibly omitted). Pseudo-class names are
case-insensitive. Some pseudo-classes are mutually exclusive, while
others can be applied simultaneously to the same
element. Pseudo-classes may be dynamic, in the sense that an element
may acquire or lose a pseudo-class while a user interacts with the
document.</p>


<h4 id=dynamic-pseudos>Dynamic pseudo-classes</h4>

<p>Dynamic pseudo-classes classify elements on characteristics other
than their name, attributes, or content, in principle characteristics
that cannot be deduced from the document tree.</p>

<p>Dynamic pseudo-classes do not appear in the document source or
document tree.</p>


<h5>The <a name=link>link pseudo-classes: :link and :visited</a></h5>

<p>User agents commonly display unvisited links differently from
previously visited ones. Selectors
provides the pseudo-classes <dfn data-dfn-type=selector data-export id="sel-link">:link</dfn> and
<dfn data-dfn-type=selector data-export id="sel-link">:visited</dfn> to distinguish them:</p>

<ul>
  <li>The <code>:link</code> pseudo-class applies to links that have
  not yet been visited.</li>
  <li>The <code>:visited</code> pseudo-class applies once the link has
  been visited by the user. </li>
</ul>

<p>After some amount of time, user agents may choose to return a
visited link to the (unvisited) ':link' state.</p>

<p>The two states are mutually exclusive.</p>

<div class="example">

  <p>Example:</p>

  <p>The following selector represents links carrying class
  <code>external</code> and already visited:</p>

  <pre>a.external:visited</pre>

</div>

<p class="note"><strong>Note:</strong> It is possible for style sheet
authors to abuse the :link and :visited pseudo-classes to determine
which sites a user has visited without the user's consent.

<p>UAs may therefore treat all links as unvisited links, or implement
other measures to preserve the user's privacy while rendering visited
and unvisited links differently.</p>

<h5>The <a name=useraction-pseudos>user action pseudo-classes
:hover, :active, and :focus</a></h5>

<p>Interactive user agents sometimes change the rendering in response
to user actions. Selectors provides three pseudo-classes for the
selection of an element the user is acting on.</p>

<ul>

  <li>The <dfn data-dfn-type=selector data-export id="sel-hover">:hover</dfn> pseudo-class applies while the user
  designates an element with a pointing device, but does not necessarily activate
  it. For example, a visual user agent could apply this pseudo-class
  when the cursor (mouse pointer) hovers over a box generated by the
  element. User agents that do not support <a
  href="https://www.w3.org/TR/CSS21/media.html#interactive-media-group">interactive
  media</a> do not have to support this pseudo-class. Some conforming
  user agents that support <a
  href="https://www.w3.org/TR/CSS21/media.html#interactive-media-group">interactive
  media</a> may not be able to support this pseudo-class (e.g., a pen
  device that does not detect hovering).</li>

  <li>The <dfn data-dfn-type=selector data-export id="sel-active">:active</dfn> pseudo-class applies while an element
  is being activated by the user. For example, between the times the
  user presses the mouse button and releases it. On systems with more
  than one mouse button, <code>:active</code> applies only to the
  primary or primary activation button (typically the "left" mouse
  button), and any aliases thereof.</li>

  <li>The <dfn data-dfn-type=selector data-export id="sel-focus">:focus</dfn> pseudo-class applies while an element
  has the focus (accepts keyboard or mouse events, or other forms of
  input). </li>

</ul>

<p>There may be document language or implementation specific limits on
which elements can become <code>:active</code> or acquire
<code>:focus</code>.</p>

<p>These pseudo-classes are not mutually exclusive. An element may
match several pseudo-classes at the same time.</p>

<p>Selectors doesn't define if the parent of an element that is
':active' or ':hover' is also in that state.</p>

<p class="note"><strong>Note:</strong> If the ':hover' state applies to an
element because its child is designated by a pointing device, then it's
possible for ':hover' to apply to an element that is not underneath
the pointing device.</p>

<div class="example">
  <p>Examples:</p>
  <pre>a:link    /* unvisited links */
a:visited /* visited links */
a:hover   /* user hovers */
a:active  /* active links */</pre>
  <p>An example of combining dynamic pseudo-classes:</p>
  <pre>a:focus
a:focus:hover</pre>
  <p>The last selector matches <code>a</code> elements that are in
  the pseudo-class :focus and in the pseudo-class :hover.</p>
</div>

<p class="note"><strong>Note:</strong> An element can be both
':visited' and ':active' (or ':link' and ':active').</p>

<h4 id="target-pseudo">The target pseudo-class :target</h4>

<p>Some URIs refer to a location within a resource. This kind of URI
ends with a &quot;number sign&quot; (#) followed by an anchor
identifier (called the fragment identifier).</p>

<p>URIs with fragment identifiers link to a certain element within the
document, known as the target element. For instance, here is a URI
pointing to an anchor named <code>section_2</code> in an HTML
document:</p>

<pre>http://example.com/html/top.html#section_2</pre>

<p>A target element can be represented by the <dfn data-dfn-type=selector data-export id="sel-target">:target</dfn>
pseudo-class. If the documentâ€™s URI has no fragment identifier, then
the document has no target element.</p>

<div class="example">
 <p>Example:</p>
 <pre>p.note:target</pre>
 <p>This selector represents a <code>p</code> element of class
 <code>note</code> that is the target element of the referring
 URI.</p>
</div>

<div class="example">
 <p>CSS example:</p>
 <p>Here, the <code>:target</code> pseudo-class is used to make the
 target element red and place an image before it, if there is one:</p>
 <pre>*:target { color : red }
*:target::before { content : url(target.png) }</pre>
</div>

<h4 id="lang-pseudo">The language pseudo-class :lang</h4>

<p>If the document language specifies how the human language of an
element is determined, it is possible to write selectors that
represent an element based on its language. For example, in HTML [[HTML401]], the language is determined by a
combination of the <code>lang</code> attribute and possibly
information from the <code>meta</code> elements or the protocol (such
as HTTP headers). XML uses an attribute called <code>xml:lang</code>,
and there may be other document language-specific methods for
determining the language.</p>

<p>The pseudo-class <dfn data-dfn-type=selector data-export data-lt=":lang" id="sel-lang">:lang(C)</dfn> represents an element that
is in language C. Whether an element is represented by a
<code>:lang()</code> selector is based solely on the element's
language value (normalized to BCP 47 syntax if necessary) being
equal to the identifier C, or beginning with the identifier C
immediately followed by "-" (U+002D). The matching of C against the
element's language value is performed case-insensitively within the ASCII range.
The identifier C does not have to be a valid language name.</p>

<p>C must be a valid CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">identifier</a> [[!CSS21]]
and must not be empty. (Otherwise, the selector is invalid.)</p>

<p class="note"><strong>Note:</strong> It is recommended that
documents and protocols indicate language using codes from BCP 47 [[BCP47]] or its successor, and by means of
"xml:lang" attributes in the case of XML-based documents [[XML10]]. See <a
href="http://www.w3.org/International/questions/qa-lang-2or3.en.html">
"FAQ: Two-letter or three-letter language codes."</a></p>

<div class="example">
  <p>Examples:</p>
  <p>The two following selectors represent an HTML document that is in
  Belgian French or German. The two next selectors represent
  <code>q</code> quotations in an arbitrary element in Belgian French
  or German.</p>
  <pre>html:lang(fr-be)
html:lang(de)
:lang(fr-be) &gt; q
:lang(de) &gt; q</pre>
</div>

<p>The difference between <code>:lang(C)</code> and the '|=' operator
is that the '|=' operator only performs a comparison against a given
attribute on the element, while the <code>:lang(C)</code> pseudo-class
uses the UAs knowledge of the document's semantics to perform the
comparison.</p>

<div class=example>

  <p>In this HTML example, only the BODY matches
  <code>[lang|=fr]</code> (because it has a LANG attribute) but both
  the BODY and the P match <code>:lang(fr)</code> (because both are in
  French). The P does not match the <code>[lang|=fr]</code> because it
  does not have a LANG attribute.</p>
  <pre>&lt;body lang=fr>
  &lt;p>Je suis fran&ccedil;ais.&lt;/p>
&lt;/body></pre>
</div>

<h4 id="UIstates">The UI element states pseudo-classes</h4>

<h5 id="enableddisabled">The :enabled and :disabled pseudo-classes</h5>

<p>The <dfn data-dfn-type=selector data-export id="sel-enabled">:enabled</dfn> pseudo-class represents user interface elements
that are in an enabled state; such elements have a corresponding disabled
state.</p>

<p>Conversely, the <dfn data-dfn-type=selector data-export id="sel-disabled">:disabled</dfn> pseudo-class represents user
interface elements that are in a disabled state; such elements have a
corresponding enabled state.</p>

<p>What constitutes an enabled state, a disabled state, and a user interface
element is language-dependent. In a typical document most elements will be
neither <code>:enabled</code> nor <code>:disabled</code>.</p>

<p class="note"><strong>Note:</strong> CSS properties that might affect a userâ€™s ability
to interact with a given user interface element do not affect whether it
matches <code>:enabled</code> or <code>:disabled</code>; e.g., the
<code>display</code> and <code>visibility</code> properties have no effect
on the enabled/disabled state of an element.</p>

<h5 id="checked">The :checked pseudo-class</h5>

<p>Radio and checkbox elements can be toggled by the user. Some menu
items are "checked" when the user selects them. When such elements are
toggled "on" the <dfn data-dfn-type=selector data-export id="sel-checked">:checked</dfn> pseudo-class applies. While the
<code>:checked</code> pseudo-class is dynamic in nature, and can altered
by user action, since it can also be based on the presence of semantic
attributes in the document, it applies to all media. For example, the
<code>:checked</code> pseudo-class initially applies to such elements
that have the HTML4 <code>selected</code> and <code>checked</code>
attributes as described in <a
href="https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.2.1">Section
17.2.1 of HTML4</a>, but of course the user can toggle "off" such
elements in which case the <code>:checked</code> pseudo-class would no
longer apply.

<h5 id="indeterminate">The :indeterminate pseudo-class</h5>

<div class="note">
<p><strong>Note:</strong> Radio and checkbox elements can be toggled by the user, but are
sometimes in an indeterminate state, neither checked nor unchecked.
This can be due to an element attribute, or DOM manipulation.</p>

<p>A future version of this specification may introduce an
<code>:indeterminate</code> pseudo-class that applies to such elements.
<!--While the <code>:indeterminate</code> pseudo-class is dynamic in
nature, and is altered by user action, since it can also be based on
the presence of an element attribute, it applies to all media.</p>

<p>Components of a radio-group initialized with no pre-selected choice
are an example of :indeterminate state.--></p>

</div>


<h4 id="structural-pseudos">Structural pseudo-classes</h4>

<p>Selectors introduces the concept of <dfn>structural
pseudo-classes</dfn> to permit selection based on extra information that lies in
the document tree but cannot be represented by other simple selectors or
combinators.

<p>Standalone text and other non-element nodes
are not counted when calculating the position of an element
in its list of siblings;
index numbering starts at 1.


<h5 id="root-pseudo">:root pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export id="sel-root">:root</dfn> pseudo-class represents an element that is
the root of the document. In HTML 4, this is always the
<code>HTML</code> element.


<h5 id="nth-child-pseudo">:nth-child() pseudo-class</h5>

<p>The
<dfn data-dfn-type=selector data-export data-lt=":nth-child()" id="sel-nth-child">:nth-child(<var>a</var><code>n</code>+<var>b</var>)</dfn>
pseudo-class notation represents an element that has
<var>a</var><code>n</code>+<var>b</var>-1 siblings
<strong>before</strong> it in the document tree, for any positive
integer or zero value of <code>n</code>.
It is not required to have a parent.
For values of <var>a</var> and <var>b</var> greater than zero, this
effectively divides the element's children into groups of <var>a</var>
elements (the last group taking the remainder), and selecting the
<var>b</var>th element of each group.
For example, this allows the selectors to address every other
row in a table, and could be used to alternate the color of paragraph
text in a cycle of four. The <var>a</var> and <var>b</var> values must
be integers (positive, negative, or zero). The index of the first child
of an element is 1.

<p>In addition to this, <code>:nth-child()</code> can take
'<code>odd</code>' and '<code>even</code>' as arguments instead.
'<code>odd</code>' has the same signification as <code>2n+1</code>,
and '<code>even</code>' has the same signification as <code>2n</code>.

<p>The argument to <code>:nth-child()</code> must match the grammar
below, where <code>INTEGER</code> matches the token <code>[0-9]+</code>
and the rest of the tokenization is given by the
<a href="#lex">Lexical scanner</a> in section 10.2:

<pre>nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;</pre>

<div class="example">
<p>Examples:</p>
<pre>tr:nth-child(2n+1) /* represents every odd row of an HTML table */
tr:nth-child(odd)  /* same */
tr:nth-child(2n+0) /* represents every even row of an HTML table */
tr:nth-child(even) /* same */

/* Alternate paragraph colours in CSS */
p:nth-child(4n+1) { color: navy; }
p:nth-child(4n+2) { color: green; }
p:nth-child(4n+3) { color: maroon; }
p:nth-child(4n+4) { color: purple; }</pre>
</div>

<p>When the value <var>b</var> is preceded by a negative sign,
the "+" character in the expression must be removed (it is
effectively replaced by the "-" character indicating the negative
value of <var>b</var>).</p>

<div class="example">
<p>Examples:</p>
<pre>:nth-child(10n-1)  /* represents the 9th, 19th, 29th, etc, element */
:nth-child(10n+9)  /* Same */
:nth-child(10n+-1) /* Syntactically invalid, and would be ignored */</pre>
</div>

<p>When <var>a</var>=0, the <var>a</var><code>n</code> part need not be
included (unless the <var>b</var> part is already omitted).  When
<var>a</var><code>n</code> is not included and <var>b</var> is non-negative,
the <code>+</code> sign before <var>b</var> (when allowed) may also be omitted.
In this case the syntax simplifies to <code>:nth-child(<var>b</var>)</code>.

<div class="example">
<p>Examples:</p>
<pre>foo:nth-child(0n+5)   /* represents an element foo that is the 5th child
                         of its parent element */
foo:nth-child(5)      /* same */</pre>
</div>

<p>When <var>a</var>=1, or <var>a</var>=-1, the <code>1</code> may be
omitted from the rule.

<div class="example">
<p>Examples:</p>
<p>The following selectors are therefore equivalent:</p>
<pre>bar:nth-child(1n+0)   /* represents all bar elements, specificity (0,1,1) */
bar:nth-child(n+0)    /* same */
bar:nth-child(n)      /* same */
bar                   /* same but lower specificity (0,0,1) */</pre>
</div>

<p>If <var>b</var>=0, then every <var>a</var>th element is picked. In
such a case, the +<var>b</var> (or -<var>b</var>) part may be omitted
unless the <var>a</var> part is already omitted.</p>

<div class="example">
<p>Examples:</p>
<pre>tr:nth-child(2n+0) /* represents every even row of an HTML table */
tr:nth-child(2n) /* same */</pre>
</div>

<p>Whitespace is permitted after the "(", before the ")", and on either
side of the "+" or "-" that separates the <var>a</var><code>n</code> and
<var>b</var> parts when both are present.

<div class="example">
<p>Valid Examples with white space:</p>
<pre>
:nth-child( 3n + 1 )
:nth-child( +3n - 2 )
:nth-child( -n+ 6)
:nth-child( +6 )
</pre>
<p>Invalid Examples with white space:</p>
<pre>
:nth-child(3 n)
:nth-child(+ 2n)
:nth-child(+ 2)
</pre>
</div>

<p>If both <var>a</var> and <var>b</var> are equal to zero, the
pseudo-class represents no element in the document tree.</p>

<p>The value <var>a</var> can be negative, but only the positive
values of <var>a</var><code>n</code>+<var>b</var>, for
<code>n</code>&ge;0, may represent an element in the document
tree.</p>

<div class="example">
<p>Example:</p>
<pre>html|tr:nth-child(-n+6)  /* represents the 6 first rows of XHTML tables */</pre>
</div>

<h5 id="nth-last-child-pseudo">:nth-last-child() pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export data-lt=":nth-last-child()" id="sel-nth-last-child">:nth-last-child(<var>a</var>n+<var>b</var>)</dfn>
pseudo-class notation represents an element that has
<var>a</var><code>n</code>+<var>b</var>-1 siblings
<strong>after</strong> it in the document tree, for any positive
integer or zero value of <code>n</code>.
It is not required to have a parent.
See <a href="#nth-child-pseudo"><code>:nth-child()</code></a> pseudo-class for
the syntax of its argument.
It also accepts the '<code>even</code>' and '<code>odd</code>' values
as arguments.


<div class="example">
<p>Examples:</p>
<pre>tr:nth-last-child(-n+2)    /* represents the two last rows of an HTML table */

foo:nth-last-child(odd)    /* represents all odd foo elements in their parent element,
                              counting from the last one */</pre>
</div>


<h5 id="nth-of-type-pseudo">:nth-of-type() pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export data-lt=":nth-of-type()" id="sel-nth-of-type">:nth-of-type(<var>a</var>n+<var>b</var>)</dfn>
pseudo-class notation represents an element that has
<var>a</var><code>n</code>+<var>b</var>-1 siblings with the same expanded
element name <strong>before</strong> it in the document tree, for any
zero or positive integer value of <code>n</code>.
It is not required to have a parent.
See <a href="#nth-child-pseudo"><code>:nth-child()</code></a>
pseudo-class for the syntax of its argument. It also accepts the
'<code>even</code>' and '<code>odd</code>' values.


<div class="example">
<p>CSS example:</p>
<p>This allows an author to alternate the position of floated images:</p>
<pre>img:nth-of-type(2n+1) { float: right; }
img:nth-of-type(2n) { float: left; }</pre>
</div>


<h5 id="nth-last-of-type-pseudo">:nth-last-of-type() pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export data-lt=":nth-last-of-type()" id="sel-nth-last-of-type">:nth-last-of-type(<var>a</var>n+<var>b</var>)</dfn>
pseudo-class notation represents an element that has
<var>a</var><code>n</code>+<var>b</var>-1 siblings with the same expanded
element name <strong>after</strong> it in the document tree, for any
zero or positive integer value of <code>n</code>.
It is not required to have a parent.
See <a href="#nth-child-pseudo"><code>:nth-child()</code></a>
pseudo-class for the syntax of its argument. It also accepts the
'<code>even</code>' and '<code>odd</code>' values.


<div class="example">
 <p>Example:</p>
 <p>To represent all <code>h2</code> children of an XHTML
 <code>body</code> except the first and last, one could use the
 following selector:</p>
 <pre>body &gt; h2:nth-of-type(n+2):nth-last-of-type(n+2)</pre>
 <p>In this case, one could also use <code>:not()</code>, although the
 selector ends up being just as long:</p>
 <pre>body &gt; h2:not(:first-of-type):not(:last-of-type)</pre>
</div>


<h5 id="first-child-pseudo">:first-child pseudo-class</h5>

<p>Same as <code>:nth-child(1)</code>. The <dfn data-dfn-type=selector data-export id="sel-first-child">:first-child</dfn> pseudo-class
represents an element that is first in a list of siblings.


<div class="example">
  <p>Examples:</p>
  <p>The following selector represents a <code>p</code> element that is
  the first child of a <code>div</code> element:</p>
  <pre>div &gt; p:first-child</pre>
  <p>This selector can represent the <code>p</code> inside the
  <code>div</code> of the following fragment:</p>
  <pre>&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
   &lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>but cannot represent the second <code>p</code> in the following
fragment:
  <pre>&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
   &lt;h2&gt; Note &lt;/h2&gt;
   &lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>
  <p>The following two selectors are usually equivalent:</p>
  <pre>* &gt; a:first-child /* a is first child of any element */
a:first-child /* Same (assuming a is not the root element) */</pre>
</div>

<h5 id="last-child-pseudo">:last-child pseudo-class</h5>

<p>Same as <code>:nth-last-child(1)</code>. The <dfn data-dfn-type=selector data-export id="sel-last-child">:last-child</dfn> pseudo-class
represents an element that is last in a list of siblings.

<div class="example">
 <p>Example:</p>
 <p>The following selector represents a list item <code>li</code> that
 is the last child of an ordered list <code>ol</code>.
 <pre>ol &gt; li:last-child</pre>
</div>

<h5 id="first-of-type-pseudo">:first-of-type pseudo-class</h5>

<p>Same as <code>:nth-of-type(1)</code>. The <dfn data-dfn-type=selector data-export id="sel-first-of-type">:first-of-type</dfn> pseudo-class
represents an element that is the first sibling of its type.

<div class="example">
<p>Example:</p>
<p>The following selector represents a definition title
<code>dt</code> inside a definition list <code>dl</code>, this
<code>dt</code> being the first of its type in the list of children of
its parent element.</p>
<pre>dl dt:first-of-type</pre>
<p>It is a valid description for the first two <code>dt</code>
elements in the following example but not for the third one:</p>
<pre>&lt;dl&gt;
 &lt;dt&gt;gigogne&lt;/dt&gt;
 &lt;dd&gt;
  &lt;dl&gt;
   &lt;dt&gt;fus&eacute;e&lt;/dt&gt;
   &lt;dd&gt;multistage rocket&lt;/dd&gt;
   &lt;dt&gt;table&lt;/dt&gt;
   &lt;dd&gt;nest of tables&lt;/dd&gt;
  &lt;/dl&gt;
 &lt;/dd&gt;
&lt;/dl&gt;</pre>
</div>

<h5 id="last-of-type-pseudo">:last-of-type pseudo-class</h5>

<p>Same as <code>:nth-last-of-type(1)</code>. The
<dfn data-dfn-type=selector data-export id="sel-last-of-type">:last-of-type</dfn> pseudo-class represents an element that is
the last sibling of its type.

<div class="example">
 <p>Example:</p>
 <p>The following selector represents the last data cell
 <code>td</code> of a table row <code>tr</code>.</p>
 <pre>tr &gt; td:last-of-type</pre>
</div>

<h5 id="only-child-pseudo">:only-child pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export id="sel-only-child">:only-child</dfn> pseudo-class
represents an element that has no siblings. Same as
<code>:first-child:last-child</code> or
<code>:nth-child(1):nth-last-child(1)</code>, but with a lower
specificity.</p>

<h5 id="only-of-type-pseudo">:only-of-type pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export id="sel-only-of-type">:only-of-type</dfn> pseudo-class
represents an element that has no siblings with the same expanded element
name. Same as <code>:first-of-type:last-of-type</code> or
<code>:nth-of-type(1):nth-last-of-type(1)</code>, but with a lower
specificity.</p>


<h5 id="empty-pseudo">:empty pseudo-class</h5>

<p>The <dfn data-dfn-type=selector data-export id="sel-empty">:empty</dfn> pseudo-class represents an element that has
no children at all. In terms of the document tree, only element nodes and
content nodes (such as DOM [[DOM-LEVEL-3-CORE]] text nodes, CDATA
nodes, and entity references) whose data has a non-zero length must be
considered as affecting emptiness;
comments, processing instructions, and other nodes must not affect whether
an element is considered empty or not.</p>

<div class="example">
 <p>Examples:</p>
 <p><code>p:empty</code> is a valid representation of the following fragment:</p>
 <pre>&lt;p&gt;&lt;/p&gt;</pre>
 <p><code>foo:empty</code> is not a valid representation for the
 following fragments:</p>
 <pre>&lt;foo&gt;bar&lt;/foo&gt;</pre>
 <pre>&lt;foo&gt;&lt;bar&gt;bla&lt;/bar&gt;&lt;/foo&gt;</pre>
 <pre>&lt;foo&gt;this is not &lt;bar&gt;:empty&lt;/bar&gt;&lt;/foo&gt;</pre>
</div>

<h4 id="content-selectors">Blank</h4> <!-- Itâ€™s the Return of Appendix H!!! Run away! -->

<p>This section intentionally left blank.  (This section previously
defined a <code>:contains()</code> pseudo-class.)</p>
<!-- (used to be :contains()) -->

<h4 id="negation">The negation pseudo-class</h4>

<p>The negation pseudo-class, <dfn data-dfn-type=selector data-export data-lt=":not()" id="sel-not">:not(<var>X</var>)</dfn>, is a
functional notation taking a <a href="#simple-selectors-dfn">simple
selector</a> (excluding the negation pseudo-class itself) as an argument.
It represents an element that is not represented by its argument.

<p>Negations may not be nested; <code>:not(:not(...))</code> is invalid.
Note also that since pseudo-elements are not simple selectors, they are
not a valid argument to <code>:not()</code>.</p>

<div class="example">
  <p>Examples:</p>
  <p>The following selector matches all <code>button</code>
  elements in an HTML document that are not disabled.</p>
  <pre>button:not([DISABLED])</pre>
  <p>The following selector represents all but <code>FOO</code>
  elements.</p>
  <pre>*:not(FOO)</pre>
  <p>The following group of selectors represents all HTML elements
  except links.</p>
  <pre>html|*:not(:link):not(:visited)</pre>
</div>

<p>Default namespace declarations do not affect the argument of the
negation pseudo-class unless the argument is a universal selector or a
type selector.</p>

<div class="example">
  <p>Examples:</p>
  <p>Assuming that the default namespace is bound to
  "http://example.com/", the following selector represents all
  elements that are not in that namespace:</p>
  <pre>*|*:not(*)</pre>
  <p>The following selector matches any element that is not being
  hovered, regardless of its namespace. In particular, it is not
  limited to only matching elements in the default namespace that are
  not being hovered, and elements not in the default namespace don't
  match the rule when they <em>are</em> being hovered.</p>
  <pre>*|*:not(:hover)</pre>
</div>

<p class="note"><strong>Note</strong>: the :not() pseudo allows
useless selectors to be written.  For instance <code>:not(*|*)</code>,
which represents no element at all, or <code>foo:not(bar)</code>,
which is equivalent to <code>foo</code> but with a higher
specificity.</p>

<h2 id="pseudo-elements">Pseudo-elements</h2>

<p>Pseudo-elements create abstractions about the document tree beyond
those specified by the document language. For instance, document
languages do not offer mechanisms to access the first letter or first
line of an elementâ€™s content. Pseudo-elements allow authors to refer
to this otherwise inaccessible information. Pseudo-elements may also
provide authors a way to refer to content that does not exist in the
source document (e.g., the <code>::before</code> and
<code>::after</code> pseudo-elements give access to generated
content).</p>

<p>A pseudo-element is made of two colons (<code>::</code>) followed
by the name of the pseudo-element.</p>

<p>This <code>::</code> notation is introduced by the current document
in order to establish a discrimination between pseudo-classes and
pseudo-elements.  For compatibility with existing style sheets, user
agents must also accept the previous one-colon notation for
pseudo-elements introduced in CSS levels 1 and 2 (namely,
<code>:first-line</code>, <code>:first-letter</code>,
<code>:before</code> and <code>:after</code>). This compatibility is
not allowed for the new pseudo-elements introduced in this specification.</p>

<p>Only one pseudo-element may appear per selector, and if present it
must appear after the sequence of simple selectors that represents the
<a href="#subject">subjects</a> of the selector. <span class="note"><strong>Note:</strong>
A future version of this specification may allow multiple pseudo-elements
per selector.</span></p>

<h3 id="first-line">The ::first-line pseudo-element</h3>

<p>The <dfn data-dfn-type=selector data-export id="sel-first-line">::first-line</dfn> pseudo-element describes the contents
of the first formatted line of an element.

<div class="example">
<p>CSS example:</p>
<pre>p::first-line { text-transform: uppercase }</pre>
<p>The above rule means "change the letters of the first line of every
<code>p</code> element to uppercase".</p>

<p>The selector <code>p::first-line</code> does not match any real
document element. It does match a pseudo-element that conforming user
agents will insert at the beginning of every <code>p</code> element.</p>
</div>

<p>Note that the length of the first line depends on a number of
factors, including the width of the page, the font size, etc.  Thus,
an ordinary HTML paragraph such as:</p>

<pre>
&lt;P&gt;This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

<p>the lines of which happen to be broken as follows:

<pre>
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag
sequence. The other lines will be treated as
ordinary lines in the paragraph.
</pre>

<p>This paragraph might be "rewritten" by user agents to include the
<em>fictional tag sequence</em> for <code>::first-line</code>. This
fictional tag sequence helps to show how properties are inherited.</p>

<pre>
&lt;P&gt;<b>&lt;P::first-line&gt;</b> This is a somewhat long HTML
paragraph that <b>&lt;/P::first-line&gt;</b> will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

<p>If a pseudo-element breaks up a real element, the desired effect
can often be described by a fictional tag sequence that closes and
then re-opens the element. Thus, if we mark up the previous paragraph
with a <code>span</code> element:</p>

<pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

<p>the user agent could simulate start and end tags for
<code>span</code> when inserting the fictional tag sequence for
<code>::first-line</code>.

<pre>
&lt;P&gt;&lt;P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

<h4 id="first-formatted-line">First formatted line definition in CSS</h4>

<p>In CSS, the <code>::first-line</code> pseudo-element can only
have an effect when attached to a block-like container such as a
block box, inline-block, table-caption, or table-cell.
In such a case, it refers to the <dfn>first formatted line</dfn> of that container.

<p>The first formatted line of an element may occur inside a
block-level descendant in the same flow (i.e., a block-level
descendant that is not out-of-flow due to floating or positioning). For example,
the first line of the <code>DIV</code> in <code>&lt;DIV>&lt;P>This
line...&lt;/P>&lt/DIV></code> is the first line of the <code>P</code> (assuming
that both <code>P</code> and <code>DIV</code> are block-level).

<p>The first line of a table-cell or inline-block cannot be the first
formatted line of an ancestor element. Thus, in <code>&lt;DIV&gt;&lt;P
STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
etcetera&lt;/DIV&gt;</code> the first formatted line of the
<code>DIV </code> is not the line "Hello".

<p class="note"><strong>Note:</strong> Note that the first line of the
<code>p</code> in this fragment: <code>&lt;p&gt&lt;br&gt;First...</code>
doesn't contain any letters (assuming the default style for <code>br</code>
in HTML 4). The word "First" is not on the first formatted line.

<p>A UA should act as if the fictional start tags of the
<code>::first-line</code> pseudo-elements were nested just inside the
innermost enclosing block-level element. (Since CSS1 and CSS2 were
silent on this case, authors should not rely on this behavior.)
For example, the fictional tag sequence for</p>

<pre>
&lt;DIV>
  &lt;P>First paragraph&lt;/P>
  &lt;P>Second paragraph&lt;/P>
&lt;/DIV>
</pre>

<p>is</p>

<pre>
&lt;DIV>
  &lt;P>&lt;DIV::first-line>&lt;P::first-line>First paragraph&lt;/P::first-line>&lt;/DIV::first-line>&lt;/P>
  &lt;P>&lt;P::first-line>Second paragraph&lt;/P::first-line>&lt;/P>
&lt;/DIV>
</pre>

<p>The <code>::first-line</code> pseudo-element is similar to an
inline-level element, but with certain restrictions. The
following CSS properties apply to a <code>::first-line</code>
pseudo-element: font properties, color property, background
properties, 'word-spacing', 'letter-spacing', 'text-decoration',
'text-transform', 'line-height'. UAs may apply other
properties as well.</p>

<p>During CSS inheritance, the portion of a child element that occurs
on the first line only inherits properties applicable to the
<code>::first-line</code> pseudo-element from the <code>::first-line</code>
pseudo-element. For all other properties inheritance is from the
non-pseudo-element parent of the first line pseudo element. (The portion
of a child element that does not occur on the first line always inherits
from the parent of that child.)

<h3 id="first-letter">The ::first-letter pseudo-element</h3>

<p>The <dfn data-dfn-type=selector data-export>::first-letter</dfn> pseudo-element represents the first
letter of an element, if it is not preceded by any
other content (such as images or inline tables) on its line. The
::first-letter pseudo-element may be used for "initial caps" and "drop
caps", which are common typographical effects.</p>

<p>Punctuation (i.e, characters defined in Unicode in the "open" (Ps),
"close" (Pe), "initial" (Pi). "final" (Pf) and "other" (Po)
punctuation classes), that precedes or follows the first letter should
be included. [[!UNICODE]]</p>

<div class="figure">
<P><img src="first-letter2.gif" alt="Quotes that precede the
first letter should be included."></p>
</div>

<p>The <code>::first-letter</code> also applies if the first letter is
in fact a digit, e.g., the "6" in "67 million dollars is a lot of
money."</p>

<p class="note"><strong>Note:</strong>
In some cases the <code>::first-letter</code> pseudo-element should include
more than just the first non-punctuation character on a line.  For
example, combining characters must be kept with their base character.
Additionally, some languages may have specific rules about how to
treat certain letter combinations.  The UA definition of
<code>::first-letter</code> should include at least the default grapheme
cluster as defined by UAX29 and may include more than that as appropriate.
In Dutch, for example, if the letter combination "ij" appears at the
beginning of an element, both letters should be considered within the
<code>::first-letter</code> pseudo-element. [[UAX29]]

<p>If the letters that would form the <code>::first-letter</code> are not in the
same element, such as "&lsquo;T" in <code>&lt;p>&lsquo;&lt;em>T...</code>, the UA
may create a <code>::first-letter</code> pseudo-element from one of the elements,
both elements, or simply not create a pseudo-element.</p>

<p>Similarly, if the first letter(s) of the block are not at the start
of the line (for example due to bidirectional reordering), then the UA
need not create the pseudo-element(s).

<div class="example">
<p>Example:</p>
<p><a name="overlapping-example">The following CSS and HTML example</a> illustrates
how overlapping pseudo-elements may interact.  The first letter of
each P element will be green with a font size of '24pt'. The rest of
the first formatted line will be 'blue' while the rest of the
paragraph will be 'red'.</p>

<pre>p { color: red; font-size: 12pt }
p::first-letter { color: green; font-size: 200% }
p::first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;</pre>

<p>Assuming that a line break will occur before the word "ends", the
<span class="index-inst" title="fictional tag sequence">fictional tag
sequence</span> for this fragment might be:</p>

<pre>&lt;P&gt;
&lt;P::first-line&gt;
&lt;P::first-letter&gt;
S
&lt;/P::first-letter&gt;ome text that
&lt;/P::first-line&gt;
ends up on two lines
&lt;/P&gt;</pre>

<p>Note that the <code>::first-letter</code> element is inside the <code>::first-line</code>
element.  Properties set on <code>::first-line</code> are inherited by
<code>::first-letter</code>, but are overridden if the same property is set on
<code>::first-letter</code>.</p>
</div>

<p>The first letter must occur on the <a
href="#first-formatted-line">first formatted line.</a> For example, in
this HTML fragment: <code>&lt;p&gt&lt;br&gt;First...</code> the first line
doesn't contain any letters and <code>::first-letter</code> doesn't
match anything (assuming the default style for <code>br</code> in HTML
4). In particular, it does not match the "F" of "First."

<h4>Application in CSS</h4>

<p>In CSS, the <code>::first-letter</code> pseudo-element applies to
block-like containers such as block, list-item, table-cell, table-caption,
and inline-block elements.
<span class="note"><strong>Note:</strong> A future version
of this specification may allow this pseudo-element to apply to more
display types.</span></p>

<p>The <code>::first-letter</code> pseudo-element can be used with all
such elements that contain text, or that have a descendant in the same
flow that contains text. A UA should act as if the fictional start tag
of the ::first-letter pseudo-element is just before the first text of
the element, even if that first text is in a descendant. </p>

<div class="example">
<p>Example:</p>
<p>The fictional tag sequence for this HTML fragment:
<pre>&lt;div>
&lt;p>The first text.</pre>
<p>is:
<pre>&lt;div>
&lt;p>&lt;div::first-letter>&lt;p::first-letter>T&lt;/...>&lt;/...>he first text.</pre>
</div>

<p>In CSS the first letter of a table-cell or inline-block cannot be the
first letter of an ancestor element. Thus, in <code>&lt;DIV&gt;&lt;P
STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt;
etcetera&lt;/DIV&gt;</code> the first letter of the <code>DIV</code> is not the
letter "H". In fact, the <code>DIV</code> doesn't have a first letter.

<p>If an element is a list item ('display: list-item'), the
<code>::first-letter</code> applies to the first letter in the
principal box after the marker. UAs may ignore
<code>::first-letter</code> on list items with 'list-style-position:
inside'. If an element has <code>::before</code> or
<code>::after</code> content, the <code>::first-letter</code> applies
to the first letter of the element <em>including</em> that content.

<div class="example">
<p>Example:</p>
<p>After the rule <code>p::before {content: "Note: "}</code>, the selector
<code>p::first-letter</code> matches the "N" of "Note".</p>
</div>

<p>In CSS a ::first-line pseudo-element is similar to an inline-level element
if its 'float' property is 'none'; otherwise, it is similar to a floated element.
The following properties that apply to <code>::first-letter</code>
pseudo-elements: font properties, 'text-decoration', 'text-transform',
'letter-spacing', 'word-spacing' (when appropriate), 'line-height',
'float', 'vertical-align' (only if 'float' is 'none'), margin
properties, padding properties, border properties, color property,
background properties.  UAs may apply other properties as well.  To
allow UAs to render a typographically correct drop cap or initial cap,
the UA may choose a line-height, width and height based on the shape
of the letter, unlike for normal elements.</p>

<div class="example">
<p>Example:</p>
<p>This CSS and HTML example shows a possible rendering of an initial cap. Note
that the 'line-height' that is inherited by the <code>::first-letter</code>
pseudo-element is 1.1, but the UA in this example has computed the
height of the first letter differently, so that it doesn't cause any
unnecessary space between the first two lines. Also note that the
fictional start tag of the first letter is inside the <span>span</span>, and thus
the font weight of the first letter is normal, not bold as the <span>span</span>:
<pre>
p { line-height: 1.1 }
p::first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p>&lt;span>Het hemelsche&lt;/span> gerecht heeft zich ten lange lesten&lt;br>
Erbarremt over my en mijn benaeuwde vesten&lt;br>
En arme burgery, en op mijn volcx gebed&lt;br>
En dagelix geschrey de bange stad ontzet.
</pre>
<div class="figure">
<p><img src="initial-cap.png" alt="Image illustrating the ::first-letter pseudo-element">
</div>
</div>

<div class="example">
<p>The following CSS will make a drop cap initial letter span about two lines:</p>

<pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P               { font-size: 12pt; line-height: 1.2 }
   P::first-letter { font-size: 200%; font-weight: bold; float: left }
   SPAN            { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

<p>This example might be formatted as follows:</p>

<div class="figure">
<P><img src="first-letter.gif" alt="Image illustrating the combined effect of the ::first-letter and ::first-line pseudo-elements"></p>
</div>

<p>The <span class="index-inst" title="fictional tag
sequence">fictional tag sequence</span> is:</p>

<pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P::first-letter&gt;
T
&lt;/P::first-letter&gt;he first
&lt;/SPAN&gt;
few words of an article in the Economist.
&lt;/P&gt;
</pre>

<p>Note that the <code>::first-letter</code> pseudo-element tags abut
the content (i.e., the initial character), while the ::first-line
pseudo-element start tag is inserted right after the start tag of the
block element.</p> </div>

<p>In order to achieve traditional drop caps formatting, user agents
may approximate font sizes, for example to align baselines. Also, the
glyph outline may be taken into account when formatting.</p>

<h3 id="selection">Blank</h3>

<p>This section intentionally left blank. (This section previously
defined a <code>::selection</code> pseudo-element.)

<h3 id="gen-content">The ::before and ::after pseudo-elements</h3>

<p>The <dfn data-dfn-type=selector data-export id="sel-before">::before</dfn>
and <dfn data-dfn-type=selector data-export id="sel-after">::after</dfn> pseudo-elements
can be used to describe generated content before or after an elementâ€™s
content. They are explained in CSS 2.1 [[!CSS21]].</p>

<p>When the <code>::first-letter</code> and <code>::first-line</code>
pseudo-elements are applied to an element having content generated
using <code>::before</code> or <code>::after</code>, they apply to the
first letter or line of the element including the generated content.</p>

<h2 id="combinators">Combinators</h2>

<h3 id=descendant-combinators>Descendant combinator</h3>

<p>At times, authors may want selectors to describe an element that is
the descendant of another element in the document tree (e.g., "an
<code>EM</code> element that is contained within an <code>H1</code>
element"). Descendant combinators express such a relationship. A
descendant combinator is <a href="#whitespace">whitespace</a> that
separates two sequences of simple selectors.  A selector of the form
"<code>A B</code>" represents an element <code>B</code> that is an
arbitrary descendant of some ancestor element <code>A</code>.

<div class="example">
 <p>Examples:</p>
 <p>For example, consider the following selector:</p>
 <pre>h1 em</pre>
 <p>It represents an <code>em</code> element being the descendant of
 an <code>h1</code> element. It is a correct and valid, but partial,
 description of the following fragment:</p>
 <pre>&lt;h1&gt;This &lt;span class="myclass"&gt;headline
is &lt;em&gt;very&lt;/em&gt; important&lt;/span&gt;&lt;/h1&gt;</pre>
 <p>The following selector:</p>
 <pre>div * p</pre>
 <p>represents a <code>p</code> element that is a grandchild or later
 descendant of a <code>div</code> element. Note the whitespace on
 either side of the "*" is not part of the universal selector; the
 whitespace is a combinator indicating that the <code>div</code> must be the
 ancestor of some element, and that that element must be an ancestor
 of the <code>p</code>.</p>
 <p>The following selector, which combines descendant combinators and
 <a href="#attribute-selectors">attribute selectors</a>, represents an
 element that (1) has the <code>href</code> attribute set and (2) is
 inside a <code>p</code> that is itself inside a <code>div</code>:</p>
 <pre>div p *[href]</pre>
</div>

<h3 id=child-combinators>Child combinators</h3>

<p>A <dfn>child combinator</dfn> describes a childhood relationship
between two elements. A child combinator is made of the
&quot;greater-than sign&quot; (U+003E, <code>&gt;</code>) character and
separates two sequences of simple selectors.


<div class="example">
 <p>Examples:</p>
 <p>The following selector represents a <code>p</code> element that is
 child of <code>body</code>:</p>
 <pre>body &gt; p</pre>
 <p>The following example combines descendant combinators and child
 combinators.</p>
 <pre>div ol&gt;li p</pre><!-- LEAVE THOSE SPACES OUT! see below -->
 <p>It represents a <code>p</code> element that is a descendant of an
 <code>li</code> element; the <code>li</code> element must be the
 child of an <code>ol</code> element; the <code>ol</code> element must
 be a descendant of a <code>div</code>. Notice that the optional white
 space around the "&gt;" combinator has been left out.</p>
</div>

<p>For information on selecting the first child of an element, please
see the section on the <code><a
href="#structural-pseudos">:first-child</a></code> pseudo-class
above.</p>

<h3 id=sibling-combinators>Sibling combinators</h3>

<p>There are two different sibling combinators: the next-sibling
combinator and the subsequent-sibling combinator. In both cases,
non-element nodes (e.g. text between elements) are ignored when
considering adjacency of elements.</p>

<h4 id=adjacent-sibling-combinators>Next-sibling combinator</h4>

<p>The <dfn>next-sibling combinator</dfn> is made of the &quot;plus
sign&quot; (U+002B, <code>+</code>) character that separates two
sequences of simple selectors. The elements represented by the two
sequences share the same parent in the document tree and the element
represented by the first sequence immediately precedes the element
represented by the second one.</p>

<div class="example">
 <p>Examples:</p>
 <p>The following selector represents a <code>p</code> element
 immediately following a <code>math</code> element:</p>
 <pre>math + p</pre>
 <p>The following selector is conceptually similar to the one in the
 previous example, except that it adds an attribute selector &mdash; it
 adds a constraint to the <code>h1</code> element, that it must have
 <code>class="opener"</code>:</p>
 <pre>h1.opener + h2</pre>
</div>


<h4 id=general-sibling-combinators>Subsequent-sibling combinator</h4>

<p>The <dfn>subsequent-sibling combinator</dfn> is made of the &quot;tilde&quot;
(U+007E, <code>~</code>) character that separates two sequences of
simple selectors. The elements represented by the two sequences share
the same parent in the document tree and the element represented by
the first sequence precedes (not necessarily immediately) the element
represented by the second one.</p>

<div class="example">
 <p>Example:</p>
 <pre>h1 ~ pre</pre>
 <p>represents a <code>pre</code> element following an <code>h1</code>. It
 is a correct and valid, but partial, description of:</p>
 <pre>&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;</pre>
</div>

<h2 id=specificity>Calculating a selector's specificity</h2>

<p>A selector's specificity is calculated as follows:</p>

<ul>
  <li>count the number of ID selectors in the selector (= a)</li>
  <li>count the number of class selectors, attributes selectors, and pseudo-classes in the selector (= b)</li>
  <li>count the number of type selectors and pseudo-elements in the selector (= c)</li>
  <li>ignore the universal selector</li>
</ul>

<p>Selectors inside <a href="#negation">the negation pseudo-class</a>
are counted like any other, but the negation itself does not count as
a pseudo-class.</p>

<p>Concatenating the three numbers a-b-c (in a number system with a
large base) gives the specificity.</p>

<div class="example">
<p>Examples:</p>
<pre>*               /* a=0 b=0 c=0 -&gt; specificity =   0 */
LI              /* a=0 b=0 c=1 -&gt; specificity =   1 */
UL LI           /* a=0 b=0 c=2 -&gt; specificity =   2 */
UL OL+LI        /* a=0 b=0 c=3 -&gt; specificity =   3 */
H1 + *[REL=up]  /* a=0 b=1 c=1 -&gt; specificity =  11 */
UL OL LI.red    /* a=0 b=1 c=3 -&gt; specificity =  13 */
LI.red.level    /* a=0 b=2 c=1 -&gt; specificity =  21 */
#x34y           /* a=1 b=0 c=0 -&gt; specificity = 100 */
#s12:not(FOO)   /* a=1 b=0 c=1 -&gt; specificity = 101 */
</pre>
</div>

<p class="note"><strong>Note:</strong> Repeated occurrences of the
same simple selector are allowed and do increase specificity.</p>

<p class="note"><strong>Note:</strong> the specificity of the styles
specified in an HTML <code>style</code> attribute is described in CSS
2.1. [[!CSS21]].</p>

<h2 id=w3cselgrammar>The grammar of Selectors</h2>

<h3 id=grammar>Grammar</h3>

<p>The grammar below defines the syntax of Selectors.  It is globally
LL(1) and can be locally LL(2) (but note that most UAs should not use
it directly, since it doesnâ€™t express the parsing conventions). The
format of the productions is optimized for human consumption and some
shorthand notations beyond Yacc (see [[!YACC]])
are used:</p>

<ul>
  <li><b>*</b>: 0 or more
  <li><b>+</b>: 1 or more
  <li><b>?</b>: 0 or 1
  <li><b>|</b>: separates alternatives
  <li><b>[ ]</b>: grouping </li>
</ul>

<p>The productions are:</p>

<pre>selectors_group
  : selector [ COMMA S* selector ]*
  ;

selector
  : simple_selector_sequence [ combinator simple_selector_sequence ]*
  ;

combinator
  /* combinators can be surrounded by whitespace */
  : PLUS S* | GREATER S* | TILDE S* | S+
  ;

simple_selector_sequence
  : [ type_selector | universal ]
    [ HASH | class | attrib | pseudo | negation ]*
  | [ HASH | class | attrib | pseudo | negation ]+
  ;

type_selector
  : [ namespace_prefix ]? element_name
  ;

namespace_prefix
  : [ IDENT | '*' ]? '|'
  ;

element_name
  : IDENT
  ;

universal
  : [ namespace_prefix ]? '*'
  ;

class
  : '.' IDENT
  ;

attrib
  : '[' S* [ namespace_prefix ]? IDENT S*
        [ [ PREFIXMATCH |
            SUFFIXMATCH |
            SUBSTRINGMATCH |
            '=' |
            INCLUDES |
            DASHMATCH ] S* [ IDENT | STRING ] S*
        ]? ']'
  ;

pseudo
  /* '::' starts a pseudo-element, ':' a pseudo-class */
  /* Exceptions: :first-line, :first-letter, :before and :after. */
  /* Note that pseudo-elements are restricted to one per selector and */
  /* occur only in the last simple_selector_sequence. */
  : ':' ':'? [ IDENT | functional_pseudo ]
  ;

functional_pseudo
  : FUNCTION S* expression ')'
  ;

expression
  /* In CSS3, the expressions are identifiers, strings, */
  /* or of the form "an+b" */
  : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
  ;

negation
  : NOT S* negation_arg S* ')'
  ;

negation_arg
  : type_selector | universal | HASH | class | attrib | pseudo
  ;</pre>


<h3 id=lex>Lexical scanner</h3>

<p>The following is the <a name=x3>tokenizer</a>, written in Flex (see
[[!FLEX]]) notation. The tokenizer is
case-insensitive.</p>

<p>The two occurrences of "\377" represent the highest character
number that current versions of Flex can deal with (decimal 255). They
should be read as "\4177777" (decimal 1114111), which is the highest
possible code point in Unicode/ISO-10646. [[!UNICODE]]</p>

<pre>%option case-insensitive

ident     [-]?{nmstart}{nmchar}*
name      {nmchar}+
nmstart   [_a-z]|{nonascii}|{escape}
nonascii  [^\0-\177]
unicode   \\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
escape    {unicode}|\\[^\n\r\f0-9a-f]
nmchar    [_a-z0-9-]|{nonascii}|{escape}
num       [0-9]+|[0-9]*\.[0-9]+
string    {string1}|{string2}
string1   \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*\"
string2   \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*\'
invalid   {invalid1}|{invalid2}
invalid1  \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*
invalid2  \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*
nl        \n|\r\n|\r|\f
w         [ \t\r\n\f]*

D         d|\\0{0,4}(44|64)(\r\n|[ \t\r\n\f])?
E         e|\\0{0,4}(45|65)(\r\n|[ \t\r\n\f])?
N         n|\\0{0,4}(4e|6e)(\r\n|[ \t\r\n\f])?|\\n
O         o|\\0{0,4}(4f|6f)(\r\n|[ \t\r\n\f])?|\\o
T         t|\\0{0,4}(54|74)(\r\n|[ \t\r\n\f])?|\\t
V         v|\\0{0,4}(58|78)(\r\n|[ \t\r\n\f])?|\\v

%%

[ \t\r\n\f]+     return S;

"~="             return INCLUDES;
"|="             return DASHMATCH;
"^="             return PREFIXMATCH;
"$="             return SUFFIXMATCH;
"*="             return SUBSTRINGMATCH;
{ident}          return IDENT;
{string}         return STRING;
{ident}"("       return FUNCTION;
{num}            return NUMBER;
"#"{name}        return HASH;
{w}"+"           return PLUS;
{w}"&gt;"           return GREATER;
{w}","           return COMMA;
{w}"~"           return TILDE;
":"{N}{O}{T}"("  return NOT;
@{ident}         return ATKEYWORD;
{invalid}        return INVALID;
{num}%           return PERCENTAGE;
{num}{ident}     return DIMENSION;
"&lt;!--"           return CDO;
"--&gt;"            return CDC;

\/\*[^*]*\*+([^/*][^*]*\*+)*\/                    /* ignore comments */

.                return *yytext;</pre>

<h2 id=profiling>Profiles</h2>

<p>Each specification using Selectors must define the subset of
Selectors it allows and excludes, and describe the local meaning of
all the components of that subset.</p>

<p>Non normative examples:

<div class="profile">
<table class="tprofile">
  <tbody>
  <tr>
    <th class="title" colspan=2>Selectors profile</th></tr>
  <tr>
    <th>Specification</th>
    <td>CSS level 1</td></tr>
  <tr>
    <th>Accepts</th>
    <td>type selectors<br>class selectors<br>ID selectors<br>:link,
      :visited and :active pseudo-classes<br>descendant combinator
     <br>::first-line and ::first-letter pseudo-elements</td></tr>
  <tr>
    <th>Excludes</th>
    <td>

<p>universal selector<br>attribute selectors<br>:hover and :focus
      pseudo-classes<br>:target pseudo-class<br>:lang() pseudo-class<br>all UI
      element states pseudo-classes<br>all structural
      pseudo-classes<br>negation pseudo-class<br>::before and ::after
      pseudo-elements<br>child combinators<br>sibling combinators

<p>namespaces</td></tr>
  <tr>
    <th>Extra constraints</th>
    <td>only one class selector allowed per sequence of simple
  selectors</td></tr></tbody></table><br><br>
<table class="tprofile">
  <tbody>
  <tr>
    <th class="title" colspan=2>Selectors profile</th></tr>
  <tr>
    <th>Specification</th>
    <td>CSS level 2</td></tr>
  <tr>
    <th>Accepts</th>
    <td>type selectors<br>universal selector<br>attribute presence and
      values selectors<br>class selectors<br>ID selectors<br>:link, :visited,
      :active, :hover, :focus, :lang() and :first-child pseudo-classes
     <br>descendant combinator<br>child combinator<br>next-sibling
      combinator<br>::first-line and ::first-letter pseudo-elements<br>::before
      and ::after pseudo-elements</td></tr>
  <tr>
    <th>Excludes</th>
    <td>

<p>substring matching attribute
      selectors<br>:target pseudo-classes<br>all UI element
      states pseudo-classes<br>all structural pseudo-classes other
      than :first-child<br>negation pseudo-class
      <br>subsequent-sibling combinators

<p>namespaces</td></tr>
  <tr>
    <th>Extra constraints</th>
    <td>more than one class selector per sequence of simple selectors (CSS1
      constraint) allowed</td></tr></tbody></table>

<p>In CSS, selectors express pattern matching rules that determine which style
rules apply to elements in the document tree.

<p>The following selector (CSS level 2) will <b>match</b> all anchors <code>a</code>
with attribute <code>name</code> set inside a section 1 header <code>h1</code>:
<pre>h1 a[name]</pre>

<p>All CSS declarations attached to such a selector are applied to elements
matching it. </div>

<div class="profile">
<table class="tprofile">
  <tbody>
  <tr>
    <th class="title" colspan=2>Selectors profile</th></tr>
  <tr>
    <th>Specification</th>
      <td>STTS 3</td>
    </tr>
  <tr>
    <th>Accepts</th>
    <td>

<p>type selectors<br>universal selectors<br>attribute selectors<br>class
      selectors<br>ID selectors<br>all structural pseudo-classes<br>
          all combinators

<p>namespaces</td></tr>
  <tr>
    <th>Excludes</th>
    <td>non-accepted pseudo-classes<br>pseudo-elements<br></td></tr>
  <tr>
    <th>Extra constraints</th>
    <td>some selectors and combinators are not allowed in fragment
      descriptions on the right side of STTS declarations.</td></tr></tbody></table>

<p>Selectors can be used in STTS 3 in two different
    manners:
<ol>
  <li>a selection mechanism equivalent to CSS selection mechanism: declarations
  attached to a given selector are applied to elements matching that selector,
  <li>fragment descriptions that appear on the right side of declarations.
</li></ol></div>

<h2 id=Conformance>Conformance and requirements</h2>

<p>This section defines conformance with the present specification only.

<p>The inability of a user agent to implement part of this specification due to
the limitations of a particular device (e.g., non interactive user agents will
probably not implement dynamic pseudo-classes because they make no sense without
interactivity) does not imply non-conformance.

<p>All specifications reusing Selectors must contain a <a
href="#profiling">Profile</a> listing the
subset of Selectors it accepts or excludes, and describing the constraints
it adds to the current specification.

<p>Invalidity is caused by a parsing error, e.g. an unrecognized token or a token
which is not allowed at the current parsing point.

<p>User agents must observe the rules for handling parsing errors:
<ul>
  <li>a simple selector containing an <a href="#nsdecl">undeclared namespace prefix</a> is invalid</li>
  <li>a selector containing an invalid simple selector, an invalid combinator
    or an invalid token is invalid. </li>
  <li>a group of selectors containing an invalid selector is invalid.</li>
</ul>

<p>Specifications reusing Selectors must define how to handle parsing
errors. (In the case of CSS, the entire rule in which the selector is
used is dropped.)</p>

<h2 id=Tests>Tests</h2>

<p>This specification has <a
href="https://test.csswg.org/harness/suite/selectors-3_dev/">a test
suite</a> allowing user agents to verify their basic conformance to
the specification. This test suite does not pretend to be exhaustive
and does not cover all possible combined cases of Selectors.</p>

<h2 id=ACKS>Acknowledgements</h2>

<p>The CSS working group would like to thank everyone who has sent
comments on this specification over the years.</p>

<p>In particular, the working group would like to extend special
thanks to Donna McManus, Justin Baker, Joel Sklar, and Molly Ives
Brower who performed the final editorial review of the last call
draft. The working group would also like to thank Adam Kuehn, Boris
Zbarsky, David Perrell, Elliotte Harold, Matthew Raymond, Ruud
Steltenpool, Patrick Garies, Anton Prowse,
and the W3C Internationalization Working Group for their
last call comments and kind words.</p>

<h2 id=references>References</h2>

<h3 id=normative-references>Normative References</h3>
<!--normative-->

<h3 id=informative-references>Informative References</h3>
<!--informative-->

<h3 id=changes>Changes</h3>

<p>Substantive since the previous Recommendation are:

  <ul>
    <li>Allowing the <a href="#structural-pseudos">Structural
     pseudo-classes</a> to match the root element. See <a
     href="http://lists.w3.org/Archives/Public/www-style/2013Apr/0246.html">minutes</a>
     and <a href="http://test.csswg.org/harness/details/selectors-3_dev/selector-structural-pseudo-root/">results</a>
     of a <a
     href="http://test.csswg.org/harness/test/selectors-3_dev/single/selector-structural-pseudo-root/format/html5/">testcase</a>.
   </ul>

</body>
</html>
