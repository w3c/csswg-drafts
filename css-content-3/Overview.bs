<pre class='metadata'>
Title: CSS Generated Content Module Level 3
Status: ED
Work Status: Exploring
Shortname: css-content
Level: 3
Group: csswg
TR: https://www.w3.org/TR/css-content-3/
ED: https://drafts.csswg.org/css-content-3/
Previous Version: https://www.w3.org/TR/2016/WD-css-content-3-20160602/
Editor: Elika J. Etemad / fantasai, W3C Invited Expert, http://fantasai.inkedblade.net/contact, w3cid 35400
Editor: Dave Cramer, Hachette Livre, dauwhe@gmail.com, w3cid 65283
Former Editor: HÃ¥kon Wium Lie, Opera Software, howcome@opera.com
Former Editor: Ian Hickson, Google, ian@hixie.ch
Ignored Terms: <datetime>, leader(), string(), target-counter(), target-counters(), target-text()
Abstract: This CSS3 Module describes how to insert content in a document.
Link Defaults: css2 (type) <uri>, css-display-3 (value) inline
Status Text: This is a very rough draft, and is not ready for implementation.
Default Highlight: css
</pre>


<!-- TODO:
 ! * Sync with CSS2.1 and GCPM
 ! * Clean up descriptions and organize into something coherent
 ! * place 'property' into marked up property elements
 ! * similarly with '::pseudo' and examples
 ! * http://lists.w3.org/Archives/Member/w3c-css-wg/2003JanMar/0170.html
 ! * string-set and co
 ! * need to increment the footnote, endnote and section-note counters
 ! * cross references, as in http://www.w3.org/Style/Group/2001/MO-css3-page-20010205
 ! * date() and time()
 ! * drop nesting
 !
 !-->

<h2 class="no-num" id="intro">
Introduction</h2>

	Authors sometimes want user agents to render content that does not come from the document tree.
	One familiar example of this is numbered headings;
	the author does not want to mark the numbers up explicitly,
	they want the user agent to generate them automatically.
	Counters and markers are used to achieve these effects.

	<div class="example">
		<pre>
		h1::before { content: counter(section) ": "; }
		</pre>
	</div>


	Similarly, authors may want the user agent to insert the word "Figure" before the caption of a figure,
	or "Chapter 7" on a line before the seventh chapter title.


	<div class="example">
		<pre>
		chapter { counter-increment: chapter; }
		chapter > title::before { content: "Chapter " counter(chapter) "\A"; }
		</pre>
	</div>


	Another common effect is replacing elements with images or other multimedia content.
	Since not all user agents support all multimedia formats,
	fallbacks may have to be provided.

	<div class="example">
		<pre>
		/* Replace &lt;logo&gt; elements with the site's logo, using a format
		 * supported by the UA */
		logo { content: url(logo.mov), url(logo.mng), url(logo.png), none; }

		/* Replace &lt;figure&gt; elements with the referenced document, or,
		 * failing that, with either the contents of the alt attribute or the
		 * contents of the element itself if there is no alt attribute */
		figure[alt] { content: attr(href url), attr(alt); }
		figure:not([alt]) { content: attr(href url), contents; }
		</pre>
	</div>

<h3 id="values">
Value Definitions</h3>

	This specification follows the <a href="https://www.w3.org/TR/CSS2/about.html#property-defs">CSS property definition conventions</a> from [[!CSS2]]
	using the <a href="https://www.w3.org/TR/css-values-3/#value-defs">value definition syntax</a> from [[!CSS-VALUES-3]].
	Value types not defined in this specification are defined in CSS Values &amp; Units [[!CSS-VALUES-3]].
	Combination with other CSS modules may expand the definitions of these value types.

	In addition to the property-specific values listed in their definitions,
	all properties defined in this specification
	also accept the <a>CSS-wide keywords</a> keywords as their property value.
	For readability they have not been repeated explicitly.

<h2 id="content-property">
Inserting and replacing content with the 'content' property</h2>

	<pre class='propdef'>
		Name: content
		Value: normal | none | [ <<content-replacement>> | <<content-list>> ] [/ [ <<string>> | <<counter>> ]+ ]?
		Initial: normal
		Applies To: all elements, tree-abiding pseudo-elements, and page margin boxes
		Inherited: no
		Percentages: n/a
		Computed Value: See prose below
		Animation type: discrete
	</pre>

	<p class=all-media>User Agents are expected to support this property on all media, including non-visual ones.</p>

	The 'content' property dictates what is rendered inside an element or pseudo-element.

	For elements, it has only one purpose:
	specifying that the element renders as normal,
	or replacing the element with an image
	(and possibly some associated "alt text").

	For pseudo-elements and margin boxes,
	it is more powerful.
	It controls whether the element renders at all,
	can replace the element with an image,
	or replace it with arbitrary inline content
	(text and images).

	<dl dfn-for="content" dfn-type=value>
		<dt><dfn>normal</dfn>
		<dd>
			For an element or page margin box, this computes to ''content/contents''.

			For ''::before'' and ''::after'', this computes to ''content/none''.

			For ''::marker'', this computes to itself (''content/normal'').

		<dt><dfn>none</dfn>
		<dd>
			On elements, this inhibits the children of the element from being rendered as children of this element,
			as if the element was empty.

			On pseudo-elements it inhibits the creation of the pseudo-element as if it had ''display: none''.

			In neither case does it prevent any pseudo-elements which have this element or pseudo-element as an <a>originating element</a> from being generated.

		<dt><dfn type><<content-replacement>></dfn>
		<dd id=replaced>
			Equal to:

			<pre class=prod><<image>></pre>

			Makes the element or pseudo-element a <a href="https://www.w3.org/TR/CSS2/conform.html#replaced-element">replaced element</a>,
			filled with the specified <<image>>.
			Its normal contents are suppressed
			and do not generate boxes,
			as if they were ''display: none''.

			If the <<image>> represents an <a>invalid image</a>,
			then it must be treated as instead representing an image with zero intrinsic width and height,
			filled with transparent black.

			Issue: The above <a>invalid image</a> behavior appears to be what Chrome is doing.
			Is this okay?
			Is there a better behavior we can/should use?

			Issue: "Zero intrinsic width and height" gives it an undefined aspect ratio,
			and sizing behavior is thus... undefined.
			At least, if you give it an explicit width or height,
			the other dimension remains at zero in Chrome.
			This might need to be explicitly defined over in the Images spec;
			needs some investigation around whether browsers act this way for 0x0 SVGs and rasters.

			Note: Replaced elements use different layout rules than normal elements.
			(In effect, it becomes equivalent to an HTML <{img}> element.)

			Note: Replaced elements do not have ''::before'' or ''::after'' pseudo-elements;
			the 'content' property replaces their entire contents.

		<dt><dfn type><<content-list>></dfn>
		<dd>
			Equal to:

			<pre class=prod>
			[ <<string>> | contents | <<image>> | <<counter>> | <<quote>> | <<target>> | <<leader()>> ]+
			</pre>

			Replaces the element's contents with one or more anonymous inline boxes
			corresponding to the specified values,
			in the order specified.
			Its normal contents are suppressed
			and do not generate boxes,
			as if they were ''display: none''.

			Each value contributes an inline box to the element's contents.
			For <<image>>, this is an inline anonymous replaced element;
			for the others, it's an anonymous inline run of text.

			If an <<image>> represents an <a>invalid image</a>,
			the user agent must do one of the following:

			* "Skip" the <<image>>, generating nothing for it.
			* Display some indication that the image can't be displayed in place of the <<image>>,
				such as a "broken image" icon.

			This specification intentionally does not define which behavior a user agent must use,
			but it must use one or the other consistently.

			Note: If the value of <<content-list>> is a single <<image>>,
			it must instead be interpreted as a <<content-replacement>>.

		<dt><dfn>/ [ <<string>> | <<counter>> ]+</dfn>
		<dd>
			Specifies the "alt text" for the element.
			See [[#alt]] for details.
			If omitted,
			the element has no "alt text".
	</dl>

	Issue: Should the contents keyword be replaced with ''content()''?

<h3 id="accessibility">
Accessibility of Generated Content</h3>

	Generated content should be searchable, selectable, and available to assistive technologies.
	The 'content' property applies to speech
	and generated content must be rendered for speech output. [[!CSS3-SPEECH]]

	Issue: Start work on an AAM for CSS.

<h3 id="alt">
Alternative Text for Accessibility</h3>

	Content intended for visual media sometimes needs alternative text for speech output or other non-visual mediums.
	The 'content' property thus accepts alternative text
	to be specified after a slash (''/'') after the last <<content-list>>.
	If such alternative text is provided,
	it must be used for speech output instead.

	This allows, for example, purely decorative text to be elided in speech output
	(by providing the empty string as alternative text),
	and allows authors to provide more readable alternatives
	to images, icons, or text-encoded symbols.

	<!--examples from CSS-PSEUDO, redone with our new syntax-->

	<div class="example">
		Here the content property is an image, so the alt value is required to provide alternative text.

		<pre>
		.new::before {
		 content: url(./img/star.png) / "New!";
			/* or a localized attribute from the DOM: attr("data-alt") */
		}
		</pre>
	</div>

	<div class="example">
		If the pseudo-element is purely decorative and its function is covered elsewhere, setting alt to the empty string can avoid reading out the decorative element. Here the ARIA attribute will be spoken as "collapsed". Without the empty string alt value, the content would also be spoken as "Black right-pointing pointer".

		<pre>
		.expandable::before {
		 content: "\25BA" / "";
		/* a.k.a. âº */
		 /* aria-expanded="false" already in DOM,
			 so this pseudo-element is decorative */
		}
		</pre>
	</div>

	<!--end copy from CSS-PSEUDO-->

<h2 id="content-values">
<<content-list>> Values and Functions</h2>

	The <<content-list>> value is used in 'content'
	to fill an element with one or more anonymous inline boxes,
	including images, strings, the values of counters, and the text value of elements.
	In this section we enumerate the possibilities.


<h3 id="strings">
String</h3>

	<dl dfn-for="content, <content-list>" dfn-type=value>
		<dt><dfn><<string>></dfn>
		<dd>
			Represents an anonymous inline box filled with the specified text.

			Note: <a>White space</a> in the string is handled the same as in literal text,
			and controlled by the properties in [[CSS-TEXT-3]] and elsewhere.
			In particular, <a>white space</a> character can collapse,
			even across multiple strings,
			such as in ''content: "First  " "  Second";'',
			which by default will render similar to <code>"First Second"</code>
			(with a single visible space between the two words).
	</dl>

<h3 id="content-uri">
<<image>></h3>

	<dl dfn-type=value dfn-for="<content-list>">
		<dt><dfn><<image>></dfn></dt>
		<dd>
			Represents an anonymous inline replaced element
			filled with the specified <<image>>.

			If the <<image>> represents an <a>invalid image</a>,
			this value instead represents nothing.
			(No inline content is added to the element,
			as if this value were "skipped".)
	</dl>

	Issue: CSS2.1 explicitly allowed the UA to substitute a broken image icon
	if the image was invalid.
	However, no browser appears to do this.
	Is this removal okay?


<h3 id="element-content">
Element Content</h3>

	<dl dfn-for="content, <content-list>" dfn-type=value>
		<dt><dfn>contents</dfn>
		<dd>
			The element's descendants.
			Since this can only be used once per element
			(you can't duplicate the children if, e.g., one is a plugin or form control),
			it is handled as follows:

			: If set on the element:
			:: Always honoured.
				Note that this is the default,
				since the initial value of 'content' is ''content/normal''
				and ''content/normal'' computes to ''content/contents'' on an element.
			: If set on one of the element's other pseudo-elements:
			:: Check to see that it is not set on a "previous" pseudo-element, in the following order, depth first:

				1. the element itself
				2. ::before
				3. ::after

				Issue: Should this behave as an empty string on pseudo-elements?

				If it is already used, then it evaluates to nothing (like ''content/none'').
				Only pseudo-elements that are actually generated are checked.
	</dl>


	<div class="example">
		In the following case:

		<pre>
		foo { content: normal; }	/* this is the initial value */
		foo::after { content: contents; }
		</pre>

		...the element's 'content' property would compute to ''content/contents''
		and the after pseudo element would have no contents
		(equivalent to ''content/none'')
		and thus would not appear.

		<pre>
		foo { content: none; }
		foo::after { content: contents; }
		</pre>

		But in this example, the ::after pseudo-element will contain the contents of the foo element.
	</div>

	ISSUE: Use cases for suppressing the content on the element and using it in a pseudo-element would be welcome.

	Note: While it is useless to include ''content/contents'' twice in a single 'content' property,
	that is not a parse error.
	The second occurrence simply has no effect,
	as it has already been used.
	It is also not a parse error to use it on a ''::marker'' pseudo-element,
	it is only during the rendering stage that it gets treated like ''content/none''.

 	Issue: Do we need the statement about marker pseudo-elements here? Or is this legacy from the old version of the spec?


<h3 id="quotes">
Quotes</h3>

	HTML has long had the <code>q</code> element,
	used to delimit quotations.
	The ''quotes'' property,
	in conjunction with the various ''*-quote'' values of the 'content' property,
	can be used to properly style such quotations.


<h4 id="quotes-property">
Specifying quotes with the 'quotes' property</h4>


	<pre class='propdef'>
		Name: quotes
		Value: auto | none | [ <<string>> <<string>> ]+
		Initial: auto
		Applies To: all elements
		Inherited: yes
		Percentages: n/a
		Computed Value: the keyword ''quotes/none'', the keyword ''quotes/auto'', or a list, each item a pair of string values
		Animation type: discrete
	</pre>

	<p class=all-media>User Agents are expected to support this property on all media, including non-visual ones.</p>

	This property specifies quotation marks for any number of embedded quotations. Values have the following meanings:

	<dl dfn-type=value dfn-for=quotes>
		<dt><dfn>none</dfn>
		<dd>
			The ''open-quote'' and ''close-quote'' values of the 'content' property
			produce no quotations marks,
			as if they were ''no-open-quote'' and ''no-close-quote'' respectively.

		<dt><dfn>auto</dfn>
		<dd>
			A typographically appropriate [=used value=] for 'quotes'
			is automatically chosen by the UA
			based on the [=content language=]
			of the element and/or its parent.

			Note: The Unicode Common Locale Data Repository [[CLDR]]
			maintains information on typographically appropriate quotation marks.
			UAs can use other sources of information as well,
			particularly as typographic preferences can vary;
			however it is encouraged to submit any improvements to Unicode
			so that the entire software ecosystem can benefit.

		<dt>[ <<string>> <<string>> ]+
		<dd>
			Values for the ''open-quote'' and ''close-quote'' values of the 'content' property
			are taken from this list of pairs of quotation marks (opening and closing).
			The first (leftmost) pair represents the outermost level of quotation,
			the second pair the first level of embedding, etc.
			The user agent must apply the appropriate pair of quotation marks according to the level of embedding.
	</dl>


<h4 id="quote-values">
The *-quote values of the content property</h4>

	<pre class="prod">
		<dfn><<quote>></dfn> = open-quote | close-quote | no-open-quote | no-close-quote
	</pre>

	<dl dfn-for="content, <content-list>, <quote>" dfn-type=value>
		<dt><dfn>open-quote</dfn>
		<dt><dfn>close-quote</dfn>
		<dd>
			These values are replaced by the appropriate string from the 'quotes' property,
			and increments (decrements) the level of nesting for quotes.
			See [[#quotes-property]] for more information.

		<dt><dfn>no-open-quote</dfn>
		<dt><dfn>no-close-quote</dfn>
		<dd>
			Inserts nothing (as in ''content/none''),
			but increments (decrements) the level of nesting for quotes.
			See [[#quotes-property]] for more information.
	</dl>



	Quotation marks are inserted in appropriate places in a document
	with the ''open-quote'' and ''close-quote'' values of the 'content' property.
	Each occurrence of ''open-quote'' or ''close-quote''
	is replaced by one of the strings from the value of 'quotes',
	based on the depth of nesting.

	''open-quote'' refers to the first of a pair of quotes,
	''close-quote'' refers to the second.
	Which pair of quotes is used depends on the nesting level of quotes:
	the number of occurrences of ''open-quote'' in all generated text before the current occurrence,
	minus the number of occurrences of ''close-quote''.
	If the depth is 0, the first pair is used,
	if the depth is 1, the second pair is used, etc.
	If the depth is greater than the number of pairs,
	the last pair is repeated.

	Note that this quoting depth is independent of
	the nesting of the source document or the formatting structure.

	Note: Quote nesting, like [[css-lists-3#inheriting-counters|counter inheritance]],
	operates on the âflattened element treeâ
	in the context of the [[DOM]].

	Some typographic styles require open quotation marks to be repeated
	before every paragraph of a quote spanning several paragraphs,
	but only the last paragraph ends with a closing quotation mark.
	In CSS, this can be achieved by inserting "phantom" closing quotes.
	The keyword ''no-close-quote'' decrements the quoting level,
	but does not insert a quotation mark.


	<div class="example">
		The following style sheet puts opening quotation marks on every paragraph in a <code>blockquote</code>, and inserts a single closing quote at the end:

		<pre>
			blockquote p:before { content: open-quote }
			blockquote p:after { content: no-close-quote }
			blockquote p:last-child::after { content: close-quote }
		</pre>
	</div>

	For symmetry, there is also a ''no-open-quote'' keyword,
	which inserts nothing,
	but increments the quotation depth by one.

	Note: If a quotation is in a different language than the surrounding text,
	it is customary to quote the text with the quote marks of the language of the surrounding text,
	not the language of the quotation itself.

	<div class="example">
		For example, French inside English:

		<blockquote>
			The device of the order of the garter is âHoni soit qui mal y pense.â
		</blockquote>

		English inside French:

		<blockquote>
			Il disait: Â«&#8197;Il faut mettre lâaction en â¹&#8197;fast forward&#8197;âº.&#8197;Â»
		</blockquote>

		A style sheet like the following will set the 'quotes' property
		so that ''open-quote'' and ''close-quote'' will work correctly on all elements.
		These rules are for documents that contain only English, French, or both.
		One rule is needed for every additional language.
		Note the use of the child combinator (">")
		to set quotes on elements based on the language of the surrounding text:

		<pre>
		:lang(fr) > * { quotes: "\00AB\2005" "\2005\00BB" "\2039\2005" "\2005\203A" }
		:lang(en) > * { quotes: "\201C" "\201D" "\2018" "\2019" }
		</pre>

		The quotation marks are shown here in a form that most people will be able to type.
		If you can type them directly, they will look like this:

		<pre>
		:lang(fr) > * { quotes: "Â«â¯" "â¯Â»" "â¹â¯" "â¯âº" }
		:lang(en) > * { quotes: "â" "â" "â" "â" }
		</pre>
	</div>

	<div class="example">
		For example, applying the following style sheet:

		<pre>
		/* Specify pairs of quotes for two levels in two languages */
		:lang(en) > q { quotes: '"' '"' "'" "'" }
		:lang(no) > q { quotes: "Â«" "Â»" "â" "â" }

		/* Insert quotes before and after Q element content */
		q::before { content: open-quote }
		q::after	{ content: close-quote }
		</pre>

		to the following HTML fragment:

		<pre class="html-example">
		&lt;html lang="en"&gt;
			&lt;head&gt;
			 &lt;title&gt;Quotes&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			 &lt;p&gt;&lt;q&gt;Quote me!&lt;/q&gt;&lt;/p&gt;
			&lt;/body&gt;
		&lt;/html&gt;
		</pre>

		would allow a user agent to produce:

		<pre>
		"Quote me!"
		</pre>

		while this HTML fragment:

		<pre class="html-example">
		&lt;html lang="no"&gt;
			&lt;head&gt;
			 &lt;title&gt;Quotes&lt;/title&gt;
			&lt;/head&gt;
			&lt;body&gt;
			 &lt;p&gt;&lt;q&gt;Tr&oslash;ndere gr&aring;ter n&aring;r &lt;q&gt;Vinsjan p&aring; kaia&lt;/q&gt; blir deklamert.&lt;/q&gt;&lt;/p&gt;
			&lt;/body&gt;
		&lt;/html&gt;
		</pre>

		would produce:

		<pre>
		Â«Tr&oslash;ndere gr&aring;ter n&aring;r âVinsjan p&aring; kaiaâ blir deklamert.Â»
		</pre>
	</div>





<h3 id="leaders">
Leaders</h3>

	A leader, sometimes known as a tab leader or a dot leader,
	is a repeating pattern used to visually connect content across horizontal spaces.
	They are most commonly used in tables of contents,
	between titles and page numbers.
	The ''leader()'' function,
	as a value for the content property,
	is used to create leaders in CSS.
	This function takes a string (the leader string),
	which describes the repeating pattern for the leader.

<h4 id="leader-function">
The ''leader()'' function</h4>

	<dl dfn-for="content, <content-list>" dfn-type=function>
		<dt><dfn lt="leader()">leader( <<leader-type>> )</dfn>
		<dd>
			Inserts a leader.
			See the section on <a href="#leaders">leaders</a> for more information.
	</dl>

	<pre class="prod">
		<dfn>leader()</dfn> = leader( <<leader-type>> )
		<dfn><<leader-type>></dfn> = dotted | solid | space | <<string>>
	</pre>

	Three keywords are shorthand values for common strings:

	<dl dfn-type=value dfn-for="leader()">
		<dt><dfn>dotted</dfn>
		<dd>Equivalent to ''leader(".")''
		<dt><dfn>solid</dfn>
		<dd>Equivalent to ''leader("_")''
		<dt><dfn>space</dfn>
		<dd>Equivalent to ''leader(" ")''
		<dt><dfn><<string>></dfn>
		<dd>
			Issue: Define this.
	</dl>

	<div class="example">
		<pre>
		ol.toc a::after {
			content: leader('.') target-counter(attr(href), page);
		}

		&lt;h1>Table of Contents&lt;/h1>
		&lt;ol class="toc">
		&lt;li>&lt;a href="#chapter1">Loomings&lt;/a>&lt;/li>
		&lt;li>&lt;a href="#chapter2">The Carpet-Bag&lt;/a>&lt;/li>
		&lt;li>&lt;a href="#chapter3">The Spouter-Inn&lt;/a>&lt;/li>
		&lt;/ol>

		</pre>

		This might result in:

		<pre>
		Table of Contents

		1. Loomings.....................1
		2. The Carpet-Bag...............9
		3. The Spouter-Inn.............13
		</pre>
	</div>

	Issue: Do leaders depend on the assumption that the content after the leader is right-aligned (end-aligned)?

<h4 id="leader-rules">
Rendering leaders</h4>

	Consider a line which contains the content before the leader (the âbefore contentâ),
	the leader,
	and the content after the leader (the âafter contentâ).
	Leaders obey the following rules:

	1. The leader string must appear in full at least once.
	2. The leader should be as long as possible
	3. Visible characters in leaders should vertically align with each other when possible.
	4. Line break characters in the leader string must be ignored.
	5. White space in the leader string follows normal CSS rules.
	6. A leader only appears between the start content and the end content.
	7. A leader only appears on a single line, even if the before content and after content are on different lines.
	8. A leader canât be the only thing on a line.

<h4 id="leader-alignment">
Procedure for rendering leaders</h4>

	1. Lay out the <var>before content</var>,
		until reaching the line where the <var>before content</var> ends.

		<pre>
		BBBBBBBBBB
		BBB
		</pre>

	2. The leader string consists of one or more glyphs,
		and is thus an inline box.
		A leader is a row of these boxes,
		drawn from the end edge to the start edge,
		where only those boxes not overlaid by the before or after content.
		On this line,
		draw the leader string,
		starting from the end edge,
		repeating as many times as possible until reaching the start edge.

		<!--start alignment so leaders broken across lines work

		use a hypothetical line block that extends across the whole containing block to avoid misalignment due to crazy floats -->

		<pre>
		BBBBBBBBBB
		..........
		</pre>

	3. Draw the before and after content on top of the leader.
		If any part of the <var>before content</var> or <var>after content</var>
		overlaps a glyph in a leader string box,
		that glyph is not displayed.

		<pre>
		BBBBBBBBBB
		BBB....AAA
		</pre>

	4. If one full copy of the leader string is not visible:

		<pre>
		BBBBBBB
		BBBBBBA
		</pre>

		Insert a line break after the <var>before content</var>,
		draw the leader on the next line,
		and draw the <var>after content</var> on top,
		and hide any leader strings that are not fully displayed.

		<pre>
		BBBBBBB
		BBBBBB
		......A
		</pre>

	<!--put var around before and after content

	define your terms	-->

	Issue: what to do if <var>after content</var> is wider than the line box?

	Issue: Leaders don't quite work in table layouts. How can we fix this?

	<figure>
		<img src="images/leader.001.jpg" width="480" alt="drawing leaders"/>
		<figcaption>Procedure for drawing leaders</figcaption>
	</figure>

	<figure>
		<img src="images/leader.002.jpg" width="480" alt="drawing leaders"/>
		<figcaption>Procedure for drawing leaders when the content doesnât fit on a single line</figcaption>
	</figure>



<h3 id="cross-references">
Cross references and the target-* functions</h3>

	Many documents contain internal references:

	<div class=example>
		* See chapter 7
		* in section 4.1
		* on page 23
	</div>

	Three new values for the content property
	are used to automatically create these types of cross-references:
	''target-counter()'', ''target-counters()'', and ''target-text()''.
	Each of these displays information obtained from the target end of a link.

	<pre class="prod">
		<dfn><<target>></dfn> = <<target-counter()>> | <<target-counters()>> | <<target-text()>>
	</pre>

	See sections below for details on each of these.



<h4 id="target-counter">
The ''target-counter()'' function</h4>

	<pre class="prod">
		<dfn>target-counter()</dfn> = target-counter( [ <<string>> | <<url>> ] , <<custom-ident>> , <<counter-style>>? )
	</pre>

	The ''target-counter()'' function retrieves the value
	of the innermost counter with a given name.
	The required arguments are the url of the target
	and the name of the counter.
	An optional counter-style argument can be used to format the result.

	These functions only take a fragment URL
	which points to a location in the current document.
	If thereâs no fragment,
	if the ID referenced isn't there,
	or if the URL points to an outside document,
	the user agent must treat that as an error.

	Issue: what should error handling be?

	Issue: restrict syntactically to local references for now.

	<div class="example">
		HTML:

		<pre>
		â¦which will be discussed on page &lt;a href="#chapter4_sec2">&lt;/a>.
		</pre>

		CSS:

		<pre>
		a::after { content: target-counter(attr(href url), page) }
		</pre>

		Result:

		<pre>
		â¦which will be discussed on page 137.
		</pre>
	</div>

	<div class="example">
		Page numbers in tables of contents can be generated automatically:

		HTML:

		<pre>
		&lt;nav>
			&lt;ol>
			 &lt;li class="frontmatter">&lt;a href="#pref_01">Preface&lt;/a>&lt;/li>
			 &lt;li class="frontmatter">&lt;a href="#intr_01">Introduction&lt;/a>&lt;/li>
			 &lt;li class="bodymatter">&lt;a href="#chap_01">Chapter One&lt;/a>&lt;/li>
			&lt;/ol>
		&lt;/nav>
		</pre>

		CSS:

		<pre>
		.frontmatter a::after { content: leader('.') target-counter(attr(href url), page, lower-roman) }
		.bodymatter a::after { content: leader('.') target-counter(attr(href url), page, decimal) }
		</pre>

		Result:

		<pre>
		Preface.............vii
		Introduction.........xi
		Chapter One...........1
		</pre>
	</div>



<h4 id="target-counters">
The ''target-counters()'' function
</h4>

	This functions fetches the value of all counters of a given name
	from the end of a link,
	and formats them by inserting a given string between the value of each nested counter.

	<pre class="prod">
		<dfn>target-counters()</dfn> = target-counters( [ <<string>> | <<url>> ] , <<custom-ident>> , <<string>> , <<counter-style>>? )
	</pre>

	<div class="example">
		<pre>
		I have not found a compelling example for target-counters() yet.
		</pre>

		Issue: found a compelling example, in CSS specs. Do something.
	</div>

<h4 id="target-text">
The ''target-text()'' function</h4>

	The ''target-text()'' function retrieves
	the text value of the element referred to by the URL.
	An optional second argument specifies what content is retrieved,
	using the same values as the 'string-set' property above.

	<pre class="prod">
		<dfn id="target-text-function">target-text()</dfn> = target-text( [ <<string>> | <<url>> ] , [ content | before | after | first-letter ]? )
	</pre>


	Issue: A simpler syntax has been proposed by fantasai:
	<a href="http://lists.w3.org/Archives/Public/www-style/2012Feb/0745.html">http://lists.w3.org/Archives/Public/www-style/2012Feb/0745.html</a>

	<div class="example">
		<pre>
		â¦which will be discussed &lt;a href="#chapter_h1_1">later&lt;/a>.

		a::after { content: ", in the chapter entitled " target-text(attr(href url)) }
		</pre>

		Result: â¦which will be discussed later, in the chapter entitled Loomings.
	</div>


<h3 id="named-strings">
Named strings</h3>

	This section introduces <dfn lt="named string">named strings</dfn>,
	which are the textual equivalent of counters
	and which have a distinct namespace from counters.
	Named strings follow the same nesting rules as counters.
	The 'string-set' property accepts values similar to the 'content' property,
	including the extraction of the current value of counters.

	Named strings are a convenient way to pull metadata out of the document
	for insertion into headers and footers.
	In HTML, for example,
	META elements contained in the document HEAD
	can set the value of named strings.
	In conjunction with attribute selectors,
	this can be a powerful mechanism:

	<div class="example">
		<pre>
		meta[author] { string-set: author attr(author); }
		head &gt; title { string-set: title contents; }
		@page:left {
			@top {
			 text-align: left;
			 vertical-align: middle;
			 content: string(title);
			}
		}
		@page:right {
			@top {
			 text-align: right;
			 vertical-align: middle;
			 content: string(author);
			}
		}
		</pre>
	</div>



	<!--Begin insert from GCPM3 -->


<h4 id="string-set">
The string-set property</h4>

	<pre class="propdef">
	Name: string-set
	Value: none | [ <<custom-ident>> <<string>>+ ]#
	Initial: none
	Applies to: all elements, but not pseudo-elements
	Inherited: no
	Percentages: N/A
	Computed value: the keyword ''string-set/none'' or a list, each item an identifier paired with a list of string values
	Animation type: discrete
	</pre>

	<p class=all-media>User Agents are expected to support this property on all media, including non-visual ones.</p>

	The 'string-set' property copies the text content of an element into a ''named string'',
	which functions as a variable.
	The text content of this named string can be retrieved using the ''string()'' function.
	Since these variables may change on a given page,
	an optional second value for the ''string()'' function
	allows authors to choose which value on a page is used.

	<dl dfn-type=value dfn-for=string-set>
		<dt><dfn>none</dfn>
		<dd>
			The element does not set any named strings.

		<dt><code>[ <<custom-ident>> <<string>>+ ]#</code>
		<dd>
			The element establishes one or more named strings,
			corresponding to each comma-separated entry in the list.

			For each entry, the <<custom-ident>> gives the name of the named string.
			It's followed by one or more <<string>> values,
			which are concatenated together to form the value of the named string.
	</dl>

<!--end of insert from GCPM3 -->
	If an element has <a>style containment</a>,
	the 'string-set' property must have no effects on descendants of that element.


	<div class="example">
		The following example captures the contents of H1 elements,
		which represent chapter names in this hypothetical document.

		<pre>H1 { string-set: chapter contents; }</pre>

		When an H1 element is encountered,
		the ''chapter'' string is set to the element's textual contents,
		and the previous value of ''chapter'', if any, is overwritten.
	</div>


<h4 id="string-function">
The ''string()'' function</h4>

	<pre class="prod">
		<dfn>string()</dfn> = string( <<custom-ident>> , [ first | start | last | first-except ]? )
	</pre>

	The ''string()'' function is used to copy the value of a named string to the document,
	via the 'content' property.
	This function requires one argument,
	the name of the named string.
	Since the value of a named string may change several times on a page
	(as multiple elements defining the string can appear)
	an optional second argument indicates which value of the named string should be used.

	The second argument of the ''string()'' function is one of the following keywords:

	<dl dfn-type="value" dfn-for="string()">
		<dt><dfn>first</dfn>
		<dd>
			The value of the first assignment on the page is used.
			If there is no assignment on the page,
			the <a>entry value</a> is used.
			If no second argument is provided,
			this is the default value.

		<dt><dfn>start</dfn>
		<dd>
			If the element is the first element on the page,
			the value of the first assignment is used.
			Otherwise the <a>entry value</a> is used.
			The <a>entry value</a> may be empty if the <a>named string</a> hasnât yet appeared.

		<dt><dfn>last</dfn>
		<dd>
			The <a>exit value</a> of the named string is used.

		<dt><dfn>first-except</dfn>
		<dd>
			This is identical to ''string()/first'',
			except that the empty string is used on the page where the value is assigned.

			Issue: we may need to kill the entire content string. Is this necessary?
	</dl>

	The content values of named strings
	are assigned at the point when the content box of the element is first created
	(or would have been created if the elementâs display value is none).
	The <dfn>entry value</dfn> for a page
	is the assignment in effect at the end of the previous page.
	The <dfn>exit value</dfn> for a page
	is the assignment in effect at the end of the current page.

	<div class="example">
		CSS:

		<pre>
		@page {
			size: 15cm 10cm;
			margin: 1.5cm;

			@top-left {
			content: "first: " string(heading, first);
			}
			@top-center {
			content: "start: " string(heading, start);
			}
			 @top-right {
			 content: "last: " string(heading, last);
			}
			}

		h2 { string-set: heading content() }
		</pre>

		The following figures show the first, start, and last assignments
		of the âheadingâ string on various pages.

		<figure>
			<img src="images/using-strings-1.jpg" width="480" alt=""/>
			<figcaption>The ''string-set/start'' value is empty,
			as the string had not yet been set at the start of the page.</figcaption>
		</figure>

		<figure>
			<img src="images/using-strings-2.jpg" width="480" alt=""/>
			<figcaption>Since the page starts with an h2,
			the ''string-set/start'' value is the value of that head.</figcaption>
		</figure>

		<figure>
			<img src="images/using-strings-3.jpg" width="480" alt=""/>
			<figcaption>Since thereâs not an h2 at the top of this page,
			the ''string-set/start'' value is the <a>exit value</a> of the previous page.</figcaption>
		</figure>
	</div>



<h4 id="content-function">
The ''content()'' function</h4>

	<pre class="prod">
		<dfn>content()</dfn> = content( [ text | before | after | first-letter | marker ]? )
	</pre>

	<dl dfn-type="value" dfn-for="content()">
		<dt><dfn>text</dfn>
		<dd>The string value of the element.
			If no value is specified in ''content()'',
			it acts as if ''content()/text'' were specified.

		<dt><dfn>before</dfn>
		<dd>The string value of the ''::before'' pseudo-element.

		<dt><dfn>after</dfn>
		<dd>The string value of the ''::after'' pseudo-element.

		<dt><dfn>first-letter</dfn>
		<dd>The first letter of the element, as defined for the ''::first-letter'' pseudo-element

		<dt><dfn>marker</dfn>
		<dd>The string value of the ''::marker'' pseudo-element.
	</dl>

	<div class="example">
		HTML:

		<pre>
		&lt;h1>Loomings&lt;/h1>
		</pre>

		CSS:

		<pre>
		h1::before { content: 'Chapter ' counter(chapter); }
		h1 { string-set: header content(before) ':' content(text); }
		h1::after { content: '.'; }
		</pre>

		The value of the named string âheaderâ will be âChapter 1: Loomingsâ.
	</div>

	<div class="example">
		HTML:

		<pre>
		&lt;section title="Loomings">
		</pre>

		CSS:

		<pre>
		section { string-set: header attr(title) }
		</pre>

		The value of the âheaderâ string will be âLoomingsâ.
	</div>


<h2 id="counters">
Automatic counters and numbering: the 'counter-increment' and 'counter-reset' properties (moved)</h2>

	Issue: Now described in [[CSS3LIST]]

	Issue: Should this move back to CSS Content?


<h2 id="bookmark-generation">
Bookmarks</h2>

	Some document formats,
	most notably PDF,
	allow the use of <dfn>bookmarks</dfn> as an aid to navigation.
	Bookmarks provide a list of links to document elements,
	as well as text to label the links and a level value.
	A bookmark has three properties:
	'bookmark-level', 'bookmark-label', and 'bookmark-state'.

	When a user activates a bookmark,
	the user agent must bring that reference point to the user's attention,
	exactly as if navigating to that element by fragment URL.
	<span class="note">This will also trigger matching the '':target'' pseudo-class.</span>

	If an element has <a>style containment</a>, the
	'bookmark-level', 'bookmark-label', and 'bookmark-state' properties
	must have no effect on descendants of the element.

<h3 id="bookmark-level">
bookmark-level
</h3>

	The 'bookmark-level' property determines if a bookmark is created,
	and at what level.
	If this property is absent,
	or has value ''bookmark-level/none'',
	no bookmark should be generated,
	regardless of the values of 'bookmark-label' or 'bookmark-state'.

	<pre class="propdef">
	Name: bookmark-level
	Value: none | <<integer>>
	Initial: none
	Applies to: all elements
	Inherited: no
	Percentages: N/A
	Computed value: the keyword ''bookmark-level/none'' or the specified integer
	Animation type: by computed value type
	</pre>

	<dl dfn-type="value" dfn-for="bookmark-level">
		<dt><dfn><<integer>></dfn>
		<dd>defines the level of the bookmark, with the top level being 1 (negative and zero values are invalid).
		<dt><dfn>none</dfn>
		<dd>no bookmark is generated.
	</dl>

	<div class="example">
		<pre>
		section h1 { bookmark-level: 1; }
		section section h1 { bookmark-level: 2; }
		section section section h1 { bookmark-level: 3; }
		</pre>
	</div>

	Note: Bookmarks do not need to create a strict hierarchy of levels.

	Issue: Should a bookmark be created for elements with <code>display: none</code>?


<h3 id="bookmark-label">
bookmark-label</h3>

	<pre class="propdef">
	Name: bookmark-label
	Value: <<content-list>>
	Initial: content(text)
	Applies to: all elements
	Inherited: no
	Percentages: N/A
	Computed value: specified value
	Animation type: discrete
	</pre>

	<dl dfn-type="value" dfn-for="bookmark-label">
		<dt><dfn><<content-list>></dfn>
		<dd><<content-list>> is defined above, in the section on the 'string-set' property. The value of <<content-list>> becomes the text content of the bookmark label.

		<!--
		<dt>none
		<dd>no bookmark is generated.
		 -->
	</dl>

	<div class="example">
		HTML:

		<pre>
		&lt;h1>Loomings&lt;/h1>
		</pre>

		CSS:

		<pre>
		h1 {
		bookmark-label: content(text);
		bookmark-level: 1;
		}
		</pre>

		The bookmark label will be âLoomingsâ.
	</div>

<h3 id="bookmark-state">
bookmark-state</h3>

	The 'bookmark-state' may be open or closed. The user must be able to toggle the bookmark state.

	<pre class="propdef">
	Name: bookmark-state
	Value: open | closed
	Initial: open
	Applies to: block-level elements
	Inherited: no
	Percentages: N/A
	Computed value: specified keyword
	Animation type: discrete
	</pre>

	<dl dfn-type="value" dfn-for="bookmark-state">
		<dt><dfn>open</dfn>
		<dd>
			Subsequent bookmarks with 'bookmark-level' greater than the given bookmark are displayed,
			until reaching another bookmark of the same level or lower.
			If one of subsequent bookmark is closed,
			apply the same test to determine if its subsequent bookmarks should be displayed.

		<dt><dfn>closed</dfn>
		<dd>
			Subsequent bookmarks of bookmark-level greater than the given bookmark are not displayed,
			until reaching another bookmark of the same level or lower.
	</dl>

	Issue: Is the initial bookmark state,
	or the bookmark state updated by the UA as appropriate?

	<!-- hehe. I expect at least one person to complain about this and suggest that ::before and ::after on replaced content becomes sibling content. Well, they will need to explain:

		* how this works with floats and abs pos content (is it moving both, does it leave the gen con in-flow...)

		* how this works with rel pos content (what moves?)

		* what ::outside::before matches in this case
	-->

<h2 id="changes">Changes since the 2 June 2016 Working Draft</h2>

	Significant changes since the <a href="https://www.w3.org/TR/2016/WD-css-content-3-20160602/">2 June 2016 Working Draft</a>
	consist primarily of:

	<ul>
		<li>Adding ''quotes/auto'' as the initial value of 'quotes'.
		<li>Lots of miscellaneous spec clean up: errors, cross-references, overly-loose or sloppy definitions, etc.
	</ul>

	See also <a href="https://www.w3.org/TR/2016/WD-css-content-3-20160602/#changes">previous changes</a>.

<h2 class="no-num" id="acknowledgements">Acknowledgements</h2>

	Stuart Ballard,
	David Baron,
	Bert Bos,
	<span lang="tr">Tantek Ãelik</span>,
	and James Craig
	provided invaluable suggestions used in this specification.


