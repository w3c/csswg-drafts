<pre class='metadata'>
Title: CSS Gap Decorations Module Level 1
Shortname: css-gaps
Level: 1
Status: ED
Prepare for TR: no
Group: csswg
Work Status: exploring
Repository: w3c/csswg-drafts
URL: https://drafts.csswg.org/css-gaps-1/
TR: https://www.w3.org/TR/css-gaps-1/
Editor: Kevin Babbitt, Microsoft, https://github.com/kbabbitt, w3cid 124689
Abstract: This module introduces several properties to add row and column gap decorations to container layout types such as grid and flex.
WPT Path Prefix: css/css-gaps/
WPT Display: open
</pre>
<pre class='anchors'>
urlPrefix: https://drafts.csswg.org/css-grid-3/; type: dfn; spec: CSS-GRID-3; text: grid lanes container
</pre>
<pre class='link-defaults'>
spec:css-backgrounds-3; type:type; text:<line-style>
spec:css-backgrounds-3; type:type; text:<line-width>
spec:css-backgrounds-3; type:value; for:<line-style>; text:hidden
spec:css-backgrounds-3; type:value; for:<line-style>; text:none
spec:css-color-5; type:type; text:<color>
</pre>

<h2 id="intro">
Introduction</h2>

	<em>This section is not normative.</em>

	[[CSS-MULTICOL-1#column-gaps-and-rules]] allows for rules to be drawn
	between columns in a <a>multicol container</a>. This specification expands
	upon the 'column-rule-width', 'column-rule-style', and 'column-rule-color'
	properties, adding equivalents in the row direction, expanding their
	application to other container layouts, and giving advanced control over
	where and how gap decorations are painted.

<h3 id="values">
Value Definitions</h3>

	This specification follows the <a href="https://www.w3.org/TR/CSS2/about.html#property-defs">CSS property definition conventions</a> from [[!CSS2]]
	using the <a href="https://www.w3.org/TR/css-values-3/#value-defs">value definition syntax</a> from [[!CSS-VALUES-3]].
	Value types not defined in this specification are defined in CSS Values &amp; Units [[!CSS-VALUES-3]].
	Combination with other CSS modules may expand the definitions of these value types.

	In addition to the property-specific values listed in their definitions,
	all properties defined in this specification
	also accept the <a>CSS-wide keywords</a> as their property value.
	For readability they have not been repeated explicitly.

   <h2 id="gaps">
   Gaps</h2>

	Various layouts in CSS such as
	<a>multicol containers</a>, <a>flex containers</a>, <a>grid containers</a>, and <a>masonry containers</a>
	position child boxes adjacent to each other with [=gaps=], between them.

	For the purposes of this specification, <dfn>gap</dfn>, <dfn>column gap</dfn>, and <dfn>row gap</dfn> are defined as follows depending on the type of container:

	<dl>
		<dt id="gap-multicol"><a>multi-column containers</a>
		<dd>
			In the column direction, [=gap=] ([=column gap=]) refers to the [=gutter=] between adjacent <a>column boxes</a> within each [=multicol line=],
			see [[CSS-MULTICOL-1]].
			In the row direction, [=gap=] ([=row gap=]) refers to the [=gutter=] between the rows of [=column boxes=] established by 'column-height',
			see [[CSS-MULTICOL-2]].

		<dt id="gap-flex"><a>flex containers</a>
		<dd>
			In the <a>main axis</a>
			(e.g. 'column-gap' in a ''flex-flow/row'' <a>flex container</a>),
			[=gap=] ([=column gap=]) refers to the [=gutter=] between items within a single [=flex line=].

			In the <a>cross axis</a>
			(e.g. 'row-gap' in a ''flex-flow/row'' <a>flex container</a>),
			[=gap=] ([=row gap=]) refers to the [=gutter=] between adjacent <a>flex lines</a>.
		<dt id="gap-grid"><a>grid containers</a>
		<dd>
			[=row gap=]s and [=column gap=]s
			refer to the [=gutters=] between <a>grid rows</a> and <a>grid columns</a>,
			respectively.
			See [[css-grid-1#gutters]] for precise details.
	</dl>

	<div class="example">
		<figure>
			<img alt="" src="images/grid-gaps.png">
			<figcaption>Gaps in a grid container (in orange and blue).</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/flex-gaps.png">
			<figcaption>Gaps in a flex container (in orange and blue).</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/multicol-gaps.png">
			<figcaption>Gaps in a multicol container with `column-wrap: wrap` (in orange and blue).</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/multicol-gaps-2.png">
			<figcaption>Column gaps (orange) in a multicol container with a spanner element.</figcaption>
		</figure>
	</div>


<h2 id="gap-decorations">
Gap decorations</h2>

	Various layouts in CSS such as
	<a>multicol containers</a>, <a>flex containers</a>, <a>grid containers</a>, and <a>grid lanes containers</a>
	position child boxes adjacent to each other with gaps, also known as <a>gutters</a>, between them.
	Each such gap may contain a <dfn>gap decoration</dfn>,
	which is a visible separator (such as a line) painted between adjacent boxes.

	<div class="example">
		<pre>
			.grid-with-spans {
			  display: grid;
			  grid-template: repeat(4, 100px) / repeat(4, 100px);
			  gap: 20px;
			  row-rule: 6px solid red;
			  column-rule: 6px solid blue;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-grid-with-spans.png">
			<figcaption>A grid with spanning items and gap decorations.</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.flex {
			  display: flex;
			  flex-wrap: wrap;
			  gap: 20px;
			  width: 500px;
			  row-rule: 6px solid red;
			  column-rule: 6px solid blue;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-flex.png">
			<figcaption>A flexbox with gap decorations.</figcaption>
		</figure>
	</div>

	<wpt>
		serialization/gap-decorations-properties.html
	</wpt>

<h3 id="layout-painting">
Layout and painting</h3>

	<a>Gap decorations</a> do not take up space.
	That is, the presence or width of a <a>gap decoration</a> will not alter the placement of anything else.
	If a <a>gap decoration</a> is wider than its gap,
	any adjacent boxes will overlap the decoration,
	and in some cases the decoration may extend outside the box of the container.
	<a>Gap decorations</a> are painted just above the border of the container.
	For scrollable containers,
	note that while the border and background of the container aren't scrolled,
	the decorations need to scroll along with items in the container.

	Gap Decorations are painted within a gap as one or more gap decoration segments.

<h4 id="segment-endpoints">
Segment Endpoints</h4>

	A gap <dfn>segment endpoint</dfn> is a point on a gap's centerline where a <a>gap decoration segment</a>
	may start or end.
	There are two endpoint types:
	<ul>
		<li><dfn>start segment endpoint</dfn>: Point at which a segment begins.
		<li><dfn>end segment endpoint</dfn>: Point at which a segment ends.
	</ul>

	Endpoints are positioned on the centerline of the gap they belong to and are created at the following junctions:

	<ol>
		<li>Bounds of a Gap:
			<p>For each gap, endpoints are created at its two bounds:
			<ul>
				<li>At the start of the gap, a <a>start segment endpoint</a> is created.
				<li>At the end of the gap, an <a>end segment endpoint</a> is created.
			</ul>
			<p class="note">When a gap runs to the content boundary, these endpoints coincide with the corresponding content edge.

		<li>Within a Gap:
			<p>When a cross/perpendicular gap touches a given gap (either overlapping it, or abutting it without overlapping),
			two endpoints are created which align with the boundaries of the cross/perpendicular gap:
			<ul>
				<li>The earlier boundary creates an <a>end segment endpoint</a>.
				<li>The later boundary creates a <a>start segment endpoint</a>.
			</ul>
			<p class="note">This ordering (end segment endpoint, start segment endpoint) reflects that the junction corresponds to
			the end of one track/item/column-box and the beginning of the next.
	</ol>
	The following examples illustrate the locations of <a>segment endpoints</a>,
	with a cyan <span style="color:#0ff">+</span> for <a> start segment endpoints</a> and a
	magenta <span style="color:#f0f">+</span> for <a> end segment endpoints</a> in each case.

	<div class="example">
		<pre>
			.grid-with-spans {
  			  display: grid;
  			  grid-template: repeat(4, 100px) / repeat(4, 100px);
  			  gap: 20px;
  			  background: rgb(255 255 128);
			}
			.grid > * {
  			  border: 1px dashed black;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-grid-segment-endpoints.png">
			<figcaption>
				Locations of <a>segment endpoints</a> in a grid with spanning items.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.flex {
			  display: flex;
			  flex-wrap: wrap;
			  gap: 20px;
			  width: 500px;
			  background: rgb(255 255 128);
			}
			.flex > * {
			  border: 1px dashed black;
			}
		</pre>
		<figure>
			<img alt="" src="images/flex-and-segment-endpoints.png">
			<figcaption>Locations of <a>segment endpoints</a> in a flex container.</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.multi-column {
			  column-count: 3;
			  column-width: 100px;
			  column-height: 50px;
			  column-wrap: wrap;
			  gap: 20px;
			  background: rgb(255 255 128);
			}

			.multi-column > * {
			  height: 100px;
			  border: 1px dashed black;
			}	
		</pre>
		<figure>
			<img alt="" src="images/multi-col-segment-endpoints.png">
			<figcaption>Locations of <a>segment endpoints</a> in a multi-column container.</figcaption>
		</figure>
	</div>

	<p class="note">NB: Should I mention different layout types and their gap behaviors here? Or is it implied? From preceeding sections. Feel Like I should for emphasis.
<wpt>
		flex/flex-gap-decorations-001.html
		flex/flex-gap-decorations-006.html
		flex/flex-gap-decorations-007.html
		flex/flex-gap-decorations-008.html
		flex/flex-gap-decorations-015.html
		flex/flex-gap-decorations-016.html
		grid/grid-gap-decorations-001.html
		multicol/multicol-gap-decorations-001.html
		multicol/multicol-gap-decorations-002.html
		multicol/multicol-gap-decorations-003.html
		multicol/multicol-gap-decorations-005.html
		multicol/multicol-gap-decorations-006.html
		multicol/multicol-gap-decorations-007.html
		multicol/multicol-gap-decorations-013.html
		multicol/multicol-gap-decorations-015.html
		multicol/multicol-gap-decorations-016.html
	</wpt>

	<h4 id="segments">
	Gap decoration segments</h4>

	A <dfn>gap decoration segment</dfn> is formed by pairing a [=start segment endpoint=] with an [=end segment endpoint=].
	Each [=gap=] is a collection of <i>n</i> [=gap decoration segment=]s, where <i>n > 0</i>.

	<div algorithm>
		To <dfn>determine the gap decoration segments</dfn> for a given [=gap=] |G|:
		<ul>
			<li>
				Let |S|, the collection of [=gap decoration segment=]s for |G|, be an empty list.
			</li>
			<li>
				Let |endpoints| be the list of <a>segment endpoint</a>s that fall along the centerline of |G|,
				ordered from start to end along |G|'s axis.
			</li>
			<li>
				Let |starts| be an empty stack.
			</li>
			<li>
				For each [=segment endpoint=] |a| in |endpoints|:
				<ol>
					<li>
						If |a| is a [=start segment endpoint=], push |a| onto |starts|.
					</li>
					<li>
						If |a| is an [=end segment endpoint=]:
						<ol>
							<li>
								If |starts| is not empty:
								<ol>
									<li>
										Pop the topmost [=start segment endpoint=] |b| from |starts|.
									</li>
									<li>
										Create a new [=gap decoration segment=] from |b| to |a|, and append it to |S|.
									</li>
								</ol>
							</li>
							<li>
								Otherwise, there is no matching [=start segment endpoint=] for |a|; ignore |a|.
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ul>
	</div>

	
	Note that this should result in <strong>no</strong> overlapping [=gap decoration segment=]s in |S|.

	In the end, there may remain  unpaired [=segment endpoint=]s in |endpoints| (or in |starts|). 
	These result in <dfn>negative gap decoration segment</dfn>s. 
	These are segments that would end up <em>overlapping</em> with other [=gap decoration segment=]s,
	as a result these are purposefully ignored and no decoration is painted for them. See below for an example.

	<div class="example">
		<figure>
			<img alt="" src="images/flex-gap-decoration-segments.png">
			<figcaption>
				Illustration of <a>gap decoration segment</a>s (blue rectangles) in a flex container.
				The segments are drawn between pairs of <a>segment endpoint</a>s,
				with <a>start segment endpoint</a>s marked with cyan crosses and <a>end segment endpoint</a>s marked with pink crosses.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/grid-gap-decoration-segments.png">
			<figcaption>
				Illustration of <a>gap decoration segment</a>s (blue rectangles) in a grid container.
				The segments are drawn between pairs of <a>segment endpoint</a>s,
				with <a>start segment endpoint</a>s marked with cyan crosses and <a>end segment endpoint</a>s marked with pink crosses.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/multicol-gap-decoration-segments.png">
			<figcaption>
				Illustration of <a>gap decoration segment</a>s (blue rectangles) in a multicol container (with column-wrap: wrap).
				The segments are drawn between pairs of <a>segment endpoint</a>s,
				with <a>start segment endpoint</a>s marked with cyan crosses and <a>end segment endpoint</a>s marked with pink crosses.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/multicol-gap-decoration-segments-2.png">
			<figcaption>
				Illustration of <a>gap decoration segment</a>s (blue rectangles) in a multicol container (with a spanner element).
				The segments are drawn between pairs of <a>segment endpoint</a>s,
				with <a>start segment endpoint</a>s marked with cyan crosses and <a>end segment endpoint</a>s marked with pink crosses.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<figure>
			<img alt="" src="images/flex-negative-gap-decoration-segments.png">
			<figcaption>
				Illustration of <a>gap decoration segment</a>s (blue rectangles) in a flex container, where we end up with <a>negative gap decoration segment</a>s.
				The segments are drawn between pairs of <a>segment endpoint</a>s,
				with <a>start segment endpoint</a>s marked with cyan crosses and <a>end segment endpoint</a>s marked with pink crosses.

				In this example there is one pair of unprocessed <a>segment endpoint</a>s (which form a <a>negative gap decoration segment</a>).
				These are marked with green and black crosses, these used to be a <a>end segment endpoint</a> and <a>start segment endpoint</a> respectively.
				Note that no decoration will be painted for these segments, so we don't see any blue rectangle between these two points.
			</figcaption>
		</figure>
	</div>

	<div class="example">
	<figure>
			<img alt="" src="images/flex-negative-gap-decoration-segments-2.png">
			<figcaption>
				Illustration of <a>gap decoration segment</a>s (blue rectangles) in a flex container, where we end up with <a>negative gap decoration segment</a>s.
				The segments are drawn between pairs of <a>segment endpoint</a>s,
				with <a>start segment endpoint</a>s marked with cyan crosses and <a>end segment endpoint</a>s marked with pink crosses.

				In this example there is one pair of unprocessed <a>segment endpoint</a>s (which form a <a>negative gap decoration segment</a>).
				These are marked with green and black crosses, these used to be a <a>end segment endpoint</a> and <a>start segment endpoint</a> respectively.
				Note that no decoration will be painted for these segments, so we don't see any blue rectangle between these two points.
			</figcaption>
		</figure>
	</div>


<h3 id="break">
Breaking gap decorations: The 'column-rule-break', 'row-rule-break', and 'rule-break' properties</h3>

	<pre class='propdef'>
		Name: column-rule-break, row-rule-break
		Value: ''none'' | ''spanning-item'' | ''intersection''
		Initial: ''spanning-item''
		Applies to: <a>grid containers</a>, <a>flex containers</a>, <a>multicol containers</a>, and <a>masonry containers</a>
		Inherited: no
		Animation type: discrete
	</pre>

	Sets the behavior for breaking decorations within a given [=gap=].
	These may cause decorations to extend over multiple [=gap decoration segment=]s, or to be broken up into multiple separate decorations (i.e., contained within one or more [=gap decoration segment=]).
	TODO: FIX: SHOULD LINK TO SAM'S SECTION Precise details for how to apply these values are given in the steps to <a>determine pairs of decoration endpoints</a>.

	<dl dfn-type="value" dfn-for="column-rule-break, row-rule-break">
		<dt><dfn>none</dfn>
		<dd>
			Within a given [=gap=], we combine the [=gap decoration segment=]s into a single [=gap decoration segment=].
			Therefore, a single continuous decoration is painted from one end of the gap to the other, with no breaks.
		</dd>
		<dt><dfn>spanning-item</dfn>
		<dd>
			Within a given [=gap=], we combine all [=gap decoration segment=]s that are <strong>not</strong> intersected by a spanning item.
			In other words, decorations break at [=gap decoration segment=]s that are intersected by an item that spans across gaps.
			Therefore, decorations are only not painted "behind" spanning items.
		</dd>
		<dt><dfn>intersection</dfn>
		<dd>
			Within a given [=gap=], gap decorations start and end at visible "T" and "cross" intersections.
			In other words, decorations are contained within each [=gap decoration segment=].
		</dd>
	</dl>

	<pre class='propdef shorthand'>
		Name: rule-break
		Value: <<'column-rule-break'>>
		Applies to: Same as 'column-rule-break' and 'row-rule-break'
	</pre>

	Sets the 'column-rule-break' and 'row-rule-break' properties to the same value.

	<wpt>
		flex/flex-gap-decorations-009.html
		flex/flex-gap-decorations-010.html
		flex/flex-gap-decorations-028.html
		flex/flex-gap-decorations-031.html
		grid/grid-gap-decorations-006.html
		grid/grid-gap-decorations-007.html
		grid/grid-gap-decorations-008.html
		grid/grid-gap-decorations-009.html
		grid/grid-gap-decorations-040.html
		grid/subgrid/subgrid-gap-decorations-004.html
		grid/subgrid/subgrid-gap-decorations-005.html
		grid/subgrid/subgrid-gap-decorations-006.html
		multicol/multicol-gap-decorations-014.html
		multicol/multicol-gap-decorations-020.html
		parsing/rule-break-computed.html
		parsing/rule-break-invalid.html
		parsing/rule-break-shorthand.html
		parsing/rule-break-valid.html
	</wpt>


<h4 id="determining-candidate-gap-segments">
Determining Candidate Gap Segments From Break Rules</h4>

	Recall that a <a>gap decoration segment</a>, |s|, can be represented as:
	|s| = [|s|.start, |s|.end]
	where |s|.start is the <a>start endpoint</a> of the segment, and |s|.end is the <a>end endpoint</a> of the segment.

	In the context of a given gap, a pair of <a>segment endpoints</a> |a| and |b| is considered <dfn>discontiguous</dfn>
	if a line segment from |a| to |b|, with the same width as the gap, intersects a child item in the container.

	Define an operation <dfn>UNION</dfn>(|s1|, |s2|) which updates |s1| such that:
	|s1| = [|s1|.start, |s2|.end]

	For two adjacent segments |s| and |t| (where |t| begins where |s| ends),
	<a>UNION</a>(|s|, |t|) is <dfn>flanked by spanning items</dfn>
	if spanning items exist on opposing sides of the segments.

	<div algorithm>
		To <dfn>determine candidate segments</dfn> |C| from segments list |S|:

		<ol>
			<li>Let |S| be the list of segments for the given gap, ordered from start to end along the gap's axis.
			<li>Let |C| be an empty list of segments.
			<li>Let |break| be the used value of either 'column-rule-break' or 'row-rule-break', whichever applies to the gap.

			<li>If |S| is empty, return |C|.

			<li>If |break| is ''column-rule-break/none'':
				<ol>
					<li>Let |s| be the first segment in |S|.
					<li>Let |last| be the last segment in |S|.
					<li><a>UNION</a>(|s|, |last|)
					<li>Append |s| to |C|
					<li>Return |C|.
				</ol>

			<li>Remove the first segment from |S|. Let |s| be that segment.

			<li>If |s|'s endpoints are <a>discontiguous</a>, go back to step 4.

			<li>If |S| is not empty:
				<ol>
					<li>Let |next| be the first segment in |S|.
					<li>Let |candidate| be a copy of |s|, then <a>UNION</a>(|candidate|, |next|)
					<li>If |candidate|'s endpoints are <a>discontiguous</a>, go to step 9.
					<li>If |break| is ''column-rule-break/intersection'' and |candidate| is not <a>flanked by spanning items</a>, go to step 9.
					<li>Remove the first segment from |S|.
					<li><a>UNION</a>(|s|, |next|)
					<li>Go back to step 8.
				</ol>

			<li>Append |s| to |C|.

			<li>Go back to step 4.
		</ol>
	</div>

The following examples illustrate various settings for the <a href="#break">*-rule-break</a> properties.
To make the differences more apparent, the <a href="#inset">*-rule-*-inset</a> properties are set to ''0'' and <a href="#visibility-rules">*-rule-visibility-items</a> is set to ''column-rule-visibility-items/all''.

	<div class="example">
		<pre>
			.break-none-grid {
				display: grid;
				grid-template: repeat(4, 100px) / repeat(4, 100px);
				gap: 20px;
				row-rule: 6px solid red;
				column-rule: 6px solid blue;
				rule-break: none;
				rule-inset: 0px;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-break-none-grid.png">
			<figcaption>
				Grid <a>gap decorations</a> with no breaks.
				Note that the <a>gap decorations</a> extend "behind" items placed in the grid.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.break-spanning-item-grid {
				display: grid;
				grid-template: repeat(4, 100px) / repeat(4, 100px);
				gap: 20px;
				row-rule: 6px solid red;
				column-rule: 6px solid blue;
				rule-break: spanning-item;
				rule-inset: 0px;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-break-spanning-item-grid.png">
			<figcaption>
				Grid <a>gap decorations</a> broken at <a>gap intersection points</a>
				that are not adjacent to spanning items.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.break-intersection-grid {
				display: grid;
				grid-template: repeat(4, 100px) / repeat(4, 100px);
				gap: 20px;
				row-rule: 6px solid red;
				column-rule: 6px solid blue;
				rule-break: intersection;
				rule-inset: 0px;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-break-intersection-grid.png">
			<figcaption>
				Grid <a>gap decorations</a> broken at every <a>gap intersection point</a>
				that is not flanked by spanning items on opposing sides.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.break-none-flex {
				display: flex;
				flex-wrap: wrap;
				gap: 20px;
				row-rule: 6px solid red;
				column-rule: 6px solid blue;
				rule-break: none;
				rule-inset: 0px;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-break-none-flex.png">
			<figcaption>
				Flexbox <a>gap decorations</a> with no breaks.
				Note that each flex line has its own distinct gaps.
				Therefore, <a>gap decorations</a> in adjacent flex lines
				are separate from each other even if the gaps happen to line up.
			</figcaption>
		</figure>
	</div>

	Note: Because flexbox has no concept of spanning items,
	''column-rule-break/spanning-item'' on a flexbox has the same effect as
	''column-rule-break/none''.

	<div class="example">
		<pre>
			.break-intersection-flex {
				display: flex;
				flex-wrap: wrap;
				gap: 20px;
				width: 500px;
				gap: 20px;
				row-rule: 6px solid red;
				column-rule: 6px solid blue;
				rule-break: intersection;
				rule-inset: 0px;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-break-intersection-flex.png">
			<figcaption>
				Flexbox <a>gap decorations</a> broken at every <a>gap intersection point</a>.
			</figcaption>
		</figure>
	</div>

<h3 id="visibility-rules">
Painting Gap Decorations with Visibility Rules</h3>

	<pre class='propdef'>
		Name: column-rule-visibility-items, row-rule-visibility-items
		Value: all | around | between
		Initial: all
		Applies to: <a>grid containers</a>
		Inherited: no
		Computed value: as specified
		Animation type: discrete
	</pre>

	These properties control whether a candidate gap decoration segment is painted
	in portions of gutters adjacent to empty cells.

	<dl dfn-type="value" dfn-for="column-rule-visibility-items, row-rule-visibility-items">
		<dt><dfn>all</dfn>
		<dd>Paint decorations in all gap segments, regardless of whether cells are occupied. This is the initial value.
		<dt><dfn>around</dfn>
		<dd>Paint decorations in a gap segment if at least one of the two cells adjacent to that segment contains an item.
		<dt><dfn>between</dfn>
		<dd>Paint decorations in a gap segment if both of the two cells adjacent to that segment contain items.
	</dl>


	<pre class='propdef shorthand'>
		Name: rule-visibility-items
		Value: <<'column-rule-visibility-items'>>
		Applies to: Same as 'column-rule-visibility-items' and 'row-rule-visibility-items'
	</pre>

	Sets the 'column-rule-visibility-items' and 'row-rule-visibility-items' properties to the same value.

	TODO: FIX: SAM ADD WPT LINKS HERE.



	<div algorithm>
		To <dfn>apply visibility rules to the candidate segments</dfn> |C| determined in [[#determining-candidate-gap-segments]]:

		<ol>
			<li>Let |S| be the list of constructed segments for this gap, ordered from start to end along the gap's axis. (From [[#segments]])

			<li>Let |C| be the list of candidate segments for this gap, ordered from start to end along the gap's axis. (From [[#determining-candidate-gap-segments]])

			<li>Let |vis| be the used value for either 'column-rule-visibility-items' or 'row-rule-visibility-items', whichever applies to the gap.

			<li>Let |P| be an empty list of segments to be painted.

			<li>If |C| is empty, return |P|.

			<li>Remove the first segment from |C|. Let |c| be that segment.

			<li>If |vis| is ''column-rule-visibility-items/all'':
				<ol>
					<li>Adjust |c|'s endpoints by applying endpoint offsets (see [[#adjusting-endpoints]])
					<li>Append |c| to |P|.
					<li>Go back to step 5.
				</ol>

			<li>Let |current| be null.

			<li>Let |seg| be the constructed segment in |S| whose start corresponds to |c|.start.

			<li>Let (|cellA|, |cellB|) be the two cells adjacent to |seg|.
				<ul>
					<li> Let |occupiedA| be true if |cellA| contains an item, false otherwise.
					<li> Let |occupiedB| be true if |cellB| contains an item, false otherwise.
				</ul>
	
			<li>Determine if |seg| is visible:
				<ul>
					<li>If |vis| is ''column-rule-visibility-items/around'': |seg| is visible if |occupiedA| or |occupiedB| is true.
					<li>If |vis| is ''column-rule-visibility-items/between'': |seg| is visible if both |occupiedA| and |occupiedB| are true.
				</ul>

			<li>If |seg| is not visible:
				<ol>
					<li>If |current| is not null:
						<ol>
							<li>Adjust |current|'s endpoints by applying endpoint offsets (see [[#adjusting-endpoints]])
							<li>Append |current| to |P|.
							<li>Set |current| to null.
						</ol>
				</ol>

			<li>Otherwise (|seg| is visible):
				<ol>
					<li>If |current| is null, set |current| to |seg|.
					<li>Otherwise, <a>UNION</a>(|current|, |seg|).
				</ol>

			<li>If |seg|.end is equal to |c|.end:
				<ol>
					<li>If |current| is not null:
						<ol>
							<li>Adjust |current|'s endpoints by applying endpoint offsets (see [[#adjusting-endpoints]])
							<li>Append |current| to |P|.
						</ol>
					<li>Go back to step 5.
				</ol>

			<li>Set |seg| to be the next constructed segment in |S| (the one that immediately follows |seg| in gap-axis order).

			<li>Go back to step 10.
		</ol>
	</div>

<h4 id="adjusting-endpoints">
Adjusting Endpoints When Appending</h4>

	Given a segment |s| = [|start|, |end|], when appending |s| to |P| in the above algorithms:
	<ol>
		<li> <a>Compute the offset</a> for |start| within |gap|. Offset |start| by the result, in the forward direction along |gap|'s axis.
		<li> <a>Compute the offset</a> for |end| within |gap|. Offset |end| by the result, in the reverse direction along |gap|'s axis.
		<li>Replace |s| with the adjusted [|start|, |end|].
	</ol>

TODO: FIX: SAM ADD EXAMPLE ILLUSTRATING THIS VISIBILITY RULES.

<h3 id="inset">
Adjusting gap segment endpoints: The 'rule-inset' properties</h3>

	<pre class='propdef'>
		Name: column-rule-edge-inset-start, column-rule-edge-inset-end, row-rule-edge-inset-start, row-rule-edge-inset-end
		Value: ''auto'' | <<length-percentage>>
		Initial: ''auto''
		Applies to: <a>grid containers</a>, <a>flex containers</a>, <a>multicol containers</a>, and <a>grid lanes containers</a>
		Inherited: no
		Percentages: refer to the <a>crossing gap width</a>
		Animation type: by computed value type
	</pre>

	<pre class='propdef'>
		Name: column-rule-interior-inset-start, column-rule-interior-inset-end, row-rule-interior-inset-start, row-rule-interior-inset-end
		Value: ''auto'' | <<length-percentage>>
		Initial: ''auto''
		Applies to: <a>grid containers</a>, <a>flex containers</a>, <a>multicol containers</a>, and <a>grid lanes containers</a>
		Inherited: no
		Percentages: refer to the <a>crossing gap width</a>
		Animation type: by computed value type
	</pre>

	These properties can be used to offset the start and end points of <a>gap decorations</a> relative to the
	<a>segment endpoint</a>s which would normally determine where decorations start and end.

	For the interior properties, 
	a value of ''-50%'' stretches the <a>gap decoration</a> up to the center of the intersection that is formed by the gaps,
	and a value of ''0'' places the <a>gap decoration</a> start and end points at the [=start segment endpoint=] and [=end segment endpoint=] of the [=gap decoration segment=].

	<dl dfn-for=rule-inset dfn-type=value>
		<dt><dfn>auto</dfn>
		<dd>
			The used value of ''auto'' is ''0'' for edge properties and ''-50%'' for interior properties.
	</dl>

	<p>An <dfn>edge segment endpoint</dfn> is any [=segment endpoint=] at the content edges of the container.</p>
	<p>An <dfn>interior segment endpoint</dfn> is any [=segment endpoint=] that is not an [=edge segment endpoint=].</p>
	<p>A given [=start segment endpoint=] and [=end segment endpoint=] can be either an [=edge segment endpoint=] or an [=interior segment endpoint=].</p>

	These properties control the behavior for any [=start segment endpoint=] that is an [=edge segment endpoint=],
	while the ''column-rule-edge-inset-end'' and ''row-rule-edge-inset-end'' properties control the behavior for any [=end segment endpoint=] that is an [=edge segment endpoint=].
	Positive values recede inwards from the content edge, while negative values extend outwards, beyond the container's content bounds.

	The ''column-rule-interior-inset-start'' and ''row-rule-interior-inset-start'' properties control the behavior for any [=start segment endpoint=] that is an [=interior segment endpoint=],
	while the ''column-rule-interior-inset-end'' and ''row-rule-interior-inset-end'' properties control the behavior for any [=end segment endpoint=] that is an [=interior segment endpoint=].
	Positive values recede away from the [=segment endpoint=], while negative values extend beyond it.

	<pre class='propdef shorthand'>
		Name: column-rule-edge-inset, row-rule-edge-inset
		Value: <<length-percentage>> [ <<length-percentage>> ]?
		Applies to: Same as 'column-rule-edge-inset-start', 'column-rule-interior-inset-start', 'row-rule-edge-inset-end', and 'row-rule-interior-inset-end'
	</pre>

	Sets the ''column-rule-edge-inset-start'' and ''column-rule-edge-inset-end'' properties to the specified values.
	Similarly, sets the ''row-rule-edge-inset-start'' and ''row-rule-edge-inset-end'' properties to the specified values.

	<pre class='propdef shorthand'>
		Name: column-rule-interior-inset, row-rule-interior-inset
		Value: <<length-percentage>> [ <<length-percentage>> ]?
		Applies to: Same as 'column-rule-edge-inset-start', 'column-rule-interior-inset-start', 'row-rule-edge-inset-end', and 'row-rule-interior-inset-end'
	</pre>

	Sets the ''column-rule-interior-inset-start'' and ''column-rule-interior-inset-end'' properties to the specified values.
	Similarly, sets the ''row-rule-interior-inset-start'' and ''row-rule-interior-inset-end'' properties to the specified values.

	<pre class='propdef shorthand'>
		Name: rule-edge-inset
		Value: <<'column-rule-edge-inset'>>
		Applies to: Same as 'column-rule-edge-inset' and 'row-rule-edge-inset'
	</pre>

	Sets the 'column-rule-edge-inset' and 'row-rule-edge-inset' properties to the same value.

	<pre class='propdef shorthand'>
		Name: rule-interior-inset
		Value: <<'column-rule-interior-inset'>>
		Applies to: Same as 'column-rule-interior-inset' and 'row-rule-interior-inset'
	</pre>

	Sets the 'column-rule-interior-inset' and 'row-rule-interior-inset' properties to the same value.

	<pre class='propdef shorthand'>
		Name: column-rule-inset, row-rule-inset
		Value: <<length-percentage>> [ <<length-percentage>> ]?
		Applies to: Same as 'column-rule-edge-inset', 'column-rule-interior-inset', 'row-rule-edge-inset', and 'row-rule-interior-inset'
	</pre>

	<pre class='propdef shorthand'>
		Name: rule-inset
		Value: <<'column-rule-inset'>>
		Applies to: Same as 'column-rule-inset' and 'row-rule-inset'
	</pre>

	Sets the 'column-rule-inset' and 'row-rule-inset' properties to the same value.

	<pre class='propdef shorthand'>
		Name: column-rule-inset-start, row-rule-inset-start
		Value: auto | <<length-percentage>>
		Applies to: 'column-rule-edge-inset-start' and 'column-rule-interior-inset-start' for 'column-rule-inset-start',
			'row-rule-edge-inset-start' and 'row-rule-interior-inset-start' for 'row-rule-inset-start'
	</pre>

	Sets the 'column-rule-edge-inset-start' and 'column-rule-interior-inset-start' properties to the same value.
	Similarly, sets the 'row-rule-edge-inset-start' and 'row-rule-interior-inset-start' properties to the same value.

	<pre class='propdef shorthand'>
		Name: column-rule-inset-end, row-rule-inset-end
		Value: auto | <<length-percentage>>
		Applies to: 'column-rule-edge-inset-end' and 'column-rule-interior-inset-end' for 'column-rule-inset-end',
			'row-rule-edge-inset-end' and 'row-rule-interior-inset-end' for 'row-rule-inset-end'
	</pre>

	Sets the 'column-rule-edge-inset-end' and 'column-rule-interior-inset-end' properties to the same value.
	Similarly, sets the 'row-rule-edge-inset-end' and 'row-rule-interior-inset-end' properties to the same value.

	<pre class='propdef shorthand'>
		Name: rule-inset-start
		Value: <<'column-rule-inset-start'>>
		Applies to: Same as 'column-rule-inset-start' and 'row-rule-inset-start'
	</pre>

	Sets the 'column-rule-inset-start' and 'row-rule-inset-start' properties to the same value.

	<pre class='propdef shorthand'>
		Name: rule-inset-end
		Value: <<'column-rule-inset-end'>>
		Applies to: Same as 'column-rule-inset-end' and 'row-rule-inset-end'
	</pre>

	Sets the 'column-rule-inset-end' and 'row-rule-inset-end' properties to the same value.


	<div class="example">
		<pre>
			.inset-0px {
				column-rule-inset: 0px;
				column-rule-break: intersection;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-column-inset-0px.png">
			<figcaption>
				An inset of ''0px'' aligns the ends of <a>gap decorations</a> with adjacent items.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.inset-negative-5px {
				column-rule-inset: -5px;
				column-rule-break: intersection;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-column-inset-5px.png">
			<figcaption>
				An inset of ''-5px'' extends the ends of <a>gap decorations</a>
				slightly beyond the edges of adjacent items.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.inset-start-8px-end-0px {
				column-rule-inset-start: 8px;
				column-rule-inset-end: 0px;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-column-start-end-edge-interior-insets.png">
			<figcaption>
				A start edge inset of ''8px'' and an end edge inset of ''0px'' recede the [=start segment endpoints=] of edge <a>gap decorations</a>
				away from the start of the gap, and align the [=end segment endpoints=] with the content edge at the end of the gap.
				A start interior inset of ''8px'' and an end interior inset of ''0px'' recede the [=start segment endpoints=] of interior <a>gap decorations</a>
				away from the edges of adjacent items at the start of the gap, and align the [=end segment endpoints=] with the edges of adjacent items at the end of the gap.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.inset-edge-0px-interior-negative-5px {
				column-rule-edge-inset: 0px;
				column-rule-interior-inset: -5px;
				column-rule-break: intersection;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-column-interior-inset-5px.png">
			<figcaption>
				An interior inset of ''-5px'' extends the endpoints of interior <a>gap decorations</a>
				slightly beyond the edges of adjacent items. An edge inset of ''0px'' aligns the endpoints of edge <a>gap decorations</a>
				with the content edges.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.inset-50percent {
				column-rule-inset: 50%;
				column-rule-break: intersection;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-column-inset-50percent.png">
		<figcaption>
			An inset of ''50%'' - the initial value - extends each end of a <a>gap decoration</a>
			halfway into its intersection.
			Neighboring <a>gap decorations</a> "meet in the middle" to create a continuous line.
			Note that at the edges of the container, the <a>crossing gap width</a> is defined to be ''0'',
			so the inset value of ''50%'' resolves to ''0''
			and thus the <a>gap decoration</a> does not extend beyond the bounds of the container.
			(Contrast with the previous example, which specified an inset in ''px'' units.)
		</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			.inset-positive-5px {
				column-rule-inset: 5px;
				column-rule-break: intersection;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-column-inset-minus-5px.png">
			<figcaption>
				An inset of ''5px'' shortens the ends of <a>gap decorations</a>
				relative to the edges of adjacent items.
			</figcaption>
		</figure>
	</div>

	When considering the <a>gap intersection points</a> within a given gap,
	each point is assigned a <dfn>crossing gap width</dfn>, defined as follows:
	<dl>
		<dt>
			At the content edge of the container
		<dd>
			The <a>crossing gap width</a> is ''0''.

		<dt>
			At an intersection with another gap
		<dd>
			The <a>crossing gap width</a> is the used value of the 'column-gap' or 'row-gap' property,
			whichever applies to the intersecting gap.
	</dl>

	<div algorithm>
		To <dfn>compute the offset</dfn> for a given <a>segment endpoint</a> |point| within a given |gap|:

		<ol>
			<li>
				Let |width| be the <a>crossing gap width</a> for |point|.
			</li>
			
			<li>
				Let |inset| be the computed value of either 'column-rule-inset' or 'row-rule-inset',
				whichever applies to |gap|.
				Resolve any percentages in |inset| against |width|.
			</li>

			<li>
				Let |result| be |width| multiplied by 50%.
				Add |inset| to |result|.
			</li>

			<li>
				Return |result|.
			</li>
		</ol>
	</div>

	For details on how the offset is applied,
	see the steps to TODO: Should reference Sam's section here.<a>determine pairs of decoration endpoints</a>.

	<wpt>
		flex/flex-gap-decorations-011.html
		flex/flex-gap-decorations-013.html
		flex/flex-gap-decorations-014.html
		grid/grid-gap-decorations-010.html
		grid/grid-gap-decorations-011.html
		grid/grid-gap-decorations-012.html
		grid/grid-gap-decorations-013.html
		grid/grid-gap-decorations-014.html
		grid/grid-gap-decorations-015.html
		multicol/multicol-gap-decorations-008.html
		multicol/multicol-gap-decorations-009.html
		multicol/multicol-gap-decorations-010.html
		multicol/multicol-gap-decorations-011.html
		multicol/multicol-gap-decorations-012.html
		parsing/rule-edge-start-end-inset-computed.html
		parsing/rule-edge-start-end-inset-invalid.html
		parsing/rule-inset-bidirectional-shorthand.html
		parsing/rule-inset-computed.html
		parsing/rule-inset-invalid.html
		parsing/rule-inset-shorthand.html
		parsing/rule-inset-valid.html
		parsing/rule-interior-start-end-inset-computed.html
		parsing/rule-interior-start-end-inset-invalid.html
	</wpt>

<h3 id="overlap">
Gap decoration overlap: The 'rule-overlap' property</h3>

	<pre class='propdef'>
		Name: rule-overlap
		Value: row-over-column | column-over-row
		Initial: row-over-column
		Applies to: <a>grid containers</a>, <a>flex containers</a>, and <a>masonry containers</a>
		Inherited: no
		Animation type: discrete
	</pre>

	Sets the overlap for <a>gap decorations</a> in two-dimensional containers.

	The following examples illustrate adjustment of gap decoration overlap using the 'rule-overlap' property.

	<div class="example">
		<pre>
			.row-over-coulumn {
				rule-overlap: row-over-column;
				row-rule: 6px solid red;
				column-rule: 6px solid blue;
			}
		</pre>
		<figure>
			<img alt="" src="images/example-row-over-column.png">
			<figcaption>
				Row-over-column gap decoration overlap.
			</figcaption>
		</figure>
	</div>

	<div class="example">
		<pre>
			rule-overlap: column-over-row;
			row-rule: 6px solid red;
			column-rule: 6px solid blue;
		</pre>
		<figure>
			<img alt="" src="images/example-column-over-row.png">
			<figcaption>
				Column-over-row gap decoration overlap.
			</figcaption>
		</figure>
	</div>

	<wpt>
		flex/flex-gap-decorations-012.html
		grid/grid-gap-decorations-023.html
		parsing/rule-overlap-computed.html
		parsing/rule-overlap-invalid.html
		parsing/rule-overlap-valid.html
	</wpt>

<h2 id="color-style-width">
Color, style, and width</h2>

Property definitions in this section supersede the definitions of properties with the same names in
[[CSS-MULTICOL-1]].

<h3 id="column-row-rule-color">
Gap decoration color: The 'column-rule-color' and 'row-rule-color' properties</h3>

	<pre class='propdef'>
		Name: column-rule-color, row-rule-color
		Value: <<line-color-list>> | <<auto-line-color-list>>
		Initial: currentcolor
		Applies to: <a>grid containers</a>, <a>flex containers</a>, <a>multicol containers</a>, and <a>grid lanes containers</a>
		Inherited: no
		Animation type: repeatable list, see [[#interpolation-behavior]].
	</pre>

	<pre class='prod'>
		<dfn>&lt;line-color-list&gt;</dfn>          = [ <<line-color-or-repeat>> ]+

		<dfn>&lt;auto-line-color-list&gt;</dfn>     = [ <<line-color-or-repeat>> ]*
									               <<auto-repeat-line-color>>
									               [ <<line-color-or-repeat>> ]*

		<dfn>&lt;line-color-or-repeat&gt;</dfn>     = [ <<color>> | <<repeat-line-color>> ]

		<dfn>&lt;repeat-line-color&gt;</dfn>        = repeat( [ <<integer [1,∞]>> ] , [ <<color>> ]+ )

		<dfn>&lt;auto-repeat-line-color&gt;</dfn>   = repeat( auto , [ <<color>> ]+ )
	</pre>

	<dl>
		<dt><dfn value for=column-rule-color><<color>></dfn></dt>
		<dd>
			Sets the color of <a>gap decorations</a>.
		</dd>
	</dl>

	<wpt>
		grid/grid-gap-decorations-022.html
		grid/grid-gap-decorations-024.html
		grid/grid-gap-decorations-025.html
		grid/grid-gap-decorations-026.html
		grid/grid-gap-decorations-027.html
		grid/grid-gap-decorations-028.html
		parsing/gap-decorations-color-computed.html
		parsing/gap-decorations-color-invalid.html
		parsing/gap-decorations-color-valid.html
	</wpt>

<h3 id="column-row-rule-style">
Gap decoration style: The 'column-rule-style' and 'row-rule-style' properties</h3>

	<pre class='propdef'>
		Name: column-rule-style, row-rule-style
		Value: <<line-style-list>> | <<auto-line-style-list>>
		Initial: none
		Applies to: <a>grid containers</a>, <a>flex containers</a>, <a>multicol containers</a>, and <a>grid lanes containers</a>
		Inherited: no
		Animation type: discrete
	</pre>

	<pre class='prod'>
		<dfn>&lt;line-style-list&gt;</dfn>          = [ <<line-style-or-repeat>> ]+

		<dfn>&lt;auto-line-style-list&gt;</dfn>     = [ <<line-style-or-repeat>> ]*
									               <<auto-repeat-line-style>>
									               [ <<line-style-or-repeat>> ]*

		<dfn>&lt;line-style-or-repeat&gt;</dfn>     = [ <<line-style>> | <<repeat-line-style>> ]

		<dfn>&lt;repeat-line-style&gt;</dfn>        = repeat( [ <<integer [1,∞]>> ] , [ <<line-style>> ]+ )

		<dfn>&lt;auto-repeat-line-style&gt;</dfn>   = repeat( auto , [ <<line-style>> ]+ )
	</pre>

	These properties set the styles of <a>gap decorations</a>.
	The <<line-style>> values are interpreted as in the <a href="https://www.w3.org/TR/CSS2/tables.html#collapsing-borders">collapsing border model</a>.

	<wpt>
		flex/flex-gap-decorations-002.html
		flex/flex-gap-decorations-003.html
		flex/flex-gap-decorations-004.html
		flex/flex-gap-decorations-005.html
		flex/flex-gap-decorations-017.html
		flex/flex-gap-decorations-018.html
		grid/grid-gap-decorations-002.html
		grid/grid-gap-decorations-003.html
		grid/grid-gap-decorations-004.html
		grid/grid-gap-decorations-005.html
		grid/grid-gap-decorations-016.html
		grid/grid-gap-decorations-017.html
		grid/grid-gap-decorations-020.html
		grid/grid-gap-decorations-021.html
		parsing/gap-decorations-style-computed.html
		parsing/gap-decorations-style-invalid.html
		parsing/gap-decorations-style-valid.html
	</wpt>

<h3 id="column-row-rule-width">
Gap decoration width: The 'column-rule-width' and 'row-rule-width' properties</h3>

	<pre class='propdef'>
		Name: column-rule-width, row-rule-width
		Value: <<line-width-list>> | <<auto-line-width-list>>
		Initial: medium
		Applies to: <a>grid containers</a>, <a>flex containers</a>, <a>multicol containers</a>, and <a>grid lanes containers</a>
		Inherited: no
		Computed value: list of absolute lengths, <a>snapped as a border width</a>
		Animation type: repeatable list, see [[#interpolation-behavior]].
	</pre>

	<pre class='prod'>
		<dfn>&lt;line-width-list&gt;</dfn>          = [ <<line-width-or-repeat>> ]+

		<dfn>&lt;auto-line-width-list&gt;</dfn>     = [ <<line-width-or-repeat>> ]*
									               <<auto-repeat-line-width>>
									               [ <<line-width-or-repeat>> ]*

		<dfn>&lt;line-width-or-repeat&gt;</dfn>     = [ <<line-width>> | <<repeat-line-width>> ]

		<dfn>&lt;repeat-line-width&gt;</dfn>        = repeat( [ <<integer [1,∞]>> ] , [ <<line-width>> ]+ )

		<dfn>&lt;auto-repeat-line-width&gt;</dfn>   = repeat( auto , [ <<line-width>> ]+ )
	</pre>

	This property sets the widths of <a>gap decorations</a>. Negative values are not allowed.

	<wpt>
		grid/grid-gap-decorations-018.html
		grid/grid-gap-decorations-019.html
		multicol/multicol-gap-decorations-004.html
		parsing/gap-decorations-col-rule-width.html
		parsing/gap-decorations-width-computed.html
		parsing/gap-decorations-width-invalid.html
		parsing/gap-decorations-width-valid.html
	</wpt>

<h3 id="lists-repeat">
Lists of values and the ''repeat-line-color/repeat()'' notation</h3>

	Each of the properties in this section accepts a space-separated list of values.
	Setting multiple values in this way allows for varying <a>gap decorations</a> within a given container.

	<div class="example">
		An author might specify alternating red and blue column rules as follows:
		<pre>
			column-rule-width: 1px;
			column-rule-style: solid;
			column-rule-color: red blue;
		</pre>
	</div>

	Such a list may contain <dfn for="<repeat-line-color>,<auto-repeat-line-color>,<repeat-line-style>,<auto-repeat-line-style>,<repeat-line-width>,<auto-repeat-line-width>">repeat()</dfn> notations.
	Similar to [[css-grid-1#repeat-notation]], these notations allow a series of <a>gap decorations</a>
	that exhibit a recurring pattern to be written in a more compact form.

	The generic form of the ''repeat-line-color/repeat()'' syntax is, approximately,
	<pre class='prod'>
		repeat( [ <<integer [1,∞]>> | auto ] , &lt;value&gt;+ )
	</pre>

	The first argument to ''repeat-line-color/repeat()'' specifies the number of repetitions.
	<dl>
		<dt><<integer>>
		<dd>
			Specifies an <dfn>integer repeater</dfn>.
			An <a>integer repeater</a> expands out to the list of values in the second argument,
			repeated as many times as specified by the first argument.

			<div class="example">
				An author may write:
				<pre>
					column-rule-color: gray red blue red blue red blue gray;
				</pre>
				Or shorten to the following, which produces the same sequence of colors:
				<pre>
					column-rule-color: gray repeat(3, red blue) gray;
				</pre>
			</div>

		<dt>auto
		<dd>
			Specfies an <dfn>auto repeater</dfn>.
			An <a>auto repeater</a> will be used to fill in values for gaps
			that would not otherwise receive values from other parts of the list.
			At most one ''repeat-line-color/repeat()'' in a given list of values may be an <a>auto repeater</a>.

			<div class="example">
				Continuing from the previous example, if the author does not know how
				many columns will be in the final layout, they might instead write:
				<pre>
					column-rule-color: gray repeat(auto, red blue) gray;
				</pre>
				Which will produce a gray decoration in the first and last column gaps,
				and alternating red and blue decorations in the in-between column gaps.
			</div>
	</dl>

	The second argument to ''repeat-line-color/repeat()'' is a space-separated list of values
	that would be accepted by the property in which the ''repeat-line-color/repeat()'' appears.

	<div algorithm>
		To <dfn>assign gap decoration values</dfn> to a list of |gaps| using a list of |values|:

		<ol>
			<li>
				Replace any <a>integer repeaters</a> in |values| with their expanded-out equivalents.
			</li>

			<li>
				If the list contains no <a>auto repeater</a>, then:
			</li>

				<ol>
					<li>
						Beginning from the first item in |values| and the first item in |gaps|,
						assign each value to the corresponding gap.
						If there are fewer values than gaps,
						repeat beginning from the first item in |values|,
						as many times as needed.
					</li>
					
					<li>
						End this algorithm.
					</li>
				</ol>

			<li>
				|values| contains an <a>auto repeater</a>.
				Let |leading count| be the number of items in |values| before the <a>auto repeater</a>.
				Let |trailing count| be the number of items in |values| after the <a>auto repeater</a>.
			</li>

			<li>
				Partition |gaps| as follows:

				<ol>
					<li>
						Let |leading gaps| contain the first |leading count| items in |gaps|.
					</li>
					<li>
						Let |trailing gaps| contain the last |trailing count| items in |gaps|,
						excluding any items in |leading gaps|.
					</li>
					<li>
						Let |auto gaps| contain any items in |gaps|
						that are not in either |leading gaps| or |trailing gaps|.
					</li>
				</ol>
			
			<li>
				If |leading gaps| is non-empty,
				<a>assign gap decoration values</a> to |leading gaps|
				using the first |leading count| items in |values|.
			</li>
			
			<li>
				If |trailing gaps| is non-empty,
				<a>assign gap decoration values</a> to |trailing gaps|
				using the first |trailing count| items in |values|.
			</li>
			
			<li>
				If |auto gaps| is non-empty,
				<a>assign gap decoration values</a> to |auto gaps|
				using the list of values in the second argument of the <a>auto repeater</a>.
			</li>
		</ol>
	</div>

<h4 id="interpolation-behavior">Interpolation behavior</h4>
When interpolating ''repeat()'' values, or lists of values for 'rule-color' or 'rule-width', the interpolation proceeds in two steps:

	<ol>
	<li><em>Expansion:</em> Expand any [=integer repeater=] into its equivalent list of values. </li>
	<li><em>List Interpolation:</em> Apply the [=repeatable list=] interpolation algorithm to the expanded lists, interpolating each item against its counterpart.</li>
	</ol>
	<div class="example">
		<pre class="lang-css">
		@keyframes example {
			from { column-rule-width: 10px; }
			to   { column-rule-width: 20px 40px; }
		}
		</pre>
		Interpolation of the above values would result in expansion of the
		"from" and "to" values to create lists of equal lengths:
		<pre>
		From:   10px 10px
		At 50%: 15px 25px
		To:     20px 40px
		</pre>
	</div>
	<div class="example">
		<pre class="lang-css">
		@keyframes example {
			from { column-rule-width: repeat(2, 5px 10px); }
			to   { column-rule-width: repeat(2, 15px 20px); }
		}
		</pre>
		Interpolation of the above values would result in expansion of the
		"from" and "to" values to create lists of equal lengths:
		<pre>
		From:    5px 10px  5px 10px
		At 50%: 10px 15px 10px 15px
		To:     15px 20px 15px 20px
		</pre>
	</div>

	<div class="example">
		<pre class="lang-css">
		@keyframes example {
			from { column-rule-width: repeat(2, 10px 20px); }
			to   { column-rule-width: 20px; }
		}
		</pre>
		Interpolation of the above values would result in expansion of the
		"from" and "to" values to create lists of equal lengths:
		<pre>
		From:   10px 20px 10px 20px
		At 50%: 15px 20px 15px 20px
		To:     20px 20px 20px 20px
		</pre>
	</div>
	<div class="example">
		<pre class="lang-css">
		@keyframes example {
			from { column-rule-width: repeat(2, 10px 20px); }
			to   { column-rule-width: 20px 30px; }
		}
		</pre>
		Interpolation of the above values would result in expansion of the
		"from" and "to" values to create lists of equal lengths:
		<pre>
		From:   10px 20px 10px 20px
		At 50%: 15px 25px 15px 25px
		To:     20px 30px 20px 30px
		</pre>
	</div>


<h5 id="auto-repeaters">Lists with Auto Repeaters</h5>
	<div algorithm="interpolate with auto repeaters">

		When either of the lists we are interpolating between (|from| and |to|) include an <a>auto repeater</a>:

			<ol>
				<li>
					Split each of |from| and |to| into segments, similar to how we [=assign gap decoration values=]:
					<ol>
						<li>Let |leading values| be the values before the <a>auto repeater</a>.</li>
						<li>Let |trailing values| be the values after the <a>auto repeater</a>.</li>
						<li>Let |auto values| be the values inside the <a>auto repeater</a>.</li>
					</ol>
				</li>
				<li>If only one of |from| or |to| contains an auto-repeater, we fall back to [=discrete=] interpolation.</li>
				<li>Expand any integer repeaters on each segment.</li>
				<li>
					If the length of |leading values| in |from| and |leading values| in |to| don't match, we fall back to [=discrete=] interpolation.
					If the length of |trailing values| in |from| and |trailing values| in |to| don't match, we fall back to [=discrete=] interpolation.
				</li>
				<li>
					When both |from| and |to| contain auto-repeaters, and the length of their segments match as described above,
					apply [=repeatable list=] interpolation to the lists of values in each |auto values|.
				</li>
			</ol>

		<div class="example">
			<pre class="lang-css">
			@keyframes example {
				from { column-rule-width: 10px repeat(auto, 20px) 30px }
				to   { column-rule-width: 20px repeat(auto, 40px) 40px }
			}
			</pre>
			Length of the |leading values| and |trailing values| across |from| and |to| match, so we can apply the [=repeatable list=] algorithm to each segment.
			<pre>
			From:   10px repeat(auto, 20px) 30px
			At 50%: 15px repeat(auto, 30px) 35px
			To:     20px repeat(auto, 40px) 40px
			</pre>
		</div>

		<div class="example">
			<pre class="lang-css">
			@keyframes example {
				from { column-rule-width: 10px 20px repeat(auto, 20px) 30px }
				to   { column-rule-width: 20px 30px repeat(auto, 40px 50px) 40px }
			}
			</pre>
			Length of the |leading values| and |trailing values| across |from| and |to| match, so we can apply the [=repeatable list=] algorithm to each segment.
			<pre>
			From:   10px 20px repeat(auto, 20px 20px) 30px
			At 50%: 15px 25px repeat(auto, 30px 35px) 35px
			To:     20px 30px repeat(auto, 40px 50px) 40px
			</pre>
		</div>

		<div class="example">
			<pre class="lang-css">
			@keyframes example {
				from { column-rule-width: 10px repeat(auto, 20px) }
				to   { column-rule-width: 20px 30px repeat(auto, 40px 50px) }
			}
			</pre>
			Length of the |from| |leading values| and |to| |leading values| don't match, so we fall back to [=discrete=] interpolation.
		</div>

		<div class="example">
			<pre class="lang-css">
			@keyframes example {
				from { column-rule-width: 10px repeat(auto, 20px) 30px }
				to   { column-rule-width: 20px repeat(auto, 40px) 40px 50px }
			}
			</pre>
			Length of the |from| |trailing values| and |to| |trailing values| don't match, so we fall back to [=discrete=] interpolation.
		</div>

		<div class="example">
			<pre class="lang-css">
			@keyframes example {
				from { column-rule-width: 10px repeat(auto, 20px) 30px }
				to   { column-rule-width: 20px }
			}
			</pre>
			Only |from| contains an <a>auto repeater</a>, so we fall back to [=discrete=] interpolation.
		</div>
	</div>

	<wpt>
		animation/column-rule-outset-interpolation.html
		animation/gap-decorations-color-neutral-keyframe-001.html
		animation/gap-decorations-color-neutral-keyframe-002.html
		animation/gap-decorations-color-neutral-keyframe-003.html
		animation/gap-decorations-color-neutral-keyframe-004.html
		animation/gap-decorations-color-neutral-keyframe-005.html
		animation/gap-decorations-outset-neutral-keyframe-001.html
		animation/gap-decorations-outset-neutral-keyframe-002.html
		animation/gap-decorations-width-neutral-keyframe-001.html
		animation/gap-decorations-width-neutral-keyframe-002.html
		animation/gap-decorations-width-neutral-keyframe-003.html
		animation/gap-decorations-width-neutral-keyframe-004.html
		animation/gap-decorations-width-neutral-keyframe-005.html
		animation/row-rule-color-interpolation.html
		animation/row-rule-outset-interpolation.html
		animation/row-rule-width-interpolation.html
		animation/rule-color-interpolation-conversion-001.html
		animation/rule-color-interpolation-conversion-002.html
		animation/rule-color-interpolation-conversion-crash.html
		animation/rule-color-interpolation-multiple-values-001.html
		animation/rule-color-interpolation-repeaters-001.html
		animation/rule-width-interpolation-conversion-001.html
		animation/rule-width-interpolation-conversion-002.html
		animation/rule-width-interpolation-multiple-values-001.html
		animation/rule-width-interpolation-multiple-values-002.html
		animation/rule-width-interpolation-repeaters.html
	</wpt>

<h3 id="gap-decoration-shorthands">
Gap decoration shorthands: The 'column-rule' and 'row-rule' properties</h3>

	<pre class='propdef shorthand'>
		Name: column-rule, row-rule
		Value: <<gap-rule-list>> | <<gap-auto-rule-list>>
	</pre>

	<pre class='prod'>
		<dfn>&lt;gap-rule-list&gt;</dfn>        = <<gap-rule-or-repeat>>#

		<dfn>&lt;gap-auto-rule-list&gt;</dfn>   = <<gap-rule-or-repeat>>#? ,
								             <<gap-auto-repeat-rule>> ,
								             <<gap-rule-or-repeat>>#?

		<dfn>&lt;gap-rule-or-repeat&gt;</dfn>   = <<gap-rule>> | <<gap-repeat-rule>>

		<dfn>&lt;gap-repeat-rule&gt;</dfn>      = repeat( <<integer [1,∞]>> , <<gap-rule>># )

		<dfn>&lt;gap-auto-repeat-rule&gt;</dfn> = repeat( auto , <<gap-rule>># )

		<dfn>&lt;gap-rule&gt;</dfn>             = <<line-width>> || <<line-style>> || <<color>>
	</pre>

	These shorthands set the corresponding width, style, and color properties as a set.

<h3 id="rule-bi-directional">
Bi-directional gap decoration shorthands: The 'rule-color', 'rule-style', 'rule-width', and 'rule' properties</h3>

	<pre class='propdef shorthand'>
		Name: rule-color
		Value: <<'column-rule-color'>>
		Inherited: no
		Applies to: Same as 'column-rule-color' and 'row-rule-color'
	</pre>

	<pre class='propdef shorthand'>
		Name: rule-style
		Value: <<'column-rule-style'>>
		Inherited: no
		Applies to: Same as 'column-rule-style' and 'row-rule-style'
	</pre>

	<pre class='propdef shorthand'>
		Name: rule-width
		Value: <<'column-rule-width'>>
		Inherited: no
		Applies to: Same as 'column-rule-width' and 'row-rule-width'
	</pre>

	<pre class='propdef shorthand'>
		Name: rule
		Value: <<'column-rule'>>
		Inherited: no
		Applies to: Same as 'column-rule' and 'row-rule'
	</pre>

	These shorthands set the corresponding column and row properties to the same values.

	<wpt>
		flex/flex-gap-decorations-019.html
		parsing/gap-decorations-bidirectional-shorthands.html
		parsing/gap-decorations-rule-initial-value-crash.html
		parsing/gap-decorations-rule-shorthand-computed.html
		parsing/gap-decorations-rule-shorthand-invalid.html
		parsing/gap-decorations-rule-shorthand-valid.html
		parsing/gap-decorations-rule-shorthand.html
	</wpt>

<h2 id="privacy">
Privacy Considerations</h2>

No new privacy considerations have been reported on this specification.

<h2 id="security">
Security Considerations</h2>

No new security considerations have been reported on this specification.

<h2 id="acknowledgements">
Acknowledgements</h2>

<p>This specification is made possible by contributions and feedback from many people, including:
	Ahmad Shadeed,
	Alison Maher,
	Benoît Rouleau,
	Elika Etemad,
	Ian Kilpatrick,
	Javier Contreras Tenorio,
	Josh Tumath,
	Kurt Catti-Schmidt,
	Lea Verou,
	Oliver Williams,
	Rachel Andrew,
	Sam Davis Omekara Jr.,
	Sebastian Zartner,
	Tab Atkins-Bittner,
	and the CSS Working Group members.
	Special thanks to Mats Palmgren who drafted an initial proposal for Gap Decorations.
</p>

<h2 id="changes">
Changes</h2>

<h3 id="changes-20250417">
Changes since the <a href="https://www.w3.org/TR/2025/WD-css-gaps-1-20250417/">17 April 2025 Working Draft</a></h3>

	<ul class="non-normative">
		<li>Specified the behavior when gaps are coincident due to track collapsing.
			(<a href="https://github.com/w3c/csswg-drafts/issues/11814">Issue 11814</a>)
		<li>Added links to WPT suite.
		<li>Updated 'rule-paint-order' to 'rule-overlap'. (<a href="https://github.com/w3c/csswg-drafts/issues/12540">Issue 12540</a>)
		<li>Updated the definition for intersections to use [=gutter=]. (<a href="https://github.com/w3c/csswg-drafts/issues/12084">Issue 12084</a>)
		<li>Updated trailing gap decoration assignment to use values in forward order. (<a href="https://github.com/w3c/csswg-drafts/issues/12527">Issue 12527</a>)
		<li>Specified the interpolation behavior for values which may contain repeaters.
			(<a href="https://github.com/w3c/csswg-drafts/issues/12431">Issue 12431</a>)
		<li>Removed the special case of 'column-rule-width' having a computed value of ''0'' when 'column-rule-style' is ''<line-style>/none'' or ''<line-style>/hidden''.
			(<a href="https://github.com/w3c/csswg-drafts/issues/11494">Issue 11494</a>)
		<li> Updated `*-outset` to `*-inset` and introduced related properties.
			(<a href="https://github.com/w3c/csswg-drafts/issues/12603">Issue 12603</a>,
			<a href="https://github.com/w3c/csswg-drafts/issues/12848">Issue 12848</a>,
			<a href="https://github.com/w3c/csswg-drafts/issues/8402">Issue 8402</a>)
	</ul>