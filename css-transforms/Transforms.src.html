<!DOCTYPE html public '-//W3C//DTD HTML 4.01//EN' 'http://www.w3.org/TR/html4/strict.dtd'>
<html lang="en">
<head profile="http://www.w3.org/2006/03/hcard">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
  <title>CSS Transforms</title>
  <script src='http://test.csswg.org/harness/annotate.js#CSS3-TRANSFORMS_DEV' type='text/javascript' defer></script>
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-ED.css" >
  <link rel="stylesheet" type="text/css" href="default.css" >

</head>
<body>
    <div id="div-head" class="head">
        <!--logo-->

        <h1>CSS Transforms Level 1</h1>

        <h2 class="no-num no-toc">[LONGSTATUS] [DATE]</h2>
        <dl>
          <dt>This version:
            <dd>
            <a href="[VERSION]">http://dev.w3.org/csswg/css3-transforms/</a>
            <!--http://www.w3.org/TR/[YEAR]/WD-[SHORTNAME]-[CDATE]/-->
          <dt>Latest version:
            <dd><a
              href="http://www.w3.org/TR/css3-transforms/">[LATEST]</a>
          <dt>Editor's draft:
            <dd><a href="http://dev.w3.org/csswg/[SHORTNAME]/">http://dev.w3.org/csswg/[SHORTNAME]/</a>
          <dt>Previous version:
            <dd><a href='http://www.w3.org/TR/2012/WD-css3-transforms-20120911/'>http://www.w3.org/TR/2012/WD-css3-transforms-20120911/</a>
          <dt id="editors-list">Editors:
            <dd>Simon Fraser (<a href="http://www.apple.com/">Apple Inc</a>) &lt;simon.fraser &#64;apple.com&gt;
            <dd>Dean Jackson (<a href="http://www.apple.com/">Apple Inc</a>) &lt;dino &#64;apple.com&gt;
            <dd>Edward O'Connor (<a href="http://www.apple.com/">Apple Inc</a>) &lt;eoconnor &#64;apple.com&gt;
            <dd>Dirk Schulze (<a href="http://www.adobe.com/">Adobe Systems, Inc</a>) &lt;dschulze &#64;adobe.com&gt;
            <dd>Aryeh Gregor (<a href="http://www.mozilla.org/">Mozilla</a>) &lt;ayg &#64;aryeh.name&gt;

          <dt id="former-editors-list">Former Editors:
            <dd>David Hyatt (<a href="http://www.apple.com/">Apple Inc</a>) &lt;hyatt &#64;apple.com&gt;
            <dd>Chris Marrin (<a href="http://www.apple.com/">Apple Inc</a>) &lt;cmarrin &#64;apple.com&gt;

            <dt>Issues list:
              <dd><a href="https://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&amp;product=CSS&amp;component=Transforms&amp;resolution=---&amp;cmdtype=doit">in Bugzilla</a>

            <dt>Feedback:
              <dd><a href="mailto:www-style@w3.org?subject=%5B[css-transforms]%5D%20feedback">www-style@w3.org</a>
                  with subject line &ldquo;<kbd>[css-transforms]
                  <var>&hellip; message topic &hellip;</var></kbd>&rdquo;
                  (<a rel="discussion" href="http://lists.w3.org/Archives/Public/www-style/">archives</a>)

            <dt>Test suite:
              <dd>  <a
                     href="http://test.csswg.org/suites/css3-transforms/nightly-unstable/">http://test.csswg.org/suites/css3-transforms/nightly-unstable/</a>
          </dl>

        <!--copyright-->

        <hr title="Separator for header">
        </div>

        <h2 class="no-num no-toc" id="abstract">Abstract</h2>

        <p>CSS transforms allows elements styled with CSS to be transformed
          in two-dimensional or three-dimensional space. This specification is the convergence of the
            <a href="http://www.w3.org/TR/css3-2d-transforms/">CSS 2D transforms</a>,
          <a href="http://www.w3.org/TR/css3-3d-transforms/">CSS 3D transforms</a>
          and <a href="http://www.w3.org/TR/2009/WD-SVG-Transforms-20090320/">SVG transforms</a>
          specifications.</p>

        <h2 class="no-num no-toc" id="status">Status of this document</h2>

        <!--status-->

        <p>
          This specification replaces the former <a href="http://www.w3.org/TR/css3-2d-transforms/" title="CSS 2D Transforms">CSS 2D Transforms</a> and <a href="http://www.w3.org/TR/css3-3d-transforms/" title="CSS 3D Transforms Module Level 3">CSS 3D Transforms</a> specifications, as well
          as <a href="http://www.w3.org/TR/SVG-Transforms/" title="SVG Transforms 1.0">SVG Transforms</a>.
        </p>

        <p>
          The <a href="ChangeLog">list of changes made to this specification</a> is
          available.
        </p>

        <h2 class="no-num no-toc" id="contents">Table of contents</h2>
        <!--toc-->

        <h2>Introduction</h2>

          <p><em>This section is not normative.</em></p>
          <p>
            The CSS <a href="http://www.w3.org/TR/REC-CSS2/visuren.html">visual
            formatting model</a> describes a coordinate system within each
            element is positioned. Positions and sizes in this coordinate space can
            be thought of as being expressed in pixels, starting in the origin of point
            with positive values proceeding to the right and down.
          </p>
          <p>
            This coordinate space can be modified with the 'transform' property. Using transform,
            elements can be translated, rotated and scaled in two or three dimensional space.
          </p>
          <p>
            Additional properties make working with transforms easier, and allow the
            author to control how nested three-dimensional transforms interact.
          </p>
          <ul>
            <li>
              The 'transform-origin' property provides a convenient way to control the origin about
              which transforms on an element are applied.
            </li>
            <li>
              The 'perspective' property allows the author to make child elements with
              three-dimensional transforms appear as if they live in a common three-dimensional
              space.
              The 'perspective-origin' property provides control over the origin at which
              perspective is applied, effectively changing the location of the "vanishing point".
            </li>
            <li>
              The 'transform-style' property allows 3D-transformed elements and their 3D-transformed
              descendants to share a common three-dimensional space, allowing the construction of
              hierarchies of three-dimensional objects.
            </li>
            <li>
               The 'backface-visibility' property comes into play when an element is flipped around
               via three-dimensional transforms such that its reverse side is visible to the viewer.
               In some situations it is desirable to hide the element in this situation, which is
               possible using the value of ''hidden'' for this property.
            </li>
          </ul>
          <p>
            Note that while some values of the 'transform' property allow an element to be
            transformed in a three-dimensional coordinate system, the elements themselves are not
            three-dimensional objects. Instead, they exist on a two-dimensional plane (a flat
            surface) and have no depth.
          </p>

        <!-- ======================================================================================================= -->

        <h2 id="module-interactions">Module Interactions</h2>
          <p>This module defines a set of CSS properties that affect the visual rendering of elements to which
            those properties are applied; these effects are applied after elements have been sized and positioned according
            to the <a href="http://www.w3.org/TR/CSS2/visuren.html" title="Visual formatting model">Visual formatting model</a>
            from [[!CSS21]]. Some values of these properties result in the creation of a <a href="http://www.w3.org/TR/CSS2/visuren.html#containing-block" title="Visual formatting model">containing block</a>, and/or the creation of a <a href="http://www.w3.org/TR/CSS2/visuren.html#z-index" title="Visual formatting model">stacking context</a>.
          </p>
          <p>
            Three-dimensional transforms can also affect the visual layering of elements, and thus override the back-to-front
            painting order described in <a href="http://www.w3.org/TR/CSS2/zindex.html" title="Elaborate description of Stacking Contexts">Appendix E</a> of [[!CSS21]].
          </p>
          <p>
            Transforms affect the results of the Element Interface extensions <a href="http://www.w3.org/TR/cssom-view/#dom-element-getclientrects">getClientRects()</a> and <a href="http://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect">getBoundingClientRect()</a>, which are specified in [[CSSOM-VIEW]].
          </p>
          <p>
            Transforms affect the rendering of backgounds on elements with a value of ''fixed'' for the
            '<code class="property"><a href="http://www.w3.org/TR/css3-background/#the-background-attachment">background-attachment</a></code>' property,
            which is specified in [[!CSS3BG]].
          </p>

        <h2 id="css-values">CSS Values</h2>

          <p>This specification follows the <a href="http://www.w3.org/TR/CSS21/about.html#property-defs">CSS property definition conventions</a> from [[!CSS21]]. Value types not defined in this specification are defined in CSS Level 2 Revision 1 [[!CSS21]].</p>

          <p>In addition to the property-specific values listed in their definitions, all properties defined in this specification also accept the <a href="http://www.w3.org/TR/CSS21/cascade.html#value-def-inherit">inherit</a> keyword as their property value. For readability it has not been repeated explicitly.


        <h2 id="definitions">Terminology</h2>
          <p> When used in this specification, terms have the meanings assigned in
            this section.
          </p>
          <dl>
            <dt id="TermBoundingBox"><dfn>bounding box</dfn></dt>
            <dd>
              <p>
                A bounding box is the object bounding box for all SVG elements
                without an associated CSS layout box and the border box for all
                other elements.  The bounding box of a table is the border box
                of its
                <a href="http://www.w3.org/TR/CSS21/tables.html#model">table wrapper box</a>,
                not its table box.
              </p>
            </dd>

            <dt id="TermTransformableElement"><dfn>transformable element</dfn></dt>
            <dd>
              <p>
                A transformable element is an element in one of these
                categories:
              </p>
              <ul>
                <li>
                  an element whose
                  layout is governed by the CSS box model which is either
                  a
                  <a href="http://www.w3.org/TR/CSS2/visuren.html#block-level">block-level</a>
                  or
                  <a href="http://www.w3.org/TR/CSS2/visuren.html#x13">atomic inline-level element</a>,
                  or whose 'display' property
                  computes to ''table-row'',
                  ''table-row-group'',
                  ''table-header-group'',
                  ''table-footer-group'',
                  ''table-cell'', or
                  ''table-caption'' [[!CSS21]]
                </li>
                <li>
                  an element in the SVG namespace and not governed by the CSS box model which has
                  the attributes 'transform', 'patternTransform' or 'gradientTransform' [[!SVG11]]
                </li>
              </ul>
            </dd>
            <dt id="TermUserCoordinateSystem"><dfn>user coordinate system</dfn></dt>
            <dt id="TermLocalCoordinateSystem"><dfn>local coordinate system</dfn></dt>
            <dd>
              <p>
                In general, a coordinate system defines locations and distances on the current
                canvas. The current local coordinate system (also user coordinate system) is the
                coordinate system that is currently active and which is used to define how
                coordinates and lengths are located and computed, respectively, on the current
                canvas.
              </p>
            </dd>
            <dt id="TermPerspectiveMatrix"><dfn>perspective matrix</dfn></dt>
            <dd>
              <p>
                A matrix computed from the values of the 'perspective' and 'perspective-origin' properties as described <a href="#perspective-matrix-computation">below</a>.
              </p>
            </dd>

            <dt id="TermTransformationMatrix"><dfn>transformation matrix</dfn></dt>
            <dd>
              <p>
                A matrix that defines the mathematical mapping from one coordinate system into another. It is computed from the values of the 'transform' and 'transform-origin' properties as described <a href="#transformation-matrix-computation">below</a>.
              </p>
            </dd>
            
            <dt id="TermCurrentTransformationMatrix"><dfn>current transformation matrix (CTM)</dfn></dt>
            <dd>
              <p>
                A matrix that defines the mapping from the local coordinate system into the viewport coordinate system.
              </p>
            </dd>

            <dt id="TermAccumulated3DTransformationMatrix">
              <dfn>accumulated 3D transformation matrix</dfn>
            </dt>
            <dd>
              <p>
                A matrix computed for elements in a
                <a href="#d-rendering-context">3D rendering context</a>, as
                described
                <a href="#accumulated-3d-transformation-matrix-computation">below</a>.
              </p>
            </dd>
            
            <dt id="TermIdentityTransformFunction">
              <dfn>identity transform function</dfn>
            </dt>
            <dd>
              <p>
                A <a href="#transform-functions">transform function</a> that is equivalent to a
                identity 4x4 matrix (see <a href="#mathematical-description">Mathematical
                Description of Transform Functions</a>). Examples for identity transform functions
                are ''translate(0)'', ''translate3d(0, 0, 0)'', ''translateX(0)'',
                ''translateY(0)'', ''translateZ(0)'', ''scale(1)'', ''scaleX(1)'', ''scaleY(1)'',
                ''scaleZ(1)'', ''rotate(0)'', ''rotate3d(1, 1, 1, 0)'', ''rotateX(0)'',
                ''rotateY(0)'', ''rotateZ(0)'', ''skew(0, 0)'', ''skewX(0)'', ''skewY(0)'', ''matrix(1, 0, 0, 1, 0,
                0)'' and ''matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)''. A special
                case is perspective: ''perspective(infinity)''. The value of m<sub>34</sub>
                becomes infinitesimal small and the transform function is therefore assumed to be
                equal to the identity matrix.
              </p>
            </dd>

            <dt id="Term3DRenderingContext"><dfn>3D rendering context</dfn></dt>
            <dd>
              <p>
                A containing block hierarchy of one or more levels, instantiated by elements with a
                computed value for the 'transform-style' property of ''preserve-3d'', whose elements
                share a common three-dimensional coordinate system.
              </p>
            </dd>
          </dl>

          <!-- ======================================================================================================= -->

          <h2 id="two-dimensional-subset">
            Two Dimensional Subset
          </h2>

          <p>
            UAs may not always be able to render three-dimensional transforms and then just
            support a two-dimensional subset of this specification. In this case <a
            href="#three-d-transform-functions">three-dimensional transforms</a> and the
            properties 'transform-style', 'perspective', 'perspective-origin' and
            'backface-visibility' must not be supported. Section <a
            href="#transform-3d-rendering">3D Transform Rendering</a> does not apply.
            Matrix decomposing uses the technique taken from the "unmatrix" method in "Graphics
            Gems II, edited by Jim Arvo", simplified for the 2D case. Section
            <a href="#mathematical-description">Mathematical Description of Transform Functions</a>
            is still effective but can be reduced by using a 3x3 transformation matrix where
            <em>a</em> equals <em>m<sub>11</sub></em>, <em>b</em> equals <em>m<sub>12</sub></em>,
            <em>c</em> equals <em>m<sub>21</sub></em>, <em>d</em> equals <em>m<sub>22</sub></em>,
            <em>e</em> equals <em>m<sub>41</sub></em> and <em>f</em> equals <em>m<sub>42</sub></em>
            (see <a href="#MatrixDefined">A 2D 3x2 matrix with six parameter</a>).
          </p>

          <div class="figure">
            <img src="3x3matrix.png" alt="3x3 matrix" title="\begin{bmatrix} a & c & e \\ b
            & d & f \\ 0 & 0 & 1 \end{bmatrix}" width="82" height="79">
             <p class="caption">
               3x3 matrix for two-dimensional transformations.
            </p>
          </div>

          <div class="example">
            <p>
              Authors can easily provide a fallback if UAs do not provide support for
              three-dimensional transforms. The following example has two property definitions
              for 'transform'. The first one consists of two two-dimensional transform
              functions. The second one has a two-dimensional and a three-dimensional transform
              function.
            </p>
            <pre>div {
    transform: scale(2) rotate(45deg);
    transform: scale(2) rotate3d(0, 0, 1, 45deg);
}</pre>

            <p>
              With 3D support, the second definition will override the first one. Without 3D
              support, the second definition is invalid and a UA falls back to the first
              definition.
            </p>
          </div>

          <!-- ======================================================================================================= -->

          <h2 id="transform-rendering">The Transform Rendering Model</h2>
            <p><em>This section is normative.</em></p>
            <p>
              Specifying a value other than ''none'' for the ''transform'' property establishes a
              new <var>local coordinate system</var> at the element that it is
              applied to. The mapping from where the element would have rendered into that local
              coordinate system is given by the element's <var>transformation
              matrix</var>. Transformations are cumulative. That is, elements establish their local
              coordinate system within the coordinate system of their parent. From the perspective
              of the user, an element effectively accumulates all the 'transform' properties of its
              ancestors as well as any local transform applied to it. The accumulation of these
              transforms defines a <var>current transformation matrix (CTM)</var> for
              the element.
            </p>
            <p>
              The coordinate space is a
              coordinate system with two axes: the X axis increases horizontally to the right; the
              Y axis increases vertically downwards. Three-dimensional transform functions extend
              this coordinate space into three dimensions, adding a Z axis perpendicular to the
              plane of the screen, that increases towards the viewer.
            </p>

            <div class="figure">
              <img src="coordinates.svg" width="270" height="240" alt="Demonstration of the initial coordinate space">
              <p class="caption">
                 Demonstration of the initial coordinate space.
              </p>
            </div>

            <p id="transformation-matrix-computation">
              The <var>transformation matrix</var> is computed
              from the 'transform' and 'transform-origin' properties as follows:
              <ol>
                <li>Start with the identity matrix.</li>
                <li>Translate by the computed X, Y and Z values of 'transform-origin'</li>
                <li>Multiply by each of the transform functions in 'transform' property from left to right</li>
                <li>Translate by the negated computed X, Y and Z values of 'transform-origin'</li>
              </ol>

            <p>
              Transforms apply to <var>transformable elements</var>.
            </p>

            <div class="example">
              <pre>
div {
    transform: translate(100px, 100px);
}
</pre>
                <p>This transform moves the element by 100 pixels in both the X and Y directions.</p>
                <div class="figure">
                  <img src="examples/translate1.svg" alt="The 100px translation in X and Y"
                  width="470" height="250">
                </div>
              </div>
              
              <div class="example">
                <pre>div {
    height: 100px; width: 100px;
    transform-origin: 50px 50px;
    transform: rotate(45deg);
}</pre>

                <p>
                  The 'transform-origin' property moves the point of origin by 50 pixels in both
                  the X and Y directions. The transform rotates the element clockwise by 45° about
                  the point of origin. After all transform functions were applied, the translation
                  of the origin gets translated back by -50 pixels in both the X and Y directions.
                </p>

                <div class="figure">
                  <img alt="The point of origin gets translated temporary" src="examples/origin1.svg"
                  width="735" height="250">
                </div>
              </div>

              <div class="example">
                <pre>
div {
    height: 100px; width: 100px;
    transform: translate(80px, 80px) scale(1.5, 1.5) rotate(45deg);
}
</pre>
                <p>
                  This transform moves the element by 80 pixels in both the X and Y directions, then
                  scales the element by 150%, then rotates it 45&deg; clockwise about the Z axis.
                  Note that the scale and rotation operate about the center of the element, since
                  the element has the default transform-origin of ''50% 50%''.
                </p>

                <div class="figure">
                  <img src="examples/compound_transform.svg" alt="The transform specified above"
                    width="270" height="270">
                </div>

                <p>
                  Note that an identical rendering can be obtained by nesting elements with the
                  equivalent transforms:
                </p>

                <pre>
&lt;div style="transform: translate(80px, 80px)"&gt;
    &lt;div style="transform: scale(1.5, 1.5)"&gt;
        &lt;div style="transform: rotate(45deg)"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
              </div>

              <p>
                For elements whose layout is governed by the CSS box model, the transform property
                does not affect the flow of the
                content surrounding the transformed element. However, the extent of the overflow
                area takes into account transformed elements. This behavior is similar to what
                happens when elements are offset via relative positioning. Therefore, if the value
                of the 'overflow' property is ''scroll'' or ''auto'', scrollbars will appear as
                needed to see content that is transformed outside the visible area.
              </p>
              <p>
                For elements whose layout is governed by the CSS box model, any value other than
                ''none'' for the transform results in
                the creation of both a stacking context and a containing block. The object acts as a
                containing block for fixed positioned descendants.
              </p>
              <p class="issue">
                Is this effect on position:fixed necessary? If so, need to go into more detail here
                about why fixed positioned objects should do this, i.e., that it's much harder to
                implement otherwise. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16328">Bug 16328</a>.
              </p>
              <p>
                <a href="http://www.w3.org/TR/css3-background/#fixed0">Fixed backgrounds</a>
                on the root element are affected by any transform specified for that element.
                For all other elements that are effected by a transform (i.e. have a transform
                applied to them, or to any of their ancestor elements), a value of ''fixed'' for the
                'background-attachment' property is treated as if it had a value of ''scroll''. The
                computed value of 'background-attachment' is not affected.

              <p class="note">
                If the root element is transformed, the transformation applies
                to the entire canvas, including any background specified for
                the root element.  Since <a href="http://www.w3.org/TR/css3-background/#special-backgrounds">
                the background painting area for the root element</a> is the entire
                canvas, which is infinite, the transformation might cause parts
                of the background that were originally off-screen to appear.
                For example, if the root element's background were repeating
                dots, and a transformation of ''scale(0.5)'' were specified on the
                root element, the dots would shrink to half their size, but
                there will be twice as many, so they still cover the whole
                viewport.
              </p>

              <h3 id="transform-3d-rendering">3D Transform Rendering</h3>

              <p>
                Normally, elements render as flat planes, and are rendered into the same plane
                as their containing block. Often this is the plane shared by the rest of the page.
                Two-dimensional transform functions can alter the appearance of an element, but
                that element is still rendered into the same plane as its containing block.
              </p>
              <p>
                Three-dimensional transforms can result in transformation matrices with a non-zero
                Z component (where the Z axis projects out of the plane of the screen). This can result
                in an element rendering on a different plane than that of its containing block. This
                may affect the front-to-back rendering order of that element relative to other elements,
                as well as causing it to intersect with other elements. This behavior depends on whether the
                element is a member of a <var>3D rendering context</var>, as described below.
              </p>
              <div class="issue">
                <p class="desc">This description does not exactly match what WebKit implements. Perhaps
                  it should be changed to match current implementations? See
                  <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19637">Bug 19637</a>.</p>
              </div>

              <div class="example">
                <p>This example shows the effect of three-dimensional transform applied to an element.
                </p>
<pre>
&lt;style&gt;
div {
    height: 150px;
    width: 150px;
}
.container {
    border: 1px solid black;
}
.transformed {
    transform: rotateY(50deg);
}
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
              <div class="figure">
                <img src="examples/simple-3d-example.png" width="210" height="190" alt="Div with a rotateY transform.">
              </div>
                <p>The transform is a 50&deg; rotation about the vertical, Y axis. Note how this makes the blue box appear
                  narrower, but not three-dimensional.
                </p>
              </div>

              <p>
                The 'perspective' and 'perspective-origin' properties can be used to add a feeling
                of depth to a scene by making elements higher on the Z axis (closer to the viewer)
                appear larger, and those further away to appear smaller. The scaling is proportional
                to <var>d</var>/(<var>d</var> &minus; <var>Z</var>) where <var>d</var>, the value of
                'perspective', is the distance from the drawing plane to the the assumed position of
                the viewer's eye.
              </p>

              <div class="figure">
                <img alt="Diagram of scale vs. Z position" src="perspective_distance.png">
                <p class="caption">
                  Diagrams showing how scaling depends on the 'perspective' property and Z position.
                  In the top diagram, <var>Z</var> is half of <var>d</var>. In order to make it
                  appear that the original circle (solid outline) appears at <var>Z</var> (dashed
                  circle), the circle is scaled up by a factor of two, resulting in the light blue
                  circle. In the bottom diagram, the circle is scaled down by a factor of one-third
                  to make it appear behind the original position.
                </p>
              </div>

              <p>
                Normally the assumed position of the viewer's eye is
                centered on a drawing. This position can be moved if
                desired &ndash; for example, if a web page contains
                multiple drawings that should share a common perspective
                &ndash; by setting 'perspective-origin'.
              </p>

              <div class="figure">
                <img alt="Diagram of different perspective-origin" src="perspective_origin.png">
                <p class="caption">
                  Diagram showing the effect of moving the perspective origin upward.
                </p>
              </div>

              <p id="perspective-matrix-computation">
                The <a href="#TermPerspectiveMatrix"><i>perspective matrix</i></a> is computed as follows:
                <ol>
                  <li>Start with the identity matrix.</li>
                  <li>Translate by the computed X and Y values of 'perspective-origin'</li>
                  <li>Multiply by the matrix that would be obtained from the '<a href="#perspective-function"><code class="css">perspective(&lt;length&gt;)</code></a>' transform function, where the length is provided by the value of the 'perspective' property</li>
                  <li>Translate by the negated computed X and Y values of 'perspective-origin'</li>
                </ol>


              <div class="example">
                <p>This example shows how perspective can be used to cause three-dimensional transforms to appear more realistic.
                </p>
<pre>
&lt;style&gt;
div {
    height: 150px;
    width: 150px;
}
.container {
    perspective: 500px;
    border: 1px solid black;
}
.transformed {
    transform: rotateY(50deg);
}
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div class="transformed"&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
                <div class="figure">
                    <img src="examples/simple-perspective-example.png" width="210" height="190" alt="Div with a rotateY transform,
                    and perspective on its container">
                </div>
                <p>The inner element has the same transform as in the previous example, but its rendering is now influenced by the perspective
                  property on its parent element. Perspective causes vertices that have positive Z coordinates (closer to the viewer)
                  to be scaled up in X and Y, and those further away (negative Z coordinates) to be scaled down, giving an appearance of depth.
                </p>
              </div>

              <p>
                An element with a three-dimensional transform that is not contained in a
                <var>3D rendering context</var> renders with the appropriate
                transform applied, but does not intersect with any other elements. The three-dimensional
                transform in this case can be considered just as a painting effect, like two-dimensional
                transforms. Similarly, the transform does not affect painting order. For example, a transform with a
                positive Z translation may make an element look larger, but does not cause that element
                to render in front of elements with no translation in Z.
              </p>
              <p>
                An element with a three-dimensional transform that is contained in a
                <var>3D rendering context</var> can visibly interact with other elements
                in that same 3D rendering context; the set of elements participating in the same
                <var>3D rendering context</var> may obscure each other or intersect,
                based on their computed transforms. They are rendered as if they are all siblings,
                positioned in a common 3D coordinate space. The position of each element in that three-dimensional
                space is determined by accumulating the transformation matrices
                up from the element that establishes the <var>3D rendering context</var>
                through each element that is a containing block for the given element, as described below.
              </p>

              <div class="example">
<pre>
&lt;style&gt;
div {
    height: 150px;
    width: 150px;
}
.container {
    perspective: 500px;
    border: 1px solid black;
}
.transformed {
    transform: rotateY(50deg);
    background-color: blue;
}
.child {
    transform-origin: top left;
    transform: rotateX(40deg);
    background-color: lime;
}
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div class="transformed"&gt;
        &lt;div class="child"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
                <p>This example shows how nested 3D transforms are rendered in the absence of ''transform-style: preserve-3d''. The blue div is transformed as in the previous example, with its rendering influenced by the perspective on its parent element. The lime element also has a 3D transform, which is a rotation about the X axis (anchored at the top, by virtue of the transform-origin). However, the lime element is being rendered into the plane of its parent because it is not a member of a 3D rendering context; the parent is "flattening".
                </p>
                <div class="figure">
                  <img src="examples/3d-rendering-context-flat.png" width="240" height="200" alt="Nested 3D transforms, with flattening">
                </div>
              </div>

              <p>Elements establish and participate in 3D rendering contexts as follows:</p>
              <ul>
                <li>
                  A <var>3D rendering context</var> is established by a
                  a <var>transformable element</var> whose computed value for 'transform-style' is
                  ''preserve-3d'', and which itself is not part of a 3D rendering context.
                  Note that such an element is always a containing block. An element that establishes a 3D rendering context
                  also participates in that context.
                </li>
                <li>
                  An element whose computed value for 'transform-style' is
                  ''preserve-3d'', and which itself participates in a
                  <var>3D rendering context</var>, extends that 3D rendering context rather than establishing
                  a new one.
                </li>
                <li>
                  An element participates in a <var>3D rendering context</var> if its containing block
                  establishes or extends a <var>3D rendering context</var>.
                </li>
              </ul>
              <p id="accumulated-3d-transformation-matrix-computation">
                The final value of the transform used to render an element in a <var>3D rendering context</avr>
                is computed by accumulating an
                <var>accumulated 3D transformation matrix</var> as follows:
              </p>
              <ol>
                <li>Start with the identity matrix.</li>
                <li>For each containing block between the root of the <var>3D rendering context</var>
                  and the element in question:
                  <ol>
                    <li>multiply the accumulated matrix with the <var>perspective matrix</var>
                      on the element's containing block (if any). That containing block is not necessarily a member
                      of the 3D rendering context.</li>
                    <li>apply to the accumulated matrix a translation equivalent to the horizontal and vertical offset of the element relative to
                      its containing block as specified by the CSS visual formatting model.</li>
                    <li>multiply the accumulated matrix with the <var>transformation matrix</var>.</li>
                  </ol>
                </li>
              </ol>

              <div class="example">
<pre>
&lt;style&gt;
div {
    height: 150px;
    width: 150px;
}
.container {
    perspective: 500px;
    border: 1px solid black;
}
.transformed {
    <b>transform-style: preserve-3d</b>;
    transform: rotateY(50deg);
    background-color: blue;
}
.child {
    transform-origin: top left;
    transform: rotateX(40deg);
    background-color: lime;
}
&lt;/style&gt;
</pre>
                <p>
                  This example is identical to the previous example, with the addition of
                  ''transform-style: preserve-3d'' on the blue element. The blue element now
                  establishes a 3D rendering context, of which the lime element is a member. Now
                  both blue and lime elements share a common three-dimensional space, so the lime
                  element renders as tilting out from its parent, influenced by the perspective on
                  the container.
                </p>
                <div class="figure">
                  <img src="examples/3d-rendering-context-3d.png" width="240" height="200" alt="Nested 3D transforms, with preserve-3d.">
                </div>
              </div>

              <p>
                Elements in the same <var>3D rendering context</var> may intersect with each other. User agents must
                render intersection by subdividing the planes of intersecting elements as described by
                <a href="http://en.wikipedia.org/wiki/Newell's_algorithm">Newell's algorithm</a>.
              </p>
              <p>
                Untransformed elements in a <var>3D rendering context</var> render on the Z=0 plane, yet may still
                intersect with transformed elements.
              </p>
              <p>
                Within a <var>3D rendering context</var>, the rendering order of non-intersecting elements is
                based on their position on the Z axis after the application of the accumulated transform. Elements at the same
                Z position render in <a href="http://www.w3.org/TR/CSS2/zindex.html#painting-order">stacking context order</a>.
              </p>

              <div class="example">
<pre>
&lt;style&gt;
.container {
    background-color: rgba(0, 0, 0, 0.3);
    transform-style: preserve-3d;
    perspective: 500px;
}
.container > div {
    position: absolute;
    left: 0;
}
.container > :first-child {
    transform: rotateY(45deg);
    background-color: orange;
    top: 10px;
    height: 135px;
}
.container > :last-child {
    transform: translateZ(40px);
    background-color: rgba(0, 0, 255, 0.75);
    top: 50px;
    height: 100px;
}
&lt;/style&gt;

&lt;div class="container"&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
                <p>
                  This example shows show elements in a 3D rendering context can intersect. The container element establishes
                  a 3D rendering context for itself and its two children. The children intersect with eachother, and
                  the orange element also intersects with the container.
                </p>
                <div class="figure">
                  <img src="examples/3d-intersection.png" width="200" height="200" alt="Intersecting sibling elements.">
                </div>
              </div>

              <p>
                Using three-dimensional transforms, it's possible to transform an element such that its reverse side
                is towards the viewer. 3D-transformed elements show the same content on both sides, so the reverse side
                looks like a mirror-image of the front side (as if the element were projected onto a sheet of glass).
                Normally, elements whose reverse side is towards the viewer remain visible. However, the
                'backface-visibility' property allows the author to make an element invisible
                when its reverse side is towards the viewer. This behavior is "live"; if an element with
                ''backface-visibility: hidden'' were animating,
                such that its front and reverse sides were alternately visible, then it would only be visible when the
                front side were towards the viewer.
              </p>
              <div class="issue">
                <p class="desc">
                  This wording needs clarification; backface-visibility works per-3D rendering context, not relative to the root.
                </p>
              </div>

              <h3 id="processing-of-perspective-transformed-boxes">
                Processing of Perspective-Transformed Boxes
              </h3>

              <div class="issue">
                <p class="desc">
                  This is a first pass at an attempt to precisely specify how
                  exactly to transform elements using the provided matrices.
                  It might not be ideal, and implementer feedback is
                  encouraged.  See <a
                  href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15605">bug
                  15605</a>.
                </p>
              </div>

              <p>
                The <var>accumulated
                3D transformation matrix</var> is a 4&times;4 matrix, while the
                objects to be transformed are two-dimensional boxes.  To
                transform each corner (<var>a</var>, <var>b</var>) of a box, the
                matrix must first be applied to (<var>a</var>, <var>b</var>, 0,
                1), which will result in a four-dimensional point (<var>x</var>,
                <var>y</var>, <var>z</var>, <var>w</var>).  This is transformed
                back to a three-dimensional point (<var>x</var>&prime;, <var>y</var>&prime;,
                <var>z</var>&prime;) as follows:
              </p>

              <p>
                If <var>w</var> &gt; 0, (<var>x</var>&prime;,
                <var>y</var>&prime;, <var>z</var>&prime;) =
                (<var>x</var>/<var>w</var>, <var>y</var>/<var>w</var>,
                <var>z</var>/<var>w</var>).
              </p>

              <p>
                If <var>w</var> = 0, (<var>x</var>&prime;, <var>y</var>&prime;,
                <var>z</var>&prime;) = (<var>x</var> &sdot; <var>n</var>,
                <var>y</var> &sdot; <var>n</var>, <var>z</var> &sdot;
                <var>n</var>).  <var>n</var> is an implementation-dependent value
                that should be chosen so that <var>x</var>&prime; or
                <var>y</var>&prime; is much larger than the viewport size, if
                possible.  For example, (5px, 22px, 0px, 0) might become (5000px,
                22000px, 0px), with <var>n</var> = 1000, but this value of
                <var>n</var> would be too small for (0.1px, 0.05px, 0px, 0).
                This specification does not define the value of <var>n</var>
                exactly.  Conceptually, (<var>x</var>&prime;,
                <var>y</var>&prime;, <var>z</var>&prime;) is <a
                href="http://en.wikipedia.org/wiki/Plane_at_infinity">infinitely
                far</a> in the direction (<var>x</var>, <var>y</var>,
                <var>z</var>).
              </p>

              <p>
                If <var>w</var> &lt; 0 for all four corners of the transformed
                box, the box is not rendered. 
              </p>

              <p>
                If <var>w</var> &lt; 0 for one to three corners of the
                transformed box, the box must be replaced by a polygon that has
                any parts with <var>w</var> &lt; 0 cut out.  This will in general
                be a polygon with three to five vertices, of which exactly two
                will have <var>w</var> = 0 and the rest <var>w</var> &gt; 0.
                These vertices are then transformed to three-dimensional points
                using the rules just stated.  Conceptually, a point with
                <var>w</var> &lt; 0 is "behind" the viewer, so should not be
                visible.
              </p>

              <div class="example">
<pre>&lt;style&gt;
.transformed {
    height: 100px;
    width: 100px;
    background: lime;
    transform: perspective(50px) translateZ(100px);
}
&lt;/style&gt;</pre>

                <p>
                  All of the box's corners have <var>z</var>-coordinates greater
                  than the perspective.  This means that the box is behind the
                  viewer and will not display.  Mathematically, the point
                  (<var>x</var>, <var>y</var>) first becomes (<var>x</var>,
                  <var>y</var>, 0, 1), then is translated to (<var>x</var>,
                  <var>y</var>, 100, 1), and then applying the perspective
                  results in (<var>x</var>, <var>y</var>, 100, &minus;1).  The
                  <var>w</var>-coordinate is negative, so it does not display.
                  An implementation that doesn't handle the <var>w</var> &lt; 0
                  case separately might incorrectly display this point as
                  (&minus;<var>x</var>, &minus;<var>y</var>, &minus;100),
                  dividing by &minus;1 and mirroring the box.
                </p>
              </div>

              <div class="example">
<pre>&lt;style&gt;
.transformed {
    height: 100px;
    width: 100px;
    background: radial-gradient(yellow, blue);
    transform: perspective(50px) translateZ(50px);
}
&lt;/style&gt;</pre>

                <p>
                  Here, the box is translated upward so that it sits at the same
                  place the viewer is looking from.  This is like bringing the
                  box closer and closer to one's eye until it fills the entire
                  field of vision.  Since the default transform-origin is at the
                  center of the box, which is yellow, the screen will be filled
                  with yellow.
                </p>
                <p>
                  Mathematically, the point (<var>x</var>, <var>y</var>) first
                  becomes (<var>x</var>, <var>y</var>, 0, 1), then is translated
                  to (<var>x</var>, <var>y</var>, 50, 1), then becomes
                  (<var>x</var>, <var>y</var>, 50, 0) after applying perspective.
                  Relative to the transform-origin at the center, the upper-left
                  corner was (&minus;50, &minus;50), so it becomes (&minus;50,
                  &minus;50, 50, 0).  This is transformed to something
                  very far to the upper left, such as (&minus;5000, &minus;5000,
                  5000).  Likewise the other corners are sent very far away.  The
                  radial gradient is stretched over the whole box, now enormous,
                  so the part that's visible without scrolling should be the
                  color of the middle pixel: yellow.  However, since the box is
                  not actually infinite, the user can still scroll to the edges
                  to see the blue parts.
                </p>
              </div>
              <div class="issue">
                <p class="desc">
                  WebKit doesn't render this box unless the translateZ() is &lt; 50px.
                </p>
              </div>

              <div class="example">
<pre>&lt;style&gt;
.transformed {
    height: 50px;
    width: 50px;
    background: lime;
    border: 25px solid blue;
    transform-origin: left;
    transform: perspective(50px) rotateY(-45deg);
}
&lt;/style&gt;</pre>

                <p>
                  The box will be rotated toward the viewer, with the left edge
                  staying fixed while the right edge swings closer.  The right
                  edge will be at about <var>z</var> = 70.7px, which is closer
                  than the perspective of 50px.  Therefore, the rightmost edge
                  will vanish ("behind" the viewer), and the visible part will
                  stretch out infinitely far to the right.
                </p>

                <p>
                  Mathematically, the top right vertex of the box was originally
                  (100, &minus;50), relative to the transform-origin.  It is first
                  expanded to (100, &minus;50, 0, 1).  After applying the
                  transform specified, this will get mapped to about (70.71,
                  &minus;50, 70.71, &minus;0.4142).  This has <var>w</var> =
                  &minus;0.4142 &lt; 0, so we need to slice away the part of the
                  box with <var>w</var> &lt; 0.  This results in the new
                  top-right vertex being (50, &minus;50, 50, 0).  This is then
                  mapped to some faraway point in the same direction, such as
                  (5000, &minus;5000, 5000), which is up and to the right from
                  the transform-origin.  Something similar is done to the lower
                  right corner, which gets mapped far down and to the right.  The
                  resulting box stretches far past the edge of the screen.
                </p>

                <p>
                  Again, the rendered box is still finite, so the user can scroll
                  to see the whole thing if he or she chooses.  However, the
                  right part has been chopped off.  No matter how far the user
                  scrolls, the rightmost 30px or so of the original box will not
                  be visible.  The blue border was only 25px wide, so it will be
                  visible on the left, top, and bottom, but not the right.
                </p>

                <p>
                  The same basic procedure would apply if one or three vertices
                  had <var>w</var> &lt; 0.  However, in that case the result of
                  truncating the <var>w</var> &lt; 0 part would be a triangle or
                  pentagon instead of a quadrilateral.
                </p>
              </div>

              <!-- ======================================================================================================= -->

              <h2 id="transform-property">
                The 'transform' Property
              </h2>
              <p>
                A transformation is applied to the coordinate system an element
                renders in through the 'transform' property. This property contains a
                list of <a href="#transform-functions">transform functions</a>. The
                final transformation value for a coordinate system is obtained by converting
                each function in the list to its corresponding matrix like defined in <a
                href="#mathematical-description">Mathematical Description of Transform
                Functions</a>, then multiplying the matrices.
              </p>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="effects">transform</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]*
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      none
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      refer to the size of
                      <var>bounding box</var>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      As specified, but with relative lengths converted into
                      absolute lengths.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Animatable:</em>
                    </td>
                    <td>
                      as <a href="#animation">transform</a>
                    </td>
                  </tr>
                </tbody>
              </table>

              <p>
                Any value other than ''none'' for the transform results in the creation of both a
                stacking context and a containing block. The object acts as a containing block for
                fixed positioned descendants.
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="transform-origin-property">
                The 'transform-origin' Property
              </h2>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="transform-origin">transform-origin</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      &nbsp;&nbsp;[ left | center | right | top | bottom | <var>&lt;percentage></var> | <var>&lt;length></var> ]<br>
                      |<br>
                      &nbsp;&nbsp;[ left | center | right | <var>&lt;percentage></var> | <var>&lt;length></var> ]<br>
                      &nbsp;&nbsp;[ top | center | bottom | <var>&lt;percentage></var> | <var>&lt;length></var> ] <var>&lt;length></var>?<br>
                      |<br>
                      &nbsp;&nbsp;[ center | [ left | right ] ] && [ center | [ top | bottom ] ] <var>&lt;length></var>?
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      50% 50%
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      refer to the size of
                      <var>bounding box</var>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      For &lt;length&gt; the absolute value, otherwise a percentage
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Animatable:</em>
                    </td>
                    <td>
                      as <a href="http://dev.w3.org/csswg/css3-transitions/#animtype-simple-list">simple list</a> of <a href="http://dev.w3.org/csswg/css3-transitions/#animtype-lpcalc">length, percentage, or calc</a>
                    </td>
                  </tr>
                </tbody>
              </table>
              
              <p>
                The default value for SVG elements without associated CSS layout box is ''0 0''.
              </p>

              <p>
                The values of the 'transform' and 'transform-origin' properties are used to compute
                the <var>transformation matrix</var>, as
                described above.
              </p>

              <p>
                If only one value is specified, the second value is assumed to be ''center''. If one
                or two values are specified, the third value is assumed to be ''0px''.
              </p>

              <p>
                If two or more values are defined and either no value is a keyword, or the only
                used keyword is ''center'', then the first value represents the horizontal position
                (or offset) and the second represents the vertical position (or offset). A third
                value always represents the Z position (or offset) and must be of type
                <var>&lt;length&gt;</var>.
              </p>

              <dl>
                <dt><var>&lt;percentage&gt;</var>

                <dd><p>A percentage for the horizontal offset is relative to the width of the 
                  <var>bounding box</var>.
                  A percentage for the vertical offset is relative to height of the 
                  <var>bounding box</var>. The value for the horizontal
                  and vertical offset represent an offset from the top left corner of the
                  <var>bounding box</var>.
                  </p>

                <dt><var>&lt;length&gt;</var>

                <dd>
                  <p>A length value gives a fixed length as the offset. The value for the horizontal
                    and vertical offset represent an offset from the top left corner of the
                    <var>bounding box</var>.
                  </p>

                  <p>For SVG elements without an associated CSS layout box the horizontal
                    and vertical offset represent an offset from the point of origin of
                    the element's local coordinate space.
                  </p>
                </dd>

                <dt><dfn title="''top''!!'transform-origin' value">''top''</dfn>

                <dd>Computes to ''0%'' for the vertical position.

                <dt><dfn title="''right''!!'transform-origin' value">''right''</dfn>

                <dd>Computes to ''100%'' for the horizontal position.

                <dt><dfn title="''bottom''!!'transform-origin' value">''bottom''</dfn>

                <dd>Computes to ''100%'' for the vertical position.

                <dt><dfn title="''left''!!'transform-origin' value">''left''</dfn>

                <dd>Computes to ''0%'' for the horizontal position.

                <dt><dfn title="''center''!!'transform-origin' value">''center''</dfn>

                <dd>Computes to ''50%'' (''left 50%'') for the
                  horizontal position if the horizontal position is not otherwise
                  specified, or ''50%'' (''top 50%'') for the vertical position if
                  it is.
              </dl>

              <p>
                The <a href="http://www.w3.org/TR/cssom/#resolved-value">resolved value</a>
                of 'transform-origin' is the
                <a href="http://www.w3.org/TR/CSS21/cascade.html#used-value">used value</a>
                (i.e., percentages are resolved to absolute lengths).
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="transform-style-property">
                The 'transform-style' Property
              </h2>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="transform-style">transform-style</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      flat | preserve-3d
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      flat
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      N/A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Same as specified value.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Animatable:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                </tbody>
              </table>

              <p>
                A value of ''preserve-3d'' for 'transform-style' establishes a stacking context.
              </p>

              <p>
                The following CSS property values require the user agent to create a flattened representation of
                the descendant elements before they can be applied, and therefore override the behavior of
                ''transform-style: preserve-3d'':</p>
              <ul>
                <li>'overflow': any value other than ''visible''.</li>
                <li>'opacity': any value other than ''1''.</li>
                <li>'filter': any value other than ''none''.</li>
                <li>'clip': any value other than ''auto''.</li>
                <li>'clip-path': any value other than ''none''.</li>
                <li>'mask-image': any value other than ''none''.</li>
                <li>'mask-box-image-source': any value other than ''none''.</li>
                <li>'mix-blend-mode': any value other than ''normal''.</li>
              </ul>

              <p>
                The computed value of 'transform-style' is not affected.
              </p>

              <p>
                The values of the 'transform' and 'transform-origin' properties are used to compute
                the <var>transformation matrix</var>, as described above.
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="perspective-property">
                The 'perspective' Property
              </h2>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="perspective">perspective</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      none | &lt;length&gt;
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      none
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      N/A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Absolute length or "none".
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Animatable:</em>
                    </td>
                    <td>
                      as <a href="http://dev.w3.org/csswg/css3-transitions/#animtype-length">length</a>
                    </td>
                  </tr>
                </tbody>
              </table>

              <p>
                If the value is ''none'', no perspective
                transform is applied.  Lengths must be positive.
              </p>
              <p>
                The use of this property with any value other than ''none'' establishes a
                stacking context. It also establishes a containing block (somewhat
                similar to ''position: relative''), just like the 'transform' property does.
              </p>
              <p>
                The values of the 'perspective' and 'perspective-origin' properties are used to
                compute the <var>perspective matrix</var>, as described above.
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="perspective-origin-property">
                The 'perspective-origin' Property
              </h2>
              <p>
                The 'perspective-origin' property establishes the origin for the
                <em>perspective</em> property. It effectively sets the X and Y position at which the
                viewer appears to be looking at the children of the element.
              </p>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="perspective-origin">perspective-origin</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      &nbsp;&nbsp;[ left | center | right | top | bottom | <var>&lt;percentage></var> | <var>&lt;length></var> ]<br>
                      |<br>
                      &nbsp;&nbsp;[ left | center | right | <var>&lt;percentage></var> | <var>&lt;length></var> ]<br>
                      &nbsp;&nbsp;[ top | center | bottom | <var>&lt;percentage></var> | <var>&lt;length></var> ]<br>
                      |<br>
                      &nbsp;&nbsp;[ center | [ left | right ] ] && [ center | [ top | bottom ] ]
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      50% 50%
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      refer to the size of the
                      <var>bounding box</var>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      For &lt;length&gt; the absolute value, otherwise a
                      percentage.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Animatable:</em>
                    </td>
                    <td>
                      as <a href="http://dev.w3.org/csswg/css3-transitions/#animtype-simple-list">simple list</a> of <a href="http://dev.w3.org/csswg/css3-transitions/#animtype-lpcalc">length, percentage, or calc</a>
                    </td>
                  </tr>
                </tbody>
              </table>
              <p>
                The values of the 'perspective' and 'perspective-origin' properties are used to
                compute the <var>perspective matrix</var>, as described above.
              </p>

              <p>
                If only one value is specified, the second value is assumed to be ''center''.
              </p>

              <p>
                If at least one of the two values is not a keyword, then the
                first value represents the horizontal position (or offset) and
                the second represents the vertical position (or offset).
              </p>

              <p>
                The values for 'perspective-origin' represent an offset of the perspective origin
                from the top
                left corner of the <var>bounding box</var>.
              </p>

              <dl>
                <dt><var>&lt;percentage&gt;</var>

                <dd><p>A percentage for the horizontal perspctive offset is relative to the width of the 
                  <var>bounding box</var>.
                  A percentage for the vertical offset is relative to height of the 
                  <var>bounding box</var>. The value for the horizontal
                  and vertical offset represent an offset from the top left corner of the
                  <var>bounding box</var>.
                  </p>

                <dt><var>&lt;length&gt;</var>

                <dd>
                  <p>A length value gives a fixed length as the offset. The value for the horizontal
                    and vertical offset represent an offset from the top left corner of the
                    <var>bounding box</var>.
                </dd>

                <dt><dfn title="''top''!!'perspective-origin' value">''top''</dfn>

                <dd>Computes to ''0%'' for the vertical position.

                <dt><dfn title="''right''!!'perspective-origin' value">''right''</dfn>

                <dd>Computes to ''100%'' for the horizontal position.

                <dt><dfn title="''bottom''!!'perspective-origin' value">''bottom''</dfn>

                <dd>Computes to ''100%'' for the vertical position.

                <dt><dfn title="''left''!!'perspective-origin' value">''left''</dfn>

                <dd>Computes to ''0%'' for the horizontal position.

                <dt><dfn title="''center''!!'perspective-origin' value">''center''</dfn>

                <dd>Computes to ''50%'' (''left 50%'') for the
                  horizontal position if the horizontal position is not otherwise
                  specified, or ''50%'' (''top 50%'') for the vertical position if
                  it is.
              </dl>

              <p>
                The <a href="http://www.w3.org/TR/cssom/#resolved-value">resolved value</a>
                of 'perspective-origin' is the
                <a href="http://www.w3.org/TR/CSS21/cascade.html#used-value">used value</a>
                (i.e., percentages are resolved to absolute lengths).
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="backface-visibility-property">
                The 'backface-visibility' Property
              </h2>
              <p>
                The 'backface-visibility' property
                determines whether or not the "back" side of a transformed element is
                visible when facing the viewer. With an identity transform, the front
                side of an element faces the viewer. Applying a rotation about Y of 180
                degrees (for instance) would cause the back side of the element to face
                the viewer.
              </p>
              <p class="note">
                Note that this property is useful when you place two elements back-to-back, as you
                would to create a playing card. Without this property, the front and
                back elements could switch places at times during an animation to flip
                the card. Another example is creating a box out of 6 elements, but where
                you want to see the inside faces of the box. This is useful when
                creating the backdrop for a 3 dimensional stage.
              </p>
              <table class="propdef">
                <tbody>
                  <tr>
                    <td>
                      <em>Name:</em>
                    </td>
                    <td>
                      <dfn id="backface-visibility">backface-visibility</dfn>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Value:</em>
                    </td>
                    <td>
                      visible | hidden
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Initial:</em>
                    </td>
                    <td>
                      visible
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Applies to:</em>
                    </td>
                    <td>
                      <a href="#TermTransformableElement">transformable elements</a>
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Inherited:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Percentages:</em>
                    </td>
                    <td>
                      N/A
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Media:</em>
                    </td>
                    <td>
                      visual
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Computed value:</em>
                    </td>
                    <td>
                      Same as specified value.
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <em>Animatable:</em>
                    </td>
                    <td>
                      no
                    </td>
                  </tr>
                </tbody>
              </table>
              <p>
                The visibility of an element with ''backface-visibility: hidden'' is determined
                as follows:
                <ol>
                  <li>
                    For an element in a
                    <var>3D rendering context</var>,
                    compute its
                    <var>
                    accumulated 3D transformation matrix</var>.  For an element
                    not in a
                    <var>3D rendering context</var>,
                    compute its
                    <var>transformation matrix</var>.
                  </li>
                  <li>
                    If the component of the matrix in row 3, column 3 is
                    negative, then the element should be hidden.  Otherwise it
                    is visible.
                  </li>
                </ol>

              <p class="note">
                The reasoning for this definition is as follows.  Assume
                elements are rectangles in the <var>x</var>&ndash;<var>y</var>
                plane with infinitesimal thickness.  The front of the
                untransformed element has coordinates like (<var>x</var>,
                <var>y</var>, <var>&epsilon;</var>), and the back is
                (<var>x</var>, <var>y</var>, &minus;<var>&epsilon;</var>), for
                some very small <var>&epsilon;</var>.  We want to know if after
                the transformation, the front of the element is closer to the
                viewer than the back (higher <var>z</var>-value) or further
                away.  The <var>z</var>-coordinate of the front will be
                <var>M</var><sub>13</sub><var>x</var> +
                <var>M</var><sub>23</sub><var>y</var> +
                <var>M</var><sub>33</sub><var>&epsilon;</var> +
                <var>M</var><sub>43</sub>, before accounting for perspective,
                and the back will be <var>M</var><sub>13</sub><var>x</var> +
                <var>M</var><sub>23</sub><var>y</var> &minus;
                <var>M</var><sub>33</sub><var>&epsilon;</var> +
                <var>M</var><sub>43</sub>.  The first quantity is greater than
                the second if and only if <var>M</var><sub>33</sub> > 0.  (If
                it equals zero, the front and back are equally close to the
                viewer.  This probably means something like a 90-degree
                rotation, which makes the element invisible anyway, so we don't
                really care whether it vanishes.)
              </p>
              
              <!-- ======================================================================================================= -->

              <h2 id="svg-transform">
                The SVG 'transform' Attribute
              </h2>

              <p>
                The <a href="http://www.w3.org/TR/2011/REC-SVG11-20110816/">SVG 1.1
                specification</a> did not specify the attributes 'transform', 'gradientTransform'
                or 'patternTransform' as <a>presentation attributes</a>. In order to improve the
                integration of SVG and HTML, this
                specification makes these SVG attributes presentation attributes and makes the
                'transform' property one that applies to <var>transformable
                elements</var> in the SVG namespace.
              </p>

              <p>
                This specification will also introduce the new presentation attributes
                'transform-origin', 'perspective', 'perspective-origin', 'transform-style' and
                'backface-visibility'.
              </p>

              <p>
                Values on new introduced presentation attributes get parsed following the syntax
                rules on <a href="#svg-data-types">SVG Data Types</a> [[SVG11]].
              </p>

              <h3 id="transform-attribute-specificity">
                SVG 'transform' attribute specificity
              </h3>

              <p>
                Since the previously named SVG attributes become presentation attributes, their
                participation in the CSS cascade is determined by the specificity of presentation
                attributes, as <a
                href="http://www.w3.org/TR/2011/REC-SVG11-20110816/styling.html#UsingPresentationAttributes">explained</a>
                in the SVG specification.
              </p>

              <div class="example">
                <p>
                  This example shows the combination of the 'transform' style property and the
                  'transform' presentation attribute.
                </p>

                <pre>&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;style&gt;
    .container {
        transform: translate(100px, 100px);
    }
    &lt;/style&gt;

    &lt;g class="container" transform="translate(200 200)"&gt;
        &lt;rect width="100" height="100" fill="blue" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</pre>

                <div class="figure">
                  <img src="examples/svg-translate1.svg" width="470" height="240"
                    alt="Translated SVG container element.">
                </div>

                <p>
                  Because of the participation to the CSS cascade, the 'transform' style property
                  overrides the 'transform' presentation attribute. Therefore the container gets
                  translated by ''100px'' in both the horizontal and the vertical directions,
                  instead of ''200px''.
                </p>
              </div>

              <h3 id="svg-syntax">
                Syntax of the SVG 'transform' attribute
              </h3>

              <p>
                To provide backwards compatibility, the syntax of the 'transform' presentation
                attribute differs from the syntax of the 'transform' style property as shown in the
                example above. However, the syntax used for the 'transform' style property can be
                used for a 'transform' presentation attribute value. Authors are advised to follow
                the rules of <a href="http://www.w3.org/TR/css3-values/#functional-notation">CSS
                Values and Units Module</a>. Therefore an author should write
                ''transform="translate(200px, 200px)"'' instead of
                ''transform="translate  (200 200)"'' because the second example with the spaces
                before the ''('', the missing comma between the arguments and the values without the
                explicit unit notation would be valid for the attribute only.
              </p>

              <h4 id="svg-transform-list">
                Transform List
              </h4>

              <p>
                The value for the 'transform' attribute consists of a transform list with zero or
                more transform functions using <a href="#svg-functional-notation">functional
                notation</a>. If the transform list consists of more than one transform function,
                these functions are separated by optional whitespace, an optional comma ('','')
                and optional whitespace. The transform list can have optional whitespace characters
                before and after the list.
              </p>

              <h4 id="svg-functional-notation">
                Functional Notation
              </h4>

              <p>
                The syntax starts with the name of the function followed by optional whitespace
                characters followed by a left parenthesis followed by optional whitespace followed
                by the argument(s) to the notation followed by optional whitespace followed by a
                right parenthesis. If a function takes more than one argument, the arguments are
                either separated by a comma ('','') with optional whitespace characters before and
                after the comma, or by one or more whitespace characters.
              </p>

              <h4 id="svg-data-types">
                SVG Data Types
              </h4>

              <p>
                Arguments on all new introduced presentation attributes consist of data types in the
                sense of <a href="http://www.w3.org/TR/css3-values/#functional-notation">CSS Values
                and Units Module</a>. The definitions of data types in CSS Values and Units Module
                are enhanced as follows:
              </p>

              <h5 id="svg-transform-value">
                The <var>&lt;translation-value&gt;</var> and <var>&lt;length&gt;</var> type
              </h5>

              <p>
                A translation-value or length can be a <var>&lt;number&gt;</var> without an unit
                identifier. In this case the <a href="#svg-number"><var>number</var></a> gets
                interpreted as "user unit". A user unit in the the <a
                href="http://www.w3.org/TR/2003/REC-SVG11-20030114/coords.html#InitialCoordinateSystem">initial
                coordinate system</a> is equivalent to the parent environment's notion of a pixel
                unit.
              </p>

              <h5 id="svg-angle">
                The <var>&lt;angle&gt;</var> type
              </h5>

              <p>
                An angle can be a <var>&lt;number&gt;</var> without an unit identifier. In this case
                the <a href="#svg-number"><i>number</i></a> gets interpreted as a value in degrees.
              </p>

              <h5 id="svg-number">
                The <var>&lt;number&gt;</var> type
              </h5>

              <p>
                SVG supports scientific notations for numbers. Therefore a <var>number</var> gets
                parsed like described in SVG <a
                href="http://www.w3.org/TR/SVG/types.html#DataTypeNumber">Basic data types</a> for
                SVG attributes.
              </p>

              <h3 id="svg-gradient-transform-pattern-transform">
                The SVG 'gradientTransform' and 'patternTransform' attributes
              </h3>

              <p>
                SVG specifies the attributes 'gradientTransform' and 'patternTransform'. This
                specification makes both attributes presentation attributes. Both attributes use the
                same <a href="#svg-syntax">syntax</a> as the SVG 'transform' attribute. This
                specification does not introduce corresponding CSS style properties. Both, the
                'gradientTransform' and the 'patternTransform' attribute, are presentation
                attributes for the 'transform' property.
              </p>

              <h3 id="svg-transform-functions">
                SVG transform functions
              </h3>

              <p>
                For backwards compatibility with existing SVG content, this specification supports
                all transform functions defined by <a
                href="http://www.w3.org/TR/SVG/coords.html#TransformAttribute">The 'transform'
                attribute</a> in [[SVG11]]. Therefore the two-dimensional transform function
                ''rotate(&lt;angle&gt;)'' is extended as follows:
              </p>

              <dl>
                <dt id="rotate-three-function">
                  <code class="css">rotate(&lt;angle&gt;[, &lt;translation-value&gt;,
                  &lt;translation-value&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#RotateDefined">2D rotation</a> by the angle specified in the
                  parameter about the origin of the element, as defined by the 'transform-origin'
                  property. If the optional translation values are specified, the transform origin
                  is translated by that amount (using the current transformation matrix) for the
                  duration of the rotate operation. For example ''rotate(90deg, 100px, 100px)''
                  would cause elements to appear rotated one-quarter of a turn in the clockwise
                  direction after a translation of the transform-origin of 100 pixel in the
                  horizontal and vertical directions.
                </dd>
              </dl>

              <p>
                User agents are just required to support the two optional arguments for translation
                on elements in the SVG namespace.
              </p>

              <h3 id="svg-three-dimensional-functions">SVG and 3D transform functions</h3>

              <p>
                This specification explicitly requires three-dimensional transform functions to
                apply to the <a>container elements</a>: <a>'a element'</a>, <a>'g element'</a>,
                <a>'svg element'</a>, all <a>graphics elements</a>, all <a>graphics referencing elements</a>
                and the SVG <a>'foreignObject element'</a> element.
              </p>

              <p>
                Three-dimensional transform functions and the properties 'perspective',
                'perspective-origin', 'transform-style' and 'backface-visibility' can not be used
                for the elements: <a>'clipPath element'</a>, <a>'linearGradient element'</a>,
                <a>'radialGradient element'</a> and <a>'pattern element'</a>. If a transform list
                includes a three-dimensional transform function, the
                complete transform list must be ignored. The values of every previously named
                property must be ignored. <var>Transformable elements</var> that are
                contained by one of these elements can have three-dimensional transform functions.
                The <a>'clipPath element'</a>, <a>'mask element'</a>,
                <a>'pattern element'</a> elements require the user agent to create a flattened
                representation of the descendant elements before they can be applied, and 
                therefore override the behavior of ''transform-style: preserve-3d''.
              </p>
              
              <p>
                If the 'vector-effect' property is set to ''non-scaling-stroke'' and an object is
                within a <var>3D rendering context</var> the property has no affect on stroking the
                object.
              </p>

              <h3 id="svg-user-coordinate-space">
                User coordinate space
              </h3>

              <p>
                For the <a>'pattern element'</a>, <a>'linearGradient element'</a>,
                <a>'radialGradient element'</a> and <a>'clipPath element'</a>
                elements the 'transform', 'patternTransform', 'gradientTransform' presentation
                attributes represents values in the current user coordinate system in place at the
                time when these elements are referenced (i.e., the user coordinate system for the
                element referencing the 'pattern' element via a 'fill' or 'stroke' property).
                Percentage values are relative to the <var>bounding box</var> of the
                referencing element.
              </p>

              <p>
                In particualar the 'patternUnit', 'gradientUnit' and 'maskUnit' attributes
                don't affect the user coordinate system used for transformations [[SVG11]].
              </p>

              <p>
                For all other <var>transformable elements</var> the
                'transform' presentation attribute represents values in the current user coordinate
                system of the parent. All percentage values of the 'transform' presentation
                attribute are relative to the element's <var>bounding box</var>.
              </p>

              <div class="example">
                <p>
                  The 'transform-origin' property on the pattern in the following example specifies
                  a ''50%'' translation of the origin in the horizontal and vertical dimension. The
                  'transform' property specifies a translation as well, but in absolute lengths.
                </p>

                <pre>&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
    &lt;style&gt;
    pattern {
        transform: rotate(45deg);
        transform-origin: 50% 50%;
    }
    &lt;/style&gt;

    &lt;defs&gt;
    &lt;pattern id="pattern-1"&gt;
        &lt;rect id="rect1" width="100" height="100" fill="blue" /&gt;
    &lt;/pattern&gt;
    &lt;/defs&gt;

    &lt;rect width="200" height="200" fill="url(#pattern-1)" /&gt;
&lt;/svg&gt;</pre>

                <p>
                  An SVG <a>'pattern element'</a> element doesn't have a bounding box. The
                  <var>bounding box</var> of the referencing <a>'rect element'</a> element is used
                  instead to solve the relative values of the 'transform-origin' property. Therefore
                  the point of origin will get translated  by 100 pixels temporarily to rotate the
                  user space of the <a>'pattern element'</a> elements content.
                </p>
              </div>

              <h3 id="transform-attribute-dom">
                SVG DOM interface for the 'transform' attribute
              </h3>

              <p>
                The SVG specification defines the '<a
                href="http://www.w3.org/TR/2011/REC-SVG11-20110816/coords.html#InterfaceSVGAnimatedTransformList">SVGAnimatedTransformList</a>'
                interface in the SVG DOM to provide access to the animated and the base value of the
                SVG 'transform', 'gradientTransform' and 'patternTransform' attributes. To ensure
                backwards compatibility, this API must still be supported by user agents.
              </p>

              <p>
                The 'transform' property contributes to the CSS cascade. According to SVG 1.1 user
                agents conceptually insert a <a
                href="http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes">new author
                style sheet</a> for presentation attributes, which is the first in the author style
                sheet collection. 'baseVal' gives the author the possibility to access and modify
                the values of the SVG 'transform' attribute. To provide the necessary backwards
                compatibility to the SVG DOM, 'baseVal' must reflect the values of this author style
                sheet. All modifications to SVG DOM objects of 'baseVal' must affect this author
                style sheet immediately.
              </p>

              <p>
                'animVal' represents the computed style of the 'transform' property. Therefore it
                includes all applied <a
                href="http://www.w3.org/TR/css3-transitions/">CSS3 Transitions</a>, <a
                href="http://www.w3.org/TR/css3-animations/">CSS3 Animations</a> or <a
                href="#svg-animation">SVG Animations</a> if any of those are underway. The computed
                style and SVG DOM objects of 'animVal' can not be modified.
              </p>

              <p>
                The attribute '<a
                href="http://www.w3.org/TR/SVG/coords.html#__svg__SVGTransform__type">type</a>' of
                '<a 
                href="http://www.w3.org/TR/SVG/coords.html#InterfaceSVGTransform">SVGTransform</a>'
                must return '<a
                href="http://www.w3.org/TR/SVG/coords.html#__svg__SVGTransform__SVG_TRANSFORM_UNKNOWN">SVG_TRANSFORM_UNKNOWN</a>'
                for <a href="#transform-functions">Transform Functions</a>
                or unit types that are not supported by this interface. If a two-dimensional
                transform function is not supported, the attribute '<a
                href="http://www.w3.org/TR/SVG/coords.html#__svg__SVGTransform__matrix">matrix</a>'
                must return a 3x2 '<a
                href="http://www.w3.org/TR/SVG/coords.html#InterfaceSVGMatrix">SVGMatrix</a>' with
                the corresponding values as described in the section <a
                href="#mathematical-description">Mathematical Description of Transform Functions</a>.
              </p>

              <h2 id="svg-animation">
                SVG Animation
              </h2>

              <h3 id="svg-animate-element">
                The <a>'animate element'</a> and <a>'set element'</a> element
              </h3>
              
              <p>
                With this specification, the <a>'animate element'</a> element and the
                <a>'set element'</a> element can animate
                the data type <var>&lt;transform-list&gt;</var>.
              </p>
              
              <p>
                The animation effect is post-multiplied to the underlying value for additive
                <a>'animate element'</a> animations (see below) instead of added to the
                underlying value, due to the specific behavior of <var>&lt;transform-list&gt;</var>
                animations.
              </p>

              <p>
                <var>From-to</var>, <var>from-by</var> and <var>by</var> animations are defined in
                SMIL to be equivalent to a corresponding <var>values</var> animation. However,
                <var>to</var> animations are a mixture of additive and non-additive behavior
                [[SMIL3]].
              </p>
                
              <p>
                <var>To</var> animations on <a>'animate element'</a> provide specific functionality
                to get a smooth change from the underlying value to the 'to' attribute value, which
                conflicts mathematically with the requirement for additive transform animations to be
                post-multiplied. As a consequence, the behavior of <var>to</var> animations for
                <a>'animate element'</a> is undefined. Authors are suggested to use <var>from-to</var>,
                <var>from-by</var>, <var>by</var> or <var>values</var> animations to achieve any
                desired transform animation.
              </p>
              
              <p>
                The value 'paced' is undefined for the attribute 'calcMode' on <a>'animate element'</a>
                for animations of the
                data type <var>&lt;transform-list&gt;</var>. If specified,
                UAs may choose the value 'linear' instead. Future versions of this specification
                may define how paced animations can be performed on
                <var>&lt;transform-list&gt;</var>.
              </p>
              
              <p class="note">Note: The following paragraphs extend <a
                href="http://www.w3.org/TR/SVG/animate.html#complexDistances">Elements, attributes
                and properties that can be animated</a> [[SVG11]].
              </p>
              
              <p>
                The introduce presentation attributes 'transform', 'transform-origin', 'perspective',
                'perspective-origin', 'transform-style' and 'backface-visibility' are animatable.
                'transform-style' and 'backface-visibility' are non-additive.
              </p>

              <p>
                With this specification the SVG basic data type <var>&lt;transform-list&gt;</var> is
                equivalent to a list of <var>&lt;transform-function&gt;</var>s.
                <var>&lt;transform-list&gt;</var> is animatable and additive. The data type can be
                animated using the SVG <a>'animate element'</a> element and
                the SVG <a>'set element'</a>
                element. SVG animations must run the same animation steps as described in section <a
                href="#animation">Transitions and Animations between Transform Values</a>.
              </p>
              
              <p>
                The set of animatable data types gets extended by <em>&lt;translation-value&gt;</em>.
                The new data type is animatable and additive.
              </p>

              <table class="data">
                <caption>Animatable data types</caption>
                <thead>
                  <tr>
                    <th>Data type</th>
                    <th>Additive?</th>
                    <th><a>'animate element'</a></th>
                    <th><a>'set element'</a></th>
                    <th><a>'animateColor element'</a></th>
                    <th><a>'animateTransform'</a></th>
                    <th>Notes</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th><var>&lt;transform-list&gt;</var></th>
                    <td>yes</td>
                    <td>yes</td>
                    <td>yes</td>
                    <td>no</td>
                    <td>yes</td>
                    <td>Additive for <a>'animateTransform element'</a> means that a transformation is post-multiplied to the base set of
                      transformations.</td>
                  </tr>
                  <tr>
                    <th><var>&lt;translation-value&gt;</var></th>
                    <td>yes</td>
                    <td>yes</td>
                    <td>yes</td>
                    <td>no</td>
                    <td>no</td>
                    <td>&nbsp;</td>
                  </tr>
                </tbody>
              </table>
              
              <h3 id="neutral-element">
                Neutral element for addition
              </h3>
              
              <p>
                Some animations require a neutral element for addition. For transform functions
                this is a scalar or a list of scalars of 0. Examples of neutral elements for
                transform functions are ''translate(0)'', ''translate3d(0, 0, 0)'',
                ''translateX(0)'', ''translateY(0)'', ''translateZ(0)'', ''scale(0)'',
                ''scaleX(0)'', ''scaleY(0)'', ''scaleZ(0)'', ''rotate(0)'',
                ''rotate3d(v<sub>x</sub>, v<sub>y</sub>, v<sub>z</sub>, 0)'' (where <var>v</var> is
                a context dependent vector), ''rotateX(0)'', ''rotateY(0)'', ''rotateZ(0)'',
                ''skew(0, 0)'', ''skewX(0)'', ''skewY(0)'', ''matrix(0, 0, 0, 0, 0, 0)'', ''matrix3d(0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'' and ''perspective(0)''.
              </p>
              
              <p class="note">
                Animations to or from the neutral element of additions ''matrix'', ''matrix3d'' and
                ''perspective'' fall back to discrete animations (See <a
                href="#matrix-interpolation">Interpolation of Matrices</a>).
              </p>
              
              <div class="example">
                <p>
                  A <var>by</var> animation with a by value v<sub>b</sub> is equivalent to the same
                  animation with a values list with 2 values, the neutral element for addition for
                  the domain of the target attribute (denoted 0) and v<sub>b</sub>, and
                  ''additive="sum"''. [[SMIL3]]
                </p>

                <pre>
&lt;rect width="100" height="100"&gt;
    &lt;animateTransform attributeName="transform" attributeType="XML"
      type="scale" by="1" dur="5s" fill="freeze"/&gt;
&lt;/rect&gt;</pre>

                <p>
                  The neutral element for addition when performing a <var>by</var> animation with
                  ''type="scale"'' is the value 0. Thus, performing the animation of the example
                  above causes the rectangle to be invisible at time 0s (since the animated
                  transform list value is ''scale(0)''), and be scaled back to its original size at
                  time 5s (since the animated transform list value is ''scale(1)'').
                </p>
  
              </div>

              <h3 id="svg-attribute-name">
                The SVG 'attributeName' attribute
              </h3>

              <p>
                <a href="http://www.w3.org/TR/SVG/animate.html">SVG 1.1 Animation</a> defines the
                '<a href="http://www.w3.org/TR/SVG/animate.html#TargetAttributes">attributeName</a>'
                attribute to specify the name of the target attribute. For the presentation
                attributes 'gradientTransform' and 'patternTransform' it will also be possible to
                use the value 'transform'. The same 'transform' property will get animated.
              </p>

              <div class="example">
                <p>
                  In this example the gradient transformation of the linear gradient gets animated.
                </p>

                <pre>&lt;linearGradient gradientTransform="scale(2)"&gt;
    &lt;animate attributeName="gradientTransform" from="scale(2)" to="scale(4)"
          dur="3s" additive="sum"/&gt;
    &lt;animate attributeName="transform" from="translate(0, 0)" to="translate(100px, 100px)"
          dur="3s" additive="sum"/&gt;
&lt;/linearGradient&gt;</pre>

                <p>The 'linearGradient' element specifies the 'gradientTransform' presentation
                  attribute. The two 'animate' elements address the target attribute
                  'gradientTransform' and 'transform'. Even so all animations apply to the same
                  gradient transformation by taking the value of the 'gradientTransform'
                  presentation attribute, applying the scaling of the first animation and applying
                  the translation of the second animation one after the other.
                </p>
              </div>

              <!-- ======================================================================================================= -->

              <h2 id="transform-functions">
                The Transform Functions
              </h2>
              <p>
                The value of the 'transform' property is a list of
                <var>&lt;transform-functions&gt;</var>. The set of allowed transform functions is
                given below. For <var>&lt;transform-functions&gt;</var> the type
                <var>&lt;translation-value&gt;</var> is defined as a <var>&lt;length&gt;</var> or
                <var>&lt;percentage&gt;</var> value, and the <var>&lt;angle&gt;</var> type is
                defined by <a
                href="http://www.w3.org/TR/css3-values/">CSS Values and Units Module.</a> Wherever
                <var>&lt;angle&gt;</var> is used in this specification, a <var>&lt;number&gt;</var>
                that is equal to zero is also allowed, which is treated the same as an angle of zero
                degrees.
              </p>

              <h3 id="two-d-transform-functions">2D Transform Functions</h3>
              <dl>
                <dt id="matrix-function">
                  <code class="css">matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a 2D transformation in the form of a <a href="#MatrixDefined">transformation matrix</a> of the six values a-f.
                </dd>
                <dt id="translate-function">
                  <code class="css">translate(&lt;translation-value&gt;[, &lt;translation-value&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#TranslateDefined">2D translation</a> by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <em>&lt;ty&gt;</em> is not provided, ty has zero as a value.
                </dd>
                <dt id="translateX-function">
                  <code class="css">translateX(&lt;translation-value&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#TranslateDefined">translation</a> by the given amount in the X direction.
                </dd>
                <dt id="translateY-function">
                  <code class="css">translateY(&lt;translation-value&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#TranslateDefined">translation</a> by the given amount in the Y direction.
                </dd>
                <dt id="scale-function">
                  <code class="css">scale(&lt;number&gt;[, &lt;number&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#ScaleDefined">2D scale</a> operation by the [sx,sy] scaling vector described by the 2 parameters. If the second parameter is not provided, it takes a value equal to the first. For example, scale(1, 1) would leave an element unchanged, while scale(2, 2) would cause it to appear twice as long in both the X
                  and Y axes, or four times its typical geometric size.
                </dd>
                <dt id="scaleX-function">
                  <code class="css">scaleX(&lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#ScaleDefined">2D scale</a> operation using the [sx,1] scaling vector, where sx is given as the parameter.
                </dd>
                <dt id="scaleY-function">
                  <code class="css">scaleY(&lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#ScaleDefined">2D scale</a> operation using the [1,sy] scaling vector, where sy is given as the parameter.
                </dd>
                <dt id="rotate-function">
                  <code class="css">rotate(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#RotateDefined">2D rotation</a> by the angle specified in the parameter about the origin of the element, as
                  defined by the 'transform-origin' property. For example, ''rotate(90deg)''
                  would cause elements to appear rotated one-quarter of a turn in the clockwise direction.
                </dd>
                <dt>
                  <code class="css">skew(&lt;angle&gt;[, &lt;angle&gt;])</code>
                </dt>
                <dd>
                  specifies a <a href="#SkewDefined">2D skew</a> by [ax,ay] for X and Y. If the second parameter is not provided, it has a zero value.
                  <p class="note">Note that the behavior of ''skew'' is different from mutliplying ''skewX'' with ''skewY''. Implementations must support this function for compatibility with legacy content.</p>
                </dd>
                <dt id="skewX-function">
                  <code class="css">skewX(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#SkewXDefined">2D skew transformation along the X axis</a> by the given angle.
                </dd>
                <dt id="skewY-function">
                  <code class="css">skewY(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#SkewYDefined">2D skew transformation along the Y axis</a> by the given angle.
                </dd>
              </dl>


              <h3 id="three-d-transform-functions">3D Transform Functions</h3>
              <dl>
                <dt id="matrix3d-function">
                  <code class="css">matrix3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a 3D transformation as a 4x4 homogeneous matrix of 16 values in column-major order.
                </dd>
                <dt id="translate3d-function">
                  <code class="css">translate3d(&lt;translation-value&gt;, &lt;translation-value&gt;, &lt;length&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [tx,ty,tz], with tx, ty and tz being the first, second and third translation-value parameters respectively.
                </dd>
                <dt id="translateZ-function">
                  <code class="css">translateZ(&lt;length&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [0,0,tz] with the given amount in the Z direction.
                </dd>
                <dt id="scale3d-function">
                  <code class="css">scale3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Scale3dDefined">3D scale</a> operation by the [sx,sy,sz] scaling vector described by the 3 parameters.
                </dd>
                <dt id="scaleZ-function">
                  <code class="css">scaleZ(&lt;number&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Scale3dDefined">3D scale</a> operation using the [1,1,sz] scaling vector, where sz is given as the parameter.
                </dd>
                <dt id="rotate3d-function">
                  <code class="css">rotate3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;angle&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#Rotate3dDefined">3D rotation</a> by the
                  angle specified in last parameter about the [x,y,z] direction
                  vector described by the first three parameters. A direction vector that cannot be normalized,
                  such as [0,0,0], will cause the rotation to not be applied.
                  <p class="note">Note that the rotation is clockwise as one looks from the end of
                  the vector toward the origin.</p>
                </dd>
                <dt id="rotateX-function">
                  <code class="css">rotateX(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  same as <code class="css">rotate3d(1, 0, 0, &lt;angle&gt;)</code>.
                </dd>
                <dt id="rotateY-function">
                  <code class="css">rotateY(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  same as <code class="css">rotate3d(0, 1, 0, &lt;angle&gt;)</code>.
                </dd>
                <dt id="rotateZ-function">
                  <code class="css">rotateZ(&lt;angle&gt;)</code>
                </dt>
                <dd>
                  same as <code class="css">rotate3d(0, 0, 1, &lt;angle&gt;)</code>,
                  which is also the same as <code class="css">rotate(&lt;angle&gt;)</code>.
                </dd>
                <dt id="perspective-function">
                  <code class="css">perspective(&lt;length&gt;)</code>
                </dt>
                <dd>
                  specifies a <a href="#PerspectiveDefined">perspective projection matrix</a>. This matrix scales points in
                  X and Y based on their Z value, scaling points with positive Z values away from the origin, and those with
                  negative Z values towards the origin. Points on the z=0 plane are unchanged. The parameter represents the
                  distance of the z=0 plane from the viewer. Lower values give a more flattened pyramid and therefore a more
                  pronounced perspective effect. For example, a value of 1000px gives a moderate amount of foreshortening
                  and a value of 200px gives an extreme amount. The value for depth must be greater than zero, otherwise the
                  function is invalid.
                </dd>
              </dl>

              <!-- ======================================================================================================= -->

              <h2 id="transform-function-lists">
                The Transform Function Lists
              </h2>

              <p>
                If a list of <var>&lt;transform-functions&gt;</var> is provided, then the net effect is as if each transform function had been specified separately in the order provided. For example,
              </p>

<pre>
&lt;div style="transform:translate(-10px,-20px) scale(2) rotate(45deg) translate(5px,10px)"/&gt;
</pre>

              <p>
                is functionally equivalent to:
              </p>
<pre>
&lt;div style="transform:translate(-10px,-20px)"&gt;
  &lt;div style="transform:scale(2)"&gt;
    &lt;div style="transform:rotate(45deg)"&gt;
      &lt;div style="transform:translate(5px,10px)"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
              <p>
                That is, in the absence of other styling that affects position and dimensions, a
                nested set of transforms is equivalent to a single list of transform functions,
                applied from the outside in. The resulting transform is the matrix multiplication of
                the list of transforms.
              </p>
          
              <p>
                If a transform function causes the <var>current transformation matrix
                (CTM)</var> of an object to be non-invertible, the object and its content do not
                get displayed.
              </p>

              <div class="example">
                <p>
                  The object in the following example gets scaled by 0.
                </p>

                <pre>&lt;style&gt;
.box {
    transform: scale(0);
}
&lt;/style&gt;

&lt;div class="box"&gt;
    Not visible
&lt;/div&gt;</pre>

                <p>
                  The scaling causes a non-invertible CTM for the coordinate space of the div box.
                  Therefore neither the div box, nor the text in it get displayed.
                </p>
              </div>

              <!-- ======================================================================================================= -->

              <h2 id="animation">
                Interpolation of Transforms
              </h2>

              <p>
                When animating or transitioning transforms, the transform function lists must be
                interpolated. For interpolation between one transform <em>from-transform</em> and
                a second transforms <em>to-transform</em>, the rules described below are applied.
              </p>

              <ul>
                <li id="none-none-animation">
                  If both the <em>from-</em> and <em>to-transform</em> are ''none'':
                  <ul>
                    <li>
                      There is no interpolation necessary. The computed value stays ''none''.
                    </li>
                  </ul>
                </li>
                <li id="none-transform-animation">
                  If one of the <em>from-</em> or <em>to-transforms</em> is ''none''.
                  <ul>
                    <li>
                      The value ''none'' is replaced by an equivalent
                      <a href="#TermIdentityTransformFunction"><i>identity transform
                      function</i></a> list for the corresponding transform
                      function list. Both transform function lists get interpolated following the
                      next rule.
                    </li>
                  </ul>
                  <div class="example">
                    <p>
                      For example, if <em>from-transform</em> is ''scale(2)'' and
                      <em>to-transform</em> is ''none'' then the value ''scale(1)'' will be used for
                      <em>to-transform</em> and animation will proceed using the next rule.
                      Similarly, if <em>from-transform</em> is ''none'' and <em>to-transform</em> is
                      ''scale(2) rotate(50deg)'' then the animation will execute as if
                      <em>from-transform</em> is ''scale(1) rotate(0)''.
                    </p>
                  </div>
                </li>
                <li id="transform-transform-animation">
                  If <em>from-</em> and <em>to-transform</em> have the same number of 
                  transform functions, each transform function pair has either the same name, or is
                  a derivative of the same <a href="#transform-primitives">primitive</a>.
                  <ul>
                    <li>
                      Interpolate each transform function pair as described in <a
                      href="#interpolation-of-transform-functions">Interpolation of transform
                      functions</a>. The computed value is the resulting transform function
                      list.
                    </li>
                  </ul>
                  <div class="example">
                    <p>
                      For example, if <em>from-transform</em> is ''scale(1) translate(0)'' and
                      <em>to-transform</em> is ''translate(100px) scale(2)'' then ''scale(1)'' and
                      ''translate(100px)'' as well as ''translate(0)'' and ''scale(2)'' don't share
                      a common primitive and therefore can not get interpolated following this rule.
                    </p>
                  </div>
                </li>
                <li id="other-animation">
                  In all other cases:
                  <ul>
                    <li>
                      The transform functions of each transform function list on the
                      <em>from-</em> and <em>to-transform</em> get post multiplied and
                      converted into 4x4 matrices. Each of the matrices gets interpolated following
                      the instructions in <a href="#matrix-interpolation">Interpolation of
                      matrices</a>. The computed value is the transform function ''matrix'' if both
                      initial matrices can be represented by a correlating 3x2 matrix and
                      ''matrix3d'' otherwise.
                    </li>
                  </ul>
                </li>
              </ul>

              <p>
                In some cases, an animation might cause a transformation matrix to be singular or
                non-invertible. For example, an animation in which scale moves from 1 to -1. At the
                time when the matrix is in such a state, the transformed element is not rendered.
              </p>
              
              <!-- ======================================================================================================= -->

              <h2 id="transform-primitives">
                Transform function primitives and derivatives
              </h2>

              <p>
                Some transform functions can be represented by more generic transform functions.
                These transform functions are called derived transform functions, the generic
                transform functions primitives. Primitives for two-dimensional and
                three-dimensional transform functions are listed below.
              </p>

              <p>
                Two-dimensional primitives with derived transform functions are:
              </p>

              <dl>
                <dt id="translate-primitive">
                  <code class="css">translate(&lt;translation-value&gt;,
                  &lt;translation-value&gt;)</code>
                </dt>
                <dd>
                  for <code class="css">translateX(&lt;translation-value&gt;)</code>,
                  <code class="css">translateY(&lt;translation-value&gt;)</code> and 
                  <code class="css">translate(&lt;translation-value&gt;)</code>.
                </dd>
                <dt id="rotate-three-primitive">
                  <code class="css">rotate(&lt;angle&gt;, &lt;translation-value&gt;,
                  &lt;translation-value&gt;)</code>
                </dt>
                <dd>
                  for <code class="css">rotate(&lt;angle&gt;)</code> if
                  <a href="#svg-transform-functions">rotate with three arguments</a> is supported.
                </dd>
                <dt id="scale-primitive">
                  <code class="css">scale(&lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  for <code class="css">scaleX(&lt;number&gt;)</code>, <code
                  class="css">scaleY(&lt;number&gt;)</code> and <code 
                  class="css">scale(&lt;number&gt;)</code>.
                </dd>
              </dl>

              <p>
                Three-dimensional primitives with derived transform functions are:
              </p>

              <dl>
                <dt id="translate3d-primitive">
                  <code class="css">translate3d(&lt;translation-value&gt;,
                  &lt;translation-value&gt;, &lt;length&gt;)</code>
                </dt>
                <dd>
                  for <code class="css">translateX(&lt;translation-value&gt;)</code>, <code 
                  class="css">translateY(&lt;translation-value&gt;)</code>, <code
                  class="css">translateZ(&lt;number&gt;)</code> and <code 
                  class="css">translate(&lt;translation-value&gt;[,
                  &lt;translation-value&gt;])</code>.
                </dd>
                <dt id="scale3d-primitive">
                  <code class="css">scale3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</code>
                </dt>
                <dd>
                  for <code class="css">scaleX(&lt;number&gt;)</code>, <code
                  class="css">scaleY(&lt;number&gt;)</code>, <code
                  class="css">scaleZ(&lt;number&gt;)</code> and <code
                  class="css">scale(&lt;number&gt;[, &lt;number&gt;])</code>.
                </dd>
                <dt id="rotate3d-primitive">
                  <code class="css">rotate3d(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;angle&gt;)</code>
                </dt>
                <dd>
                  for <code class="css">rotate(&lt;number&gt;)</code>, <code
                  class="css">rotateX(&lt;number&gt;)</code>, <code
                  class="css">rotateY(&lt;number&gt;)</code> and <code
                  class="css">rotateZ(&lt;number&gt;)</code>.
                </dd>
              </dl>

              <p id="interpolation-two-three-dimensional-function">
                For derived transform functions that have a two-dimensional primitive and a
                three-dimensional primitive, the context decides about the used primitive. See
                <a href="#interpolation-of-transform-functions">Interpolation of primitives and
                derived transform functions</a>.
              </p>
              
              <!-- ======================================================================================================= -->

              <h2 id="interpolation-of-transform-functions">
                Interpolation of primitives and derived transform functions
              </h2>
              
              <p>
                Two transform functions with the same name and the same number of arguments are
                interpolated numerically without a former conversion. The calculated value will be
                of the same transform function type with the same number of arguments. Special rules
                apply to ''rotate3d'', ''matrix'', ''matrix3d'' and ''perspective''.
              </p>
              
              <div class="example">
                <p>
                  The two transform functions ''translate(0)'' and ''translate(100px)'' are of the
                  same type, have the same number of arguments and therefore can get interpolated
                  numerically. ''translateX(100px)'' is not of the same type and
                  ''translate(100px, 0)'' does not have the same number of arguments, therefore
                  these transform functions can not get interpolated without a former conversion
                  step.
                </p>
              </div>

              <p>
                Two different types of transform functions that share the same primitive, or
                transform functions of the same type with different number of arguments can be
                interpolated. Both transform functions need a former conversion to the common
                primitive first and get interpolated numerically afterwards. The computed value
                will be the primitive with the resulting interpolated arguments. 
              </p>

              <div class="example">
                <p>
                  The following example describes a transition from ''translateX(100px)'' to
                  ''translateY(100px)'' in 3 seconds on hovering over the div box. Both transform
                  functions derive from the same primitive <code 
                  class="css">translate(&lt;translation-value&gt;, &lt;translation-value&gt;)</code>
                  and therefore can be interpolated.
                </p>

                <pre>div {
    transform: translateX(100px);
}

div:hover {
    transform: translateY(100px);
    transition: transform 3s;
}</pre>

                <p>
                  For the time of the transition both transform functions get transformed to the
                  common primitive. ''translateX(100px)'' gets converted to ''translate(100px, 0)''
                  and ''translateY(100px)'' gets converted to ''translate(0, 100px)''. Both
                  transform functions can then get interpolated numerically.
                </p>
              </div>

              <p>
                If both transform functions share a primitive in the two-dimensional space, both
                transform functions get converted to the two-dimensional primitive. If one or both
                transform functions are three-dimensional transform functions, the common
                three-dimensional primitive is used.
              </p>

              <div class="example">
                <p>
                  In this example a two-dimensional transform function gets animated to a
                  three-dimensional transform function. The common primitive is <code
                  class="css">translate3d</code>.
                </p>

                <pre>div {
    transform: translateX(100px);
}

div:hover {
    transform: translateZ(100px);
    transition: transform 3s;
}</pre>

                <p>
                  First '<code class="css">translateX(100px)</code>' gets converted to '<code
                  class="css">translate3d(100px, 0, 0)</code>' and '<code class="css">translateZ(100px)</code>' to '<code
                  class="css">translate3d(0, 0, 100px)</code>' respectively. Then both converted transform
                  functions get interpolated numerically.
                </p>
              </div>

              <p>
                The transform functions ''matrix'', ''matrix3d'' and ''perspective''
                get converted into 4x4 matrices first and interpolated as defined in section <a
                href="#matrix-interpolation">Interpolation of Matrices</a> afterwards.
              </p>

              <p>
                For interpolations with the primitive ''rotate3d'', the direction vectors of the
                transform functions get normalized first. If the
                normalized vectors are equal, the rotation angle gets interpolated numerically.
                Otherwise the transform functions get converted into 4x4 matrices first and
                interpolated as defined in section <a href="#matrix-interpolation">Interpolation of
                Matrices</a> afterwards.
              </p>

              <!-- ======================================================================================================= -->

              <h2 id="matrix-interpolation">
                Interpolation of Matrices
              </h2>

              <p>
                When interpolating between two matrices, each is decomposed into the corresponding
                translation, rotation, scale, skew and perspective values. Not all matrices can be
                accurately described by these values. Those that can't are decomposed into the most
                accurate representation possible, using the pseudocode in <a
                href="#matrix-decomposing">Decomposing the Matrix</a>. The resulting values get <a
                href="#matrix-values-interpolation">interpolated numerically</a> and <a
                href="#matrix-recomposing">recomposed back to a matrix</a> in a final step.
              </p>

              <div class="note">
                <p>
                  In the following example the element gets translated by 100 pixel in both the X
                  and Y directions and rotated by 1170&deg; on hovering. The initial
                  transformation is 45&deg;. With the usage of transition, an author might expect
                  a animated, clockwise rotation by three and a quarter turns (1170&deg;).
                </p>

                <pre>
&lt;style&gt;
div {
    transform: rotate(45deg);
}
div:hover {
    transform: translate(100px, 100px) rotate(1215deg);
    transition: transform 3s;
}
&lt;/style&gt;

&lt;div&gt;&lt;/div&gt;</pre>

                <p>
                  The number of transform functions on the source transform
                  ''rotate(45deg)'' differs from the number of transform functions on the
                  destination transform ''translate(100px, 100px) rotate(1125deg)''.
                  According to the last rule of <a href="#animation">Interpolation of
                  Transforms</a>, both transforms must be interpolated by matrix interpolation.
                  With converting the transformation functions to matrices, the information about
                  the three turns gets lost and the element gets rotated by just a quarter turn (90&deg;).
                </p>

                <p>
                  To achieve the three and a quarter turns for the example above, source and
                  destination transforms must fulfill the third rule of <a
                  href="#animation">Interpolation of Transforms</a>. Source transform could look
                  like ''translate(0, 0) rotate(45deg)'' for a linear interpolation of 
                  the transform functions.
                </p>
              </div>
              
              <p>
                If one of the matrices for interpolation is non-invertible, the used animation
                function must fallback to a discrete animation according to the rules of the
                respective animation specification.
              </p>

              <h3 id="matrix-decomposing">Decomposing the Matrix</h3>
              
              <p>
                The pseudocode below is based upon the "unmatrix" method in "Graphics Gems II,
                edited by Jim Arvo", but modified to use Quaternions instead of Euler angles to
                avoid the problem of Gimbal Locks.
              </p>
              
              <p>
                The following pseudocode works on a 4x4 homogeneous matrix:
              </p>

              <pre>
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can

Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix):
  double  determinant(matrix)          returns the 4x4 determinant of the matrix
  matrix  inverse(matrix)              returns the inverse of the passed matrix
  matrix  transpose(matrix)            returns the transpose of the passed matrix
  point   multVecMatrix(point, matrix) multiplies the passed point by the passed matrix
                                       and returns the transformed point
  double  length(point)                returns the length of the passed vector
  point   normalize(point)             normalizes the length of the passed point to 1
  double  dot(point, point)            returns the dot product of the passed points
  double  sqrt(double)                 returns the root square of passed value
  double  max(double y, double x)      returns the bigger value of the two passed values

Decomposition also makes use of the following function:
  point combine(point a, point b, double ascl, double bscl)
      result[0] = (ascl * a[0]) + (bscl * b[0])
      result[1] = (ascl * a[1]) + (bscl * b[1])
      result[2] = (ascl * a[2]) + (bscl * b[2])
      return result

// Normalize the matrix.
if (matrix[3][3] == 0)
    return false

for (i = 0; i < 4; i++)
    for (j = 0; j < 4; j++)
        matrix[i][j] /= matrix[3][3]

// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
perspectiveMatrix = matrix

for (i = 0; i < 3; i++)
    perspectiveMatrix[i][3] = 0

perspectiveMatrix[3][3] = 1

if (determinant(perspectiveMatrix) == 0)
    return false

// First, isolate perspective.
if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
    // rightHandSide is the right hand side of the equation.
    rightHandSide[0] = matrix[0][3];
    rightHandSide[1] = matrix[1][3];
    rightHandSide[2] = matrix[2][3];
    rightHandSide[3] = matrix[3][3];

    // Solve the equation by inverting perspectiveMatrix and multiplying
    // rightHandSide by the inverse.
    inversePerspectiveMatrix = inverse(perspectiveMatrix)
    transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
    perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)
else
    // No perspective.
    perspective[0] = perspective[1] = perspective[2] = 0
    perspective[3] = 1

// Next take care of translation
for (i = 0; i < 3; i++)
    translate[i] = matrix[3][i]

// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
for (i = 0; i < 3; i++)
    row[i][0] = matrix[i][0]
    row[i][1] = matrix[i][1]
    row[i][2] = matrix[i][2]

// Compute X scale factor and normalize first row.
scale[0] = length(row[0])
row[0] = normalize(row[0])

// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0] = dot(row[0], row[1])
row[1] = combine(row[1], row[0], 1.0, -skew[0])

// Now, compute Y scale and normalize 2nd row.
scale[1] = length(row[1])
row[1] = normalize(row[1])
skew[0] /= scale[1];

// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1] = dot(row[0], row[2])
row[2] = combine(row[2], row[0], 1.0, -skew[1])
skew[2] = dot(row[1], row[2])
row[2] = combine(row[2], row[1], 1.0, -skew[2])

// Next, get Z scale and normalize 3rd row.
scale[2] = length(row[2])
row[2] = normalize(row[2])
skew[1] /= scale[2]
skew[2] /= scale[2]

// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
pdum3 = cross(row[1], row[2])
if (dot(row[0], pdum3) < 0)
    for (i = 0; i < 3; i++)
        scale[i] *= -1;
        row[i][0] *= -1
        row[i][1] *= -1
        row[i][2] *= -1

// Now, get the rotations out
quaternion[0] = 0.5 * sqrt(max(1 + row[0][0] - row[1][1] - row[2][2], 0))
quaternion[1] = 0.5 * sqrt(max(1 - row[0][0] + row[1][1] - row[2][2], 0))
quaternion[2] = 0.5 * sqrt(max(1 - row[0][0] - row[1][1] + row[2][2], 0))
quaternion[3] = 0.5 * sqrt(max(1 + row[0][0] + row[1][1] + row[2][2], 0))

if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0]
if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1]
if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2]

return true</pre>

              <h3 id="matrix-values-interpolation">
                Interpolation of decomposed matrix values
              </h3>

              <p>
                Each component of the decomposed values translation, scale, skew and perspective of
                the source matrix get linearly interpolated with each corresponding component of the
                destination matrix.
              </p>
              
              <p class="note">
                For instance, <code>translate[0]</code> of the source matrix and
                <code>translate[0]</code> of the destination matrix are interpolated numerically,
                and the result is used to set the translation of the animating element.
              </p>

              <p>
                Quaternions of the decomposed source matrix are interpolated with quaternions of the
                decomposed destination matrix using the spherical linear interpolation (Slerp) as
                described by the pseudocode below: 
              </p>
              
              <pre>
Input:  quaternionA   ; a 4 component vector
        quaternionB   ; a 4 component vector
        t             ; interpolation parameter with 0 <= t <= 1
Output: quaternionDst ; a 4 component vector

Supporting functions (vector is a 4 component vector):
  double  dot(vector, vector)         returns the dot product of the passed vectors
  vector  multVector(vector, vector)  multiplies the passed vectors
  double  sqrt(double)                returns the root square of passed value
  double  max(double y, double x)     returns the bigger value of the two passed values
  double  min(double y, double x)     returns the smaller value of the two passed values
  double  cos(double)                 returns the cosines of passed value
  double  sin(double)                 returns the sine of passed value  
  double  acos(double)                returns the inverse cosine of passed value


product = dot(quaternionA, quaternionB)

// Clamp product to -1.0 <= product <= 1.0
product = max(product, 1.0)
product = min(product, -1.0)

if (product == 1.0)
   quaternionDst = quaternionA
   return

theta = acos(dot)
w = sin(t * theta) * 1 / sqrt(1 - product * product)

for (i = 0; i < 4; i++)
  quaternionA[i] *= cos(t * theta) - product * w
  quaternionB[i] *= w
  quaternionDst[i] = quaternionA[i] + quaternionB[i]

return</pre>
                      
              <h3 id="matrix-recomposing">
                Recomposing the Matrix
              </h3>

              <p>
                After interpolation the resulting values are used to transform the elements user
                space. One way to use these values is to recompose them into a 4x4 matrix. This can
                be done following the pseudocode below:
              </p>

              <pre>
Input:  translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

Supporting functions (matrix is a 4x4 matrix):
  matrix  multiply(matrix a, matrix b)   returns the 4x4 matrix product of a * b  

// apply perspective
for (i = 0; i < 4; i++)
  matrix[i][3] = perspective[i]

// apply translation
for (i = 0; i < 3; i++)
  for (j = 0; j < 3; j++)
    matrix[3][i] += translation[j] * matrix[j][i]

// apply rotation
x = quaternion[0]
y = quaternion[1]
z = quaternion[2]
w = quaternion[3]

// Construct a composite rotation matrix from the quaternion values
// rotationMatrix is a identity 4x4 matrix initially
rotationMatrix[0][0] = 1 - 2 * (y * y + z * z)
rotationMatrix[0][1] = 2 * (x * y - z * w)
rotationMatrix[0][2] = 2 * (x * z + y * w)
rotationMatrix[1][0] = 2 * (x * y + z * w)
rotationMatrix[1][1] = 1 - 2 * (x * x + z * z)
rotationMatrix[1][2] = 2 * (y * z - x * w)
rotationMatrix[2][0] = 2 * (x * z - y * w)
rotationMatrix[2][1] = 2 * (y * z + x * w)
rotationMatrix[2][2] = 1 - 2 * (x * x + y * y)

matrix = multiply(matrix, rotationMatrix)

// apply skew
// temp is a identity 4x4 matrix initially
if (skew[2])
    temp[2][1] = skew[2]
    matrix = multiply(matrix, temp)

if (skew[1])
    temp[2][1] = 0
    temp[2][0] = skew[1]
    matrix = multiply(matrix, temp)

if (skew[0])
    temp[2][0] = 0
    temp[1][0] = skew[0]
    matrix = multiply(matrix, temp)

// apply scale
for (i = 0; i < 3; i++)
  for (j = 0; j < 3; j++)
    matrix[i][j] *= scale[i]

return</pre>

              <h2 id="mathematical-description">
                Mathematical Description of Transform Functions
              </h2>

              <p>
                Mathematically, all transform functions can be represented as 4x4 transformation matrices of the following form:
              </p>
              <p>
              <img src="4x4matrix.png" alt="\begin{bmatrix} m11 & m21 & m31 & m41 \\ m12 & m22 & m32 & m42 \\ m13 & m23 & m33 & m43 \\ m14 & m24 & m34 & m44 \end{bmatrix}" width="222" height="106">
              <p>
                One translation unit on a matrix is equivalent to 1 pixel in the local coordinate system of the element.
              </p>

              <ul>
                <li id="MatrixDefined">
                  <p>
                    A 2D 3x2 matrix with six parameters <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em> and <em>f</em> is equivalent to the matrix:
                  </p>
                  <img src="matrix.png" alt="\begin{bmatrix} a & c & 0 & e \\ b & d & 0 & f \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="108" height="106">
                </li>
                <li id="TranslateDefined">
                  <p>
                    A 2D translation with the parameters <em>tx</em> and <em>ty</em> is equivalent to a <a href="#Translate3dDefined">3D translation</a> where <em>tz</em> has zero as a value.
                  </p>
                </li>
                <li id="ScaleDefined">
                  <p>
                    A 2D scaling with the parameters <em>sx</em> and <em>sy</em> is equivalent to a <a href="#Scale3dDefined">3D scale</a> where <em>sz</em> has one as a value.
                  </p>
                </li>
                <li id="RotateDefined">
                  <p>
                    A 2D rotation with the parameter <em>alpha</em> is
                    equivalent to a <a href="#Rotate3dDefined">3D rotation</a>
                    with vector [0,0,1] and parameter <em>alpha</em>.
                  </p>
                </li>
                <li id="SkewDefined">
                  <p>
                    A 2D skew like transformation with the parameters <em>alpha</em> and <em>beta</em> is equivalent to the matrix:
                  </p>
                  <img src="skew.png" alt="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="205" height="106">
                </li>
                <li id="SkewXDefined">
                  <p>
                    A 2D skew transformation along the X axis with the parameter <em>alpha</em> is equivalent to the matrix:
                  </p>
                  <img src="skewX.png" alt="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="155" height="106">
                </li>
                <li id="SkewYDefined">
                  <p>
                    A 2D skew transformation along the Y axis with the parameter <em>beta</em> is equivalent to the matrix:
                  </p>
                  <img src="skewY.png" alt="\begin{bmatrix} 1 & 0 & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="155" height="106">
                </li>
                <li id="Translate3dDefined">
                  <p>
                    A 3D translation with the parameters <em>tx</em>, <em>ty</em> and <em>tz</em> is equivalent to the matrix:
                  </p>
                  <img src="translate3d.png" alt="\begin{bmatrix} 1 & 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & tz \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="114" height="106">
                </li>
                <li id="Scale3dDefined">
                  <p>
                    A 3D scaling with the parameters <em>sx</em>, <em>sy</em> and <em>sz</em> is equivalent to the matrix:
                  </p>
                  <img src="scale3d.png" alt="\begin{bmatrix} sx & 0 & 0 & 0 \\ 0 & sy & 0 & 0 \\ 0 & 0 & sz & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="137" height="106">
                </li>
                <li id="Rotate3dDefined">
                  <p>
                    A 3D rotation with the vector [x,y,z] and the parameter <em>alpha</em> is equivalent to the matrix:
                  </p>
                  <img src="rotate3dmatrix.png" alt="\begin{bmatrix} 1 - 2 \cdot (y^2 + z^2) \cdot sq & 2 \cdot (x \cdot y \cdot sq - z \cdot sc) & 2 \cdot (x \cdot z \cdot sq + y \cdot sc) & 0 \\ 2 \cdot (x \cdot y \cdot sq + z \cdot sc) & 1 - 2 \cdot (x^2 + z^2) \cdot sq & 2 \cdot (y \cdot z \cdot sq - x \cdot sc) & 0 \\ 2 \cdot (x \cdot z \cdot sq - y \cdot sc) & 2 \cdot (y \cdot z \cdot sq + x \cdot sc) & 1 - 2 \cdot (x^2 + y^2) \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="647" height="106">
                  <p>
                    where:
                  </p>
                  <img src="rotate3dvariables.png" alt="\newline sc = \sin (\alpha/2) \cdot \cos (\alpha/2) \newline sq = \sin^2 (\alpha/2)" width="221" height="50">
                </li>
                <li id="PerspectiveDefined">
                  <p>
                    A perspective projection matrix with the parameter <em>d</em> is equivalent to the matrix:
                  </p>
                  <img src="perspective.png" alt="\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/d & 1 \end{bmatrix}" width="143" height="106">
                </li>
              </ul>

        <h2>Conformance</h2>
        <!--conformance-->

        <h2>References</h2>

        <h3 class="no-num">Normative references</h3>
        <!--normative-->

        <h3 class="no-num">Other references</h3>
        <!--informative-->



        <h2 class="no-num">Property index</h2>
        <!-- properties -->



        <h2 class="no-num" id="index">Index</h2>
        <!--index-->

  </body>
</html>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-declaration:"~/SGML/HTML4.decl"
sgml-default-doctype-name:"html"
sgml-minimize-attributes:t
sgml-nofill-elements:("pre" "style" "br")
sgml-live-element-indicator:t
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-always-quote-attributes:t
sgml-indent-step:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

