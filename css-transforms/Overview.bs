<h1>CSS Transforms Module Level 1</h1>
<pre class='metadata'>
Status: ED
Work Status: Refining
ED: https://drafts.csswg.org/css-transforms/
TR: https://www.w3.org/TR/css3-transforms/
Previous Version: https://www.w3.org/TR/2012/WD-css3-transforms-20120911/
Previous Version: https://www.w3.org/TR/2012/WD-css3-transforms-20120403/
Shortname: css-transforms
Link Defaults: svg (property) to/stroke/fill, css-masking-1 (property) clip/clip-path, filters-1 (property) filter, css-backgrounds-3 (value) fixed, html (element) a
Level: 1
Group: fxtf
Editor: Simon Fraser, Apple Inc http://www.apple.com/, simon.fraser@apple.com
Editor: Dean Jackson, Apple Inc http://www.apple.com/, dino@apple.com
Editor: Theresa O'Connor, Apple Inc http://www.apple.com/, eoconnor@apple.com
Editor: Dirk Schulze, Adobe Systems Inc http://www.adobe.com/, dschulze@adobe.com
Former Editor: David Hyatt, Apple Inc http://www.apple.com/, hyatt@apple.com
Former Editor: Chris Marrin, Apple Inc http://www.apple.com/, cmarrin@apple.com
Former Editor: Aryeh Gregor, Mozilla http://www.mozilla.org/, ayg@aryeh.name
Abstract: CSS transforms allows elements styled with CSS to be transformed in two-dimensional or three-dimensional space. This specification is the convergence of the <a href="https://www.w3.org/TR/css3-2d-transforms/">CSS 2D transforms</a>, <a href="https://www.w3.org/TR/css3-3d-transforms/">CSS 3D transforms</a> and <a href="https://www.w3.org/TR/2009/WD-SVG-Transforms-20090320/">SVG transforms</a> specifications.
!Issues List: <a href="https://www.w3.org/Bugs/Public/buglist.cgi?query_format=advanced&product=CSS&component=Transforms&resolution=---&cmdtype=doit">in Bugzilla</a>
</pre>

<style type="text/css">
.example {
  clear:both
}

th {
  text-align:left
}

.pseudo-code {
  font-family:monospace
}
.pseudo-code > ol {
  list-style-type:decimal
}
.pseudo-code > ol > li > ol {
  list-style-type:lower-latin
}
.pseudo-code > ol > li > ol > li > ol {
  list-style-type:lower-roman
}
.pseudo-code ul {
  list-style-type:disc
}

dd > p:nth-child(1) {
  margin-top:0
}
</style>

<h2 id="intro">Introduction</h2>

<em>This section is not normative.</em>

The CSS <a href="https://www.w3.org/TR/REC-CSS2/visuren.html">visual formatting model</a> describes a coordinate system within each element is positioned. Positions and sizes in this coordinate space can be thought of as being expressed in pixels, starting in the origin of point with positive values proceeding to the right and down.

This coordinate space can be modified with the 'transform' property. Using transform, elements can be translated, rotated and scaled in two or three dimensional space.

Additional properties make working with transforms easier, and allow the author to control how nested three-dimensional transforms interact.

<ul>
  <li>
    The 'transform-origin' property provides a convenient way to control the origin about which transforms on an element are applied.

  <li>
    The 'perspective' property allows the author to make child elements with three-dimensional transforms appear as if they live in a common three-dimensional space. The 'perspective-origin' property provides control over the origin at which perspective is applied, effectively changing the location of the "vanishing point".

  <li>
    The 'transform-style' property allows 3D-transformed elements and their 3D-transformed descendants to share a common three-dimensional space, allowing the construction of hierarchies of three-dimensional objects.

  <li>
     The 'backface-visibility' property comes into play when an element is flipped around via three-dimensional transforms such that its reverse side is visible to the viewer. In some situations it is desirable to hide the element in this situation, which is possible using the value of ''backface-visibility/hidden'' for this property.

</ul>

Note: While some values of the 'transform' property allow an element to be transformed in a three-dimensional coordinate system, the elements themselves are not three-dimensional objects. Instead, they exist on a two-dimensional plane (a flat surface) and have no depth.

<h2 id="module-interactions">Module Interactions</h2>

This module defines a set of CSS properties that affect the visual rendering of elements to which those properties are applied; these effects are applied after elements have been sized and positioned according to the <a href="https://www.w3.org/TR/CSS2/visuren.html">Visual formatting model</a> from [[!CSS21]]. Some values of these properties result in the creation of a <a href="https://www.w3.org/TR/CSS2/visuren.html#containing-block">containing block</a>, and/or the creation of a <a spec="css21">stacking context</a>.

Three-dimensional transforms can also affect the visual layering of elements, and thus override the back-to-front painting order described in <a href="https://www.w3.org/TR/CSS2/zindex.html">Appendix E</a> of [[!CSS21]].

Transforms affect the rendering of backgrounds on elements with a value of ''fixed'' for the 'background-attachment' property, which is specified in [[!CSS3BG]].

Transforms affect the client rectangles returned by the Element Interface Extensions <a href="https://www.w3.org/TR/cssom-view/#dom-element-getclientrects">getClientRects()</a> and <a href="https://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect">getBoundingClientRect()</a>, which are specified in [[CSSOM-VIEW]].

<h2 id="css-values">CSS Values</h2>

This specification follows the <a href="https://www.w3.org/TR/CSS21/about.html#property-defs">CSS property definition conventions</a> from [[!CSS21]]. Value types not defined in these specifications are defined in CSS Values and Units Module Level 3 [[!CSS3VAL]].

In addition to the property-specific values listed in their definitions, all properties defined in this specification also accept the <a href="https://www.w3.org/TR/CSS21/cascade.html#value-def-inherit">inherit</a> keyword as their property value. For readability it has not been repeated explicitly.

<!--
 /$$$$$$$$
|__  $$__/
   | $$  /$$$$$$   /$$$$$$  /$$$$$$/$$$$   /$$$$$$$
   | $$ /$$__  $$ /$$__  $$| $$_  $$_  $$ /$$_____/
   | $$| $$$$$$$$| $$  \__/| $$ \ $$ \ $$|  $$$$$$
   | $$| $$_____/| $$      | $$ | $$ | $$ \____  $$
   | $$|  $$$$$$$| $$      | $$ | $$ | $$ /$$$$$$$/
   |__/ \_______/|__/      |__/ |__/ |__/|_______/
-->

<h2 id="terminology">Terminology</h2>

When used in this specification, terms have the meanings assigned in this section.

<dl>
  <dt><dfn>transformable element</dfn>
  <dd>
    A transformable element is an element in one of these categories:
    <ul>
      <li>
        an element whose layout is governed by the CSS box model which is either a <a href="https://www.w3.org/TR/CSS2/visuren.html#block-level">block-level</a> or <a href="https://www.w3.org/TR/CSS2/visuren.html#x13">atomic inline-level element</a>, or whose 'display' property computes to ''table-row'', ''table-row-group'', ''table-header-group'', ''table-footer-group'', ''table-cell'', or ''table-caption'' [[!CSS21]]

      <li>
        an element in the SVG namespace and not governed by the CSS box model which has the attributes 'transform', <{pattern/patternTransform}> or <{linearGradient/gradientTransform}> [[!SVG11]].

    </ul>


  <dt><dfn>transformed element</dfn>
  <dd>
    An element with a computed value other than ''transform/none'' for the 'transform' property.


  <dt><dfn>3D-transformed element</dfn>
  <dd>
    An element whose computed value for the 'transform' property includes one of the <a href="#three-d-transform-functions">3D transform functions</a>


  <dt><dfn export>user coordinate system</dfn>
  <dt><dfn export>local coordinate system</dfn>
  <dd>
    <p>In general, a coordinate system defines locations and distances on the current canvas. The current local coordinate system (also user coordinate system) is the coordinate system that is currently active and which is used to define how coordinates and lengths are located and computed, respectively, on the current canvas.
    <p>The current user coordinate system has its origin at the top-left of a <a>reference box</a> specified by the 'transform-box' property. Percentage values are relative to the dimension of this reference box. One unit equals one CSS pixel.


  <dt><dfn>perspective matrix</dfn>
  <dd>
    A matrix computed from the values of the 'perspective' and 'perspective-origin' properties as described <a href="#perspective-matrix-computation">below</a>.

  <dt><dfn>transformation matrix</dfn>
  <dd>
    A matrix that defines the mathematical mapping from one coordinate system into another. It is computed from the values of the 'transform' and 'transform-origin' properties as described <a href="#transformation-matrix-computation">below</a>.

  <dt><dfn>current transformation matrix (CTM)</dfn>
  <dd>
    A matrix that defines the mapping from the local coordinate system into the viewport coordinate system.

  <dt><dfn>accumulated 3D transformation matrix</dfn>
  <dd>
    A matrix computed for an element relative to the root of its <a>3D rendering context</a>, as described <a href="#accumulated-3d-transformation-matrix-computation">below</a>.

  <dt><dfn>2D matrix</dfn>
  <dd>
    A 3x2 transformation matrix with 6 items or a 4x4 matrix with 16 items, where the items m<sub>31</sub>, m<sub>32</sub>, m<sub>13</sub>, m<sub>23</sub>, m<sub>43</sub>, m<sub>14</sub>, m<sub>24</sub>, m<sub>34</sub> are equal to ''0'' and m<sub>33</sub>, m<sub>44</sub> are equal to ''1''.

  <dt><dfn>3D matrix</dfn>
  <dd>
    A 4x4 matrix which does not fulfill the requirements of an <a>2D matrix</a>.

  <dt><dfn>identity transform function</dfn>
  <dd>
    A <a href="#transform-functions">transform function</a> that is equivalent to a identity 4x4 matrix (see <a href="#mathematical-description">Mathematical Description of Transform Functions</a>). Examples for identity transform functions are ''translate(0)'', ''translate3d(0, 0, 0)'', ''translateX(0)'', ''translateY(0)'', ''translateZ(0)'', ''scale(1)'', ''scaleX(1)'', ''scaleY(1)'', ''scaleZ(1)'', ''rotate(0)'', ''rotate3d(1, 1, 1, 0)'', ''rotateX(0)'', ''rotateY(0)'', ''rotateZ(0)'', ''skew(0, 0)'', ''skewX(0)'', ''skewY(0)'', ''matrix(1, 0, 0, 1, 0, 0)'' and ''matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)''. A special case is perspective: ''perspective(infinity)''. The value of m<sub>34</sub> becomes infinitesimal small and the transform function is therefore assumed to be equal to the identity matrix.


  <dt><dfn>3D rendering context</dfn>
  <dd>
    A set of elements with a common ancestor which share a common three-dimensional coordinate system, as described <a href="#3d-rendering-contexts">below</a>.

</dl>

<!--
  /$$$$$$  /$$$$$$$           /$$$$$$            /$$
 /$$__  $$| $$__  $$         /$$__  $$          | $$
|__/  \ $$| $$  \ $$        | $$  \__/ /$$   /$$| $$$$$$$
  /$$$$$$/| $$  | $$ /$$$$$$|  $$$$$$ | $$  | $$| $$__  $$
 /$$____/ | $$  | $$|______/ \____  $$| $$  | $$| $$  \ $$
| $$      | $$  | $$         /$$  \ $$| $$  | $$| $$  | $$
| $$$$$$$$| $$$$$$$/        |  $$$$$$/|  $$$$$$/| $$$$$$$/
|________/|_______/          \______/  \______/ |_______/
-->

<h2 id="two-dimensional-subset">Two Dimensional Subset</h2>

UAs may not always be able to render three-dimensional transforms and then just support a two-dimensional subset of this specification. In this case <a href="#three-d-transform-functions">three-dimensional transforms</a> and the properties 'transform-style', 'perspective', 'perspective-origin' and 'backface-visibility' must not be supported. Section <a href="#3d-transform-rendering">3D Transform Rendering</a> does not apply. Matrix decomposing uses the technique taken from the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", simplified for the 2D case. Section <a href="#mathematical-description">Mathematical Description of Transform Functions</a> is still effective but can be reduced by using a 3x3 transformation matrix where <em>a</em> equals m<sub>11</sub>, <em>b</em> equals m<sub>12</sub>, <em>c</em> equals m<sub>21</sub>, <em>d</em> equals m<sub>22</sub>, <em>e</em> equals m<sub>41</sub> and <em>f</em> equals m<sub>42</sub> (see <a href="#MatrixDefined">A 2D 3x2 matrix with six parameter</a>).

<div class="figure">
  <img src="images/3x3matrix.png" alt="3x3 matrix" title="\begin{bmatrix} a & c & e \\ b
  & d & f \\ 0 & 0 & 1 \end{bmatrix}" width="82" height="79">
   <p class="caption">
     3x3 matrix for two-dimensional transformations.

</div>

<div class="example">

Authors can easily provide a fallback if UAs do not provide support for three-dimensional transforms. The following example has two property definitions for 'transform'. The first one consists of two two-dimensional transform functions. The second one has a two-dimensional and a three-dimensional transform function.

  <pre>div {
  transform: scale(2) rotate(45deg);
  transform: scale(2) rotate3d(0, 0, 1, 45deg);
}</pre>

    With 3D support, the second definition will override the first one. Without 3D support, the second definition is invalid and a UA falls back to the first definition.

</div>

<!--
 /$$$$$$$                            /$$
| $$__  $$                          | $$
| $$  \ $$  /$$$$$$  /$$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$
| $$$$$$$/ /$$__  $$| $$__  $$ /$$__  $$ /$$__  $$ /$$__  $$
| $$__  $$| $$$$$$$$| $$  \ $$| $$  | $$| $$$$$$$$| $$  \__/
| $$  \ $$| $$_____/| $$  | $$| $$  | $$| $$_____/| $$
| $$  | $$|  $$$$$$$| $$  | $$|  $$$$$$$|  $$$$$$$| $$
|__/  |__/ \_______/|__/  |__/ \_______/ \_______/|__/
-->

<h2 id="transform-rendering">The Transform Rendering Model</h2>

<em>This section is normative.</em>

Specifying a value other than ''transform/none'' for the 'transform' property establishes a new <a>local coordinate system</a> at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element's <a>transformation matrix</a>. Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent. From the perspective of the user, an element effectively accumulates all the 'transform' properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a <a>current transformation matrix (CTM)</a> for the element.

The coordinate space is a coordinate system with two axes: the X axis increases horizontally to the right; the Y axis increases vertically downwards. Three-dimensional transformrm functions extend this coordinate space into three dimensions, adding a Z axis perpendicular to the plane of the screen, that increases towards the viewer.

<div class="figure">
  <img src="images/coordinates.svg" width="270" height="240" alt="Demonstration of the initial coordinate space">
  <p class="caption">
     Demonstration of the initial coordinate space.

</div>

<p id="transformation-matrix-computation">
  The <a>transformation matrix</a> is computed from the 'transform' and 'transform-origin' properties as follows:
  <ol>
    <li>Start with the identity matrix.
    <li>Translate by the computed X, Y and Z values of 'transform-origin'
    <li>Multiply by each of the transform functions in 'transform' property from left to right
    <li>Translate by the negated computed X, Y and Z values of 'transform-origin'
  </ol>


Transforms apply to <a>transformable elements</a>.

Note: Transformations do affect the visual rendering, but have no affect on the CSS layout other than affecting overflow. Transforms are also taken into account when computing client rectangles exposed via the Element Interface Extensions, namely <a href="https://www.w3.org/TR/cssom-view/#dom-element-getclientrects">getClientRects()</a> and <a href="https://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect">getBoundingClientRect()</a>, which are specified in [[CSSOM-VIEW]].

<div class="example">
  <pre>
div {
    transform: translate(100px, 100px);
}</pre>
  <p>
    This transform moves the element by 100 pixels in both the X and Y directions.

  <div class="figure">
    <img src="examples/translate1.svg" alt="The 100px translation in X and Y"
    width="470" height="250">
  </div>
</div>

<div class="example">
  <pre>
  div {
    height: 100px; width: 100px;
    transform-origin: 50px 50px;
    transform: rotate(45deg);
  }
  </pre>

The 'transform-origin' property moves the point of origin by 50 pixels in both the X and Y directions. The transform rotates the element clockwise by 45&deg; about the point of origin. After all transform functions were applied, the translation of the origin gets translated back by -50 pixels in both the X and Y directions.

  <div class="figure">
    <img alt="The point of origin gets translated temporary" src="examples/origin1.svg" width="735" height="250">
  </div>
</div>

<div class="example">
  <pre>
  div {
    height: 100px; width: 100px;
    transform: translate(80px, 80px) scale(1.5, 1.5) rotate(45deg);
  }
  </pre>

This transform moves the element by 80 pixels in both the X and Y directions, then scales the element by 150%, then rotates it 45&deg; clockwise about the Z axis. Note that the scale and rotation operate about the center of the element, since the element has the default transform-origin of ''50% 50%''.

  <div class="figure">
    <img src="examples/compound_transform.svg" alt="The transform specified above"
      width="270" height="270">
  </div>

Note that an identical rendering can be obtained by nesting elements with the equivalent transforms:

  <pre>
  &lt;div style="transform: translate(80px, 80px)">
      &lt;div style="transform: scale(1.5, 1.5)">
          &lt;div style="transform: rotate(45deg)">&lt;/div>
      &lt;/div>
  &lt;/div>
  </pre>
</div>

For elements whose layout is governed by the CSS box model, the transform property does not affect the flow of the content surrounding the transformed element. However, the extent of the overflow area takes into account transformed elements. This behavior is similar to what happens when elements are offset via relative positioning. Therefore, if the value of the 'overflow' property is ''overflow/scroll'' or ''overflow/auto'', scrollbars will appear as needed to see content that is transformed outside the visible area.

For elements whose layout is governed by the CSS box model, any value other than ''transform/none'' for the transform results in the creation of both a stacking context and a containing block. The object acts as a containing block for fixed positioned descendants.

Issue: Is this effect on ''position: fixed'' necessary? If so, need to go into more detail here about why fixed positioned objects should do this, i.e., that it's much harder to implement otherwise. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=16328">Bug 16328</a>.

<a href="https://www.w3.org/TR/css3-background/#fixed0">Fixed backgrounds</a> on the root element are affected by any transform specified for that element. For all other elements that are effected by a transform (i.e. have a transform applied to them, or to any of their ancestor elements), a value of ''fixed'' for the 'background-attachment' property is treated as if it had a value of ''background-attachment/scroll''. The computed value of 'background-attachment' is not affected.

Note: If the root element is transformed, the transformation applies to the entire canvas, including any background specified for the root element.  Since <a href="https://www.w3.org/TR/css3-background/#special-backgrounds">the background painting area for the root element</a> is the entire canvas, which is infinite, the transformation might cause parts of the background that were originally off-screen to appear. For example, if the root element's background were repeating dots, and a transformation of ''scale(0.5)'' were specified on the root element, the dots would shrink to half their size, but there will be twice as many, so they still cover the whole viewport.

<h3 id="3d-transform-rendering">3D Transform Rendering</h3>

Normally, elements render as flat planes, and are rendered into the same plane as their containing block. Often this is the plane shared by the rest of the page. Two-dimensional transform functions can alter the appearance of an element, but that element is still rendered into the same plane as its containing block.

Three-dimensional transforms can result in transformation matrices with a non-zero Z component (where the Z axis projects out of the plane of the screen). This can result in an element rendering on a different plane than that of its containing block. This may affect the front-to-back rendering order of that element relative to other elements, as well as causing it to intersect with other elements.

<div class="example">

This example shows the effect of three-dimensional transform applied to an element.

  <pre>
  &lt;style>
  div {
      height: 150px;
      width: 150px;
  }
  .container {
      border: 1px solid black;
  }
  .transformed {
      transform: rotateY(50deg);
  }
  &lt;/style>

  &lt;div class="container">
      &lt;div class="transformed">&lt;/div>
  &lt;/div>
  </pre>
  <div class="figure">
    <img src="examples/simple-3d-example.png" width="210" height="190" alt="Div with a rotateY transform.">
  </div>

The transform is a 50&deg; rotation about the vertical, Y axis. Note how this makes the blue box appear narrower, but not three-dimensional.
</div>


<h4 id="perspective">Perspective</h4>

The 'perspective' and 'perspective-origin' properties can be used to add a feeling of depth to a scene by making elements higher on the Z axis (closer to the viewer) appear larger, and those further away to appear smaller. The scaling is proportional to <var>d</var>/(<var>d</var> &minus; <var>Z</var>) where <var>d</var>, the value of 'perspective', is the distance from the drawing plane to the the assumed position of the viewer's eye.

<div class="figure">
  <img alt="Diagram of scale vs. Z position" src="images/perspective_distance.png">
  <p class="caption">
    Diagrams showing how scaling depends on the 'perspective' property and Z position. In the top diagram, <var>Z</var> is half of <var>d</var>. In order to make it appear that the original circle (solid outline) appears at <var>Z</var> (dashed circle), the circle is scaled up by a factor of two, resulting in the light blue circle. In the bottom diagram, the circle is scaled down by a factor of one-third to make it appear behind the original position.

</div>

Normally the assumed position of the viewer's eye is centered on a drawing. This position can be moved if desired &ndash; for example, if a web page contains multiple drawings that should share a common perspective &ndash; by setting 'perspective-origin'.

<div class="figure">
  <img alt="Diagram of different perspective-origin" src="images/perspective_origin.png">
  <p class="caption">
    Diagram showing the effect of moving the perspective origin upward.

</div>

<p id="perspective-matrix-computation">
  The <a>perspective matrix</a> is computed as follows:
  <ol>
    <li>Start with the identity matrix.
    <li>Translate by the computed X and Y values of 'perspective-origin'
    <li>Multiply by the matrix that would be obtained from the ''perspective()'' transform function, where the length is provided by the value of the 'perspective' property
    <li>Translate by the negated computed X and Y values of 'perspective-origin'
  </ol>


<div class="example">

This example shows how perspective can be used to cause three-dimensional transforms to appear more realistic.

  <pre>
  &lt;style>
  div {
    height: 150px;
    width: 150px;
  }
  .container {
    perspective: 500px;
    border: 1px solid black;
  }
  .transformed {
    transform: rotateY(50deg);
  }
  &lt;/style>

  &lt;div class="container">
    &lt;div class="transformed">&lt;/div>
  &lt;/div>
  </pre>

  <div class="figure">
      <img src="examples/simple-perspective-example.png" width="210" height="190" alt="Div with a rotateY transform, and perspective on its container">
  </div>

The inner element has the same transform as in the previous example, but its rendering is now influenced by the perspective property on its parent element. Perspective causes vertices that have positive Z coordinates (closer to the viewer) to be scaled up in X and Y, and those further away (negative Z coordinates) to be scaled down, giving an appearance of depth.
</div>

<h4 id="3d-rendering-contexts">3D Rendering Contexts</h4>

This section specifies the rendering model for content that uses 3D-transforms and the ''transform-style'' property. In order to describe this model, we introduce the concept of a "3D rendering context".

A <a>3D rendering context</a> is a set of elements rooted in a common ancestor that, for the purposes of 3D-transform rendering, are considered to share a common three-dimensional coordinate system. The front-to-back rendering of elements in the a 3D rendering context depends on their z-position in that three-dimensional space, and, if the 3D transforms on those elements cause them to intersect, then they are rendered with intersection.

A 3D rendering context is established by an element which has a used value for transform-style of "flat". Descendant elements with a used value for transform-style of "auto" or "preserve-3d" share their enclosing 3D rendering context. A descendant with a used value for transform-style of "flat" participates in its containing 3D rendering context, but establishes a new 3D rendering context for its descendants. For the purposes of rendering in its containing 3D rendering context, it behaves like a flat plane.

Note: This is conceptually similar to CSS stacking contexts. A positioned element with explicit z-index establishes a stacking context, while participating in the stacking context of an ancestor.  Similarly, an element can establish a 3D rendering context for its descendants, while participating in the 3D rendering context of an ancestor. Just as elements within a stacking context render in z-index order, elements in a 3D-rendering context render in z-depth order and can intersect.

Some CSS properties have values that are considered to force "grouping": they require that their element and its descendants are rendered as a group before being composited with other elements; these include opacity, filters and properties that affect clipping. The relevant property values are listed under <a href="#grouping-property-values">grouping property values</a>. These grouping property values force the used value for transform-style to be "flat", and such elements are referred to as <dfn>flattening elements</dfn>. Consequently, they always establish a new 3D rendering context. The root element always has a used value of "flat" for transform-style.

The rendering of elements in a 3D rendering context is as follows (numbers refer to items in <a href="https://www.w3.org/TR/CSS2/zindex.html#painting-order">CSS 2.1, Appendix E, Section E.2 Painting Order</a>):

<ol style="list-style-type: upper-alpha;">
  <li>The background, borders and other box decorations of the establishing element are rendered (steps 1 and 2)
  <li>The content and descendant elements without 3D transforms, ordered according to steps 3â€”7, are rendered into a plane at z=0 relative to to the establishing element.
  <li>3D-transformed elements are each rendered into their own plane, transformed by the <a href="#accumulated-3d-transformation-matrix-computation">accumulated 3D transformation matrix</a>.
  <li>Intersection is performed between the set of planes generated by steps B and C, according to <a href="http://en.wikipedia.org/wiki/Newell%27s_algorithm">Newell's algorithm</a>.
  <li>The resulting set of planes is rendered on top of the backgrounds and box decorations rendered in this step A. Coplanar 3D transformed elements are rendered in painting order.
</ol>

Issue: is it OK to not pop 2D-transformed elements into their own planes?

Issue: requiring intersection with non-transformed content and descendants requires UAs to allocate additional textures (possibly doubling memory use). Would be more efficient to simply render content and untransformed descendants along with background and borders.

Note that elements with transforms which have a negative z-component will render behind the content and untransformed descendants of the establishing element, and that 3D transformed elements may interpenetrate with content and untransformed elements.

Note: Because the 3D-transformed elements in a 3D rendering context can all depth-sort and intersect with each other, they are effectively rendered as if they were siblings. The effect of transform-style: preserve-3d can then be thought of as causing all the 3D transformed elements in a 3D rendering context to be hoisted up into the establishing element, but still rendered with their <a href="#accumulated-3d-transformation-matrix-computation">accumulated 3D transformation matrix</a>.

<div class="example">
  <pre>
  &lt;style>
  .container {
    background-color: rgba(0, 0, 0, 0.3);
    perspective: 500px;
  }
  .container > div {
    position: absolute;
    left: 0;
  }
  .container > :first-child {
    transform: rotateY(45deg);
    background-color: orange;
    top: 10px;
    height: 135px;
  }
  .container > :last-child {
    transform: translateZ(40px);
    background-color: rgba(0, 0, 255, 0.6);
    top: 50px;
    height: 100px;
  }
  &lt;/style>

  &lt;div class="container">
    &lt;div>&lt;/div>
    &lt;div>&lt;/div>
  &lt;/div>
  </pre>

This example shows show elements in a 3D rendering context can intersect. The container element establishes a 3D rendering context for itself and its two children. The children intersect with each other, and the orange element also intersects with the container.

  <div class="figure">
    <img src="examples/3d-intersection.png" width="210" height="198" alt="Intersecting sibling elements.">
  </div>
</div>

The ''perspective'' property can be used to ensure that 3D transformed elements in the resulting 3D rendering context appear to live in a common three-dimensional space with depth, by suppling a common perspective matrix to descendant transformed members of its 3D rendering context, which is taken into account in the <a href="#accumulated-3d-transformation-matrix-computation">accumulated 3D matrix computation</a>.

By default, elements with value for ''perspective'' other than ''perspective/none'' are flattening, and thus establish a 3D rendering context. However, setting ''transform-style'' to ''preserve-3d'' allows the perspective element to extend its containing 3D rendering context (provided no other <a href="#grouping-property-values">grouping property values</a> are in effect).

<div class="example">
  <pre>
  &lt;style>
  div {
    height: 150px;
    width: 150px;
  }
  .container {
    perspective: 500px;
    border: 1px solid black;
  }
  .transformed {
    transform: rotateY(50deg);
    background-color: blue;
  }
  .child {
    transform-origin: top left;
    transform: rotateX(40deg);
    background-color: lime;
  }
  &lt;/style>

  &lt;div class="container">
    &lt;div class="transformed">
      &lt;div class="child">&lt;/div>
    &lt;/div>
  &lt;/div>
  </pre>

This example shows how nested 3D transforms are rendered. The blue div is transformed as in the previous example, with its rendering influenced by the perspective on its parent element. The lime element also has a 3D transform, which is a rotation about the X axis (anchored at the top, by virtue of the transform-origin). However, the lime element is being rendered into the plane of its parent because it is not a member of the same 3D rendering context; the parent is "flattening". Thus the lime element only appears shorter; it does not "pop out" of the blue element.

  <div class="figure">
    <img src="examples/3d-rendering-context-flat.png" width="240" height="200" alt="Nested 3D transforms, with flattening">
  </div>
</div>

<h4 id="transformed-element-hierarchies">Transformed element hierarchies</h4>

By default, <a>transformed elements</a> are flattening, and thus establish a <a>3D rendering context</a>. However, since it is useful to construct hierarchies of transformed objects that share a common 3-dimensional space, this flattening behavior may be overridden by specifying a value of ''preserve-3d'' for the ''transform-style'' property, provided no other <a href="#grouping-property-values">grouping property values</a> are in effect. This allows descendants of the transformed element to share the same 3D rendering context. Non-3D-transformed descendants of such elements are rendered into the plane of the element in step C above, but 3D-transformed elements in the same 3D rendering context will "pop out" into their own planes.

<div class="example">
  <pre>
  &lt;style>
  div {
    height: 150px;
    width: 150px;
  }
  .container {
    perspective: 500px;
    border: 1px solid black;
  }
  .transformed {
    <b>transform-style: preserve-3d</b>;
    transform: rotateY(50deg);
    background-color: blue;
  }
  .child {
    transform-origin: top left;
    transform: rotateX(40deg);
    background-color: lime;
  }
  &lt;/style>
  </pre>

This example is identical to the previous example, with the addition of ''transform-style: preserve-3d'' on the blue element. The blue element now extends the 3D rendering context of its container. Now both blue and lime elements share a common three-dimensional space, so the lime element renders as tilting out from its parent, influenced by the perspective on the container.

  <div class="figure">
    <img src="examples/3d-rendering-context-3d.png" width="240" height="200" alt="Nested 3D transforms, with preserve-3d.">
  </div>
</div>

<h4 id="accumulated-3d-transformation-matrix-computation">Accumulated 3D Transformation Matrix Computation</h4>

The final value of the transform used to render an element in a <a>3D rendering context</a> is computed by accumulating an <a>accumulated 3D transformation matrix</a> as follows:

1. Let <var>transform</var> be the identity matrix.
2. Let <var>current element</var> be the transformed element.
3. Let <var>ancestor block</var> be the element that establishes the transformed element's containing block.
4. While <var>current element</var> is not the element that establishes the transformed element's <a>3D rendering context</a>:

    1. If <var>current element</var> has a value for 'transform' which is not ''transform/none'', pre-multiply <var>current element</var>'s <a>transformation matrix</a> with the <var>transform</var>.
    2. Compute a translation matrix which represents the offset of <var>current element</var> from its <var>ancestor block</var>, and pre-multiply that matrix into the <var>transform</var>.
    3. If <var>ancestor block</var> has a value for 'perspective' which is not ''perspective/none'', pre-multiply the <var>ancestor block</var>'s <a>perspective matrix</a> into the <var>transform</var>.
    4. Let <var>ancestor block</var> be the element that establishes the <var>current element</var>'s containing block.
    5. Let <var>current element</var> be the <var>ancestor block</var>.

Note: as described here, the <a>accumulated 3D transformation matrix</a> takes into account offsets generated by the <a href="https://www.w3.org/TR/REC-CSS2/visuren.html">visual formatting model</a> on the transformed element, and elements in the ancestor chain between the transformed element and the element that establishes the its <a>3D rendering context</a>.

<h4 id="backface-visibility">Backface Visibility</h4>

Using three-dimensional transforms, it's possible to transform an element such that its reverse side is visible. 3D-transformed elements show the same content on both sides, so the reverse side looks like a mirror-image of the front side (as if the element were projected onto a sheet of glass). Normally, elements whose reverse side is towards the viewer remain visible. However, the 'backface-visibility' property allows the author to make an element invisible when its reverse side is towards the viewer. This behavior is "live"; if an element with ''backface-visibility: hidden'' were animating, such that its front and reverse sides were alternately visible, then it would only be visible when the front side were towards the viewer.

Visibility of the reverse side of an element is considered using the <a>accumulated 3D transformation matrix</a>, and is thus relative to the enclosing flattening element.

Note: This property is useful when you place two elements back-to-back, as you would to create a playing card. Without this property, the front and back elements could switch places at times during an animation to flip the card. Another example is creating a box out of 6 elements, but where you want to see only the inside faces of the box.

<div class="example">

This example shows how to make a "card" element that flips over when clicked. Note the "transform-style: preserve-3d" on #card which is necessary to avoid flattening when flipped.

  <pre>
  &lt;style>
  .body { perspective: 500px; }
  #card {
    position: relative;
    height: 300px; width: 200px;
    transition: transform 1s;
    transform-style: preserve-3d;
  }
  #card.flipped {
    transform: rotateY(180deg);
  }
  .face {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: silver;
    border-radius: 40px;
    backface-visibility: hidden;
  }
  .back {
    transform: rotateY(180deg);
  }
  &lt;/style>
  &lt;div id="card" onclick="this.classList.toggle('flipped')">
    &lt;div class="front face">Front&lt;/div>
    &lt;div class="back face">Back&lt;/div>
  &lt;/div>
  </pre>

</div>

Issue: what is the impact of backface-visibility on non-transformed or 2D-transformed elements? Do they get popped into their own planes and intersect?

<h3 id="processing-of-perspective-transformed-boxes">
  Processing of Perspective-Transformed Boxes
</h3>

Issue: This is a first pass at an attempt to precisely specify how exactly to transform elements using the provided matrices. It might not be ideal, and implementer feedback is encouraged.  See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=15605">bug 15605</a>.

The <a>accumulated 3D transformation matrix</a> is affected both by the ''perspective'' property, and by any perspective() transform function present in the value of the ''transform'' property.

This <a>accumulated 3D transformation matrix</a> is a 4&times;4 matrix, while the objects to be transformed are two-dimensional boxes. To transform each corner (<var>a</var>, <var>b</var>) of a box, the matrix must first be applied to (<var>a</var>, <var>b</var>, 0, 1), which will result in a four-dimensional point (<var>x</var>, <var>y</var>, <var>z</var>, <var>w</var>).  This is transformed back to a three-dimensional point (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) as follows:

If <var>w</var> > 0, (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) = (<var>x</var>/<var>w</var>, <var>y</var>/<var>w</var>, <var>z</var>/<var>w</var>).

If <var>w</var> = 0, (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) = (<var>x</var> &sdot; <var>n</var>, <var>y</var> &sdot; <var>n</var>, <var>z</var> &sdot; <var>n</var>).  <var>n</var> is an implementation-dependent value that should be chosen so that <var>x</var>&prime; or <var>y</var>&prime; is much larger than the viewport size, if possible.  For example, (5px, 22px, 0px, 0) might become (5000px, 22000px, 0px), with <var>n</var> = 1000, but this value of <var>n</var> would be too small for (0.1px, 0.05px, 0px, 0). This specification does not define the value of <var>n</var> exactly.  Conceptually, (<var>x</var>&prime;, <var>y</var>&prime;, <var>z</var>&prime;) is <a href="http://en.wikipedia.org/wiki/Plane_at_infinity">infinitely far</a> in the direction (<var>x</var>, <var>y</var>, <var>z</var>).

If <var>w</var> &lt; 0 for all four corners of the transformed box, the box is not rendered.

If <var>w</var> &lt; 0 for one to three corners of the transformed box, the box must be replaced by a polygon that has any parts with <var>w</var> &lt; 0 cut out. This will in general be a polygon with three to five vertices, of which exactly two will have <var>w</var> = 0 and the rest <var>w</var> > 0. These vertices are then transformed to three-dimensional points using the rules just stated.  Conceptually, a point with <var>w</var> &lt; 0 is "behind" the viewer, so should not be visible.

<div class="example">
  <pre>
  .transformed {
    height: 100px;
    width: 100px;
    background: lime;
    transform: perspective(50px) translateZ(100px);
  }
  </pre>

All of the box's corners have <var>z</var>-coordinates greater than the perspective.  This means that the box is behind the viewer and will not display.  Mathematically, the point (<var>x</var>, <var>y</var>) first becomes (<var>x</var>, <var>y</var>, 0, 1), then is translated to (<var>x</var>, <var>y</var>, 100, 1), and then applying the perspective results in (<var>x</var>, <var>y</var>, 100, &minus;1). The <var>w</var>-coordinate is negative, so it does not display. An implementation that doesn't handle the <var>w</var> &lt; 0 case separately might incorrectly display this point as (&minus;<var>x</var>, &minus;<var>y</var>, &minus;100), dividing by &minus;1 and mirroring the box.

</div>

<div class="example">
  <pre>
  .transformed {
    height: 100px;
    width: 100px;
    background: radial-gradient(yellow, blue);
    transform: perspective(50px) translateZ(50px);
  }
  </pre>

Here, the box is translated upward so that it sits at the same place the viewer is looking from. This is like bringing the box closer and closer to one's eye until it fills the entire field of vision. Since the default transform-origin is at the center of the box, which is yellow, the screen will be filled with yellow.

Mathematically, the point (<var>x</var>, <var>y</var>) first becomes (<var>x</var>, <var>y</var>, 0, 1), then is translated to (<var>x</var>, <var>y</var>, 50, 1), then becomes (<var>x</var>, <var>y</var>, 50, 0) after applying perspective. Relative to the transform-origin at the center, the upper-left corner was (&minus;50, &minus;50), so it becomes (&minus;50,
    &minus;50, 50, 0).  This is transformed to something very far to the upper left, such as (&minus;5000, &minus;5000, 5000).  Likewise the other corners are sent very far away. The radial gradient is stretched over the whole box, now enormous, so the part that's visible without scrolling should be the color of the middle pixel: yellow.  However, since the box is not actually infinite, the user can still scroll to the edges to see the blue parts.

</div>

<div class="example">
  <pre>
  .transformed {
    height: 50px;
    width: 50px;
    background: lime;
    border: 25px solid blue;
    transform-origin: left;
    transform: perspective(50px) rotateY(-45deg);
  }
  </pre>

The box will be rotated toward the viewer, with the left edge staying fixed while the right edge swings closer.  The right edge will be at about <var>z</var> = ''70.7px'', which is closer than the perspective of ''50px''. Therefore, the rightmost edge will vanish ("behind" the viewer), and the visible part will stretch out infinitely far to the right.

Mathematically, the top right vertex of the box was originally (100, &minus;50), relative to the transform-origin. It is first expanded to (100, &minus;50, 0, 1).  After applying the transform specified, this will get mapped to about (70.71, &minus;50, 70.71, &minus;0.4142). This has <var>w</var> = &minus;0.4142 &lt; 0, so we need to slice away the part of the box with <var>w</var> &lt; 0.  This results in the new top-right vertex being (50, &minus;50, 50, 0).  This is then mapped to some faraway point in the same direction, such as (5000, &minus;5000, 5000), which is up and to the right from the transform-origin.  Something similar is done to the lower right corner, which gets mapped far down and to the right. The resulting box stretches far past the edge of the screen.

Again, the rendered box is still finite, so the user can scroll to see the whole thing if he or she chooses. However, the right part has been chopped off.  No matter how far the user scrolls, the rightmost ''30px'' or so of the original box will not be visible.  The blue border was only ''25px'' wide, so it will be visible on the left, top, and bottom, but not the right.

The same basic procedure would apply if one or three vertices had <var>w</var> &lt; 0.  However, in that case the result of truncating the <var>w</var> &lt; 0 part would be a triangle or pentagon instead of a quadrilateral.

</div>

<!--
   /$$                                             /$$$$$$
  | $$                                            /$$__  $$
 /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$$| $$  \__//$$$$$$   /$$$$$$
|_  $$_/   /$$__  $$|____  $$| $$__  $$ /$$_____/| $$$$   /$$__  $$ /$$__  $$
  | $$    | $$  \__/ /$$$$$$$| $$  \ $$|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/
  | $$ /$$| $$      /$$__  $$| $$  | $$ \____  $$| $$    | $$  | $$| $$
  |  $$$$/| $$     |  $$$$$$$| $$  | $$ /$$$$$$$/| $$    |  $$$$$$/| $$
   \___/  |__/      \_______/|__/  |__/|_______/ |__/     \______/ |__/





 /$$$$$$/$$$$
| $$_  $$_  $$
| $$ \ $$ \ $$
| $$ | $$ | $$
| $$ | $$ | $$
|__/ |__/ |__/
-->

<h2 id="transform-property">The 'transform' Property</h2>

A transformation is applied to the coordinate system an element renders in through the 'transform' property. This property contains a list of <a href="#transform-functions">transform functions</a>. The final transformation value for a coordinate system is obtained by converting each function in the list to its corresponding matrix like defined in <a href="#mathematical-description">Mathematical Description of Transform Functions</a>, then multiplying the matrices.

<pre class='propdef'>
Name: transform
Value: none | <<transform-list>>
Initial: none
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: refer to the size of <a>reference box</a>
Computed value: As specified, but with relative lengths converted into absolute lengths.
Media: visual
Animatable: as <a href="#interpolation-of-transforms">transform</a>
</pre>

Any computed value other than ''transform/none'' for the transform results in the creation of both a stacking context and a containing block. The object acts as a containing block for fixed positioned descendants.

<pre class=prod><dfn>&lt;transform-list></dfn> = <<transform-function>>+</pre>


<h3 id="serialization-of-transform-functions">Serialization of <<transform-function>>s</h3>

To serialize the <<transform-function>>s, serialize as per their individual grammars, in the order the grammars are written in, avoiding <<calc()>> expressions where possible, avoiding <<calc()>> transformations, omitting components when possible without changing the meaning, joining space-separated tokens with a single space, and following each serialized comma with a single space.

<h3 id="serialization-of-the-computed-value">Serialization of the <a>computed value</a> of <<transform-list>></h3>

A <<transform-list>> for the <a>computed value</a> is serialized to either one <<matrix()>> or one <<matrix3d()>> function by the following algorithm:

<ol class="algorithm">
  <li>Let <var>transform</var> be a 4x4 matrix initialized to the identity matrix. The elements <var>m11</var>, <var>m22</var>, <var>m33</var> and <var>m44</var> of <var>transform</var> must be set to ''1'' all other elements of <var>transform</var> must be set to ''0''.
  <li>Post-multiply all <<transform-function>>s in <<transform-list>> to <var>transform</var>.
  <li>Chose between <<matrix()>> or <<matrix3d()>> serialization:
    <dl class="switch">
      <dt>If <var>transform</var> is a <a>2D matrix</a>
      <dd>Serialize <var>transform</var> to a <<matrix()>> function.
      <dt>Otherwise
      <dd>Serialize <var>transform</var> to a <<matrix3d()>> function.
    </dl>

</ol>


<!--
   /$$                                             /$$$$$$
  | $$                                            /$$__  $$
 /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$$| $$  \__//$$$$$$   /$$$$$$
|_  $$_/   /$$__  $$|____  $$| $$__  $$ /$$_____/| $$$$   /$$__  $$ /$$__  $$
  | $$    | $$  \__/ /$$$$$$$| $$  \ $$|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/
  | $$ /$$| $$      /$$__  $$| $$  | $$ \____  $$| $$    | $$  | $$| $$
  |  $$$$/| $$     |  $$$$$$$| $$  | $$ /$$$$$$$/| $$    |  $$$$$$/| $$
   \___/  |__/      \_______/|__/  |__/|_______/ |__/     \______/ |__/



                                           /$$           /$$
                                          |__/          |__/
 /$$$$$$/$$$$           /$$$$$$   /$$$$$$  /$$  /$$$$$$  /$$ /$$$$$$$
| $$_  $$_  $$ /$$$$$$ /$$__  $$ /$$__  $$| $$ /$$__  $$| $$| $$__  $$
| $$ \ $$ \ $$|______/| $$  \ $$| $$  \__/| $$| $$  \ $$| $$| $$  \ $$
| $$ | $$ | $$        | $$  | $$| $$      | $$| $$  | $$| $$| $$  | $$
| $$ | $$ | $$        |  $$$$$$/| $$      | $$|  $$$$$$$| $$| $$  | $$
|__/ |__/ |__/         \______/ |__/      |__/ \____  $$|__/|__/  |__/
                                               /$$  \ $$
                                              |  $$$$$$/
                                               \______/
-->

<h2 id="transform-origin-property">The 'transform-origin' Property</h2>

<pre class='propdef'>
Name: transform-origin
Value: &nbsp;&nbsp;[ left | center | right | top | bottom | <<length-percentage>> ]<br> | <br>&nbsp;&nbsp;[ left | center | right | <<length-percentage>> ]<br>&nbsp;&nbsp;[ top | center | bottom | <<length-percentage>> ] <<length>>?<br> |<br>&nbsp;&nbsp;[[ center | left | right ] && [ center | top | bottom ]] <<length>>?
Initial: 50% 50%
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: refer to the size of <a>reference box</a>
Computed value: For <<length>> the absolute value, otherwise a percentage
Media: visual
Animatable: as <a href="https://drafts.csswg.org/css3-transitions/#animtype-simple-list">simple list</a> of <a href="https://drafts.csswg.org/css3-transitions/#animtype-lpcalc">length, percentage, or calc</a>
</pre>

The initial <a>used value</a> for SVG elements without associated CSS layout box is ''0 0''.

The values of the 'transform' and 'transform-origin' properties are used to compute the <a>transformation matrix</a>, as described above.

If only one value is specified, the second value is assumed to be <a value for=transform-origin>center</a>. If one or two values are specified, the third value is assumed to be ''0px''.

If two or more values are defined and either no value is a keyword, or the only used keyword is <a value for=transform-origin>center</a>, then the first value represents the horizontal position (or offset) and the second represents the vertical position (or offset). A third value always represents the Z position (or offset) and must be of type <<length>>.

<dl dfn-for="transform-origin" dfn-type="value">
  <dt><<percentage>>
  <dd>
    A percentage for the horizontal offset is relative to the width of the <a>reference box</a>. A percentage for the vertical offset is relative to the height of the <a>reference box</a>. The value for the horizontal and vertical offset represent an offset from the top left corner of the <a>reference box</a>.

  <dt><<length>>
  <dd>
    A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the <a>reference box</a>.

  <dt><dfn>top</dfn>
  <dd>Computes to ''0%'' for the vertical position.
  <dt><dfn>right</dfn>
  <dd>Computes to ''100%'' for the horizontal position.
  <dt><dfn>bottom</dfn>
  <dd>Computes to ''100%'' for the vertical position.
  <dt><dfn>left</dfn>
  <dd>Computes to ''0%'' for the horizontal position.
  <dt><dfn>center</dfn>
  <dd>
    Computes to ''50%'' (''left 50%'') for the horizontal position if the horizontal position is not otherwise specified, or ''50%'' (''top 50%'') for the vertical position if it is.
</dl>

The <a href="https://www.w3.org/TR/cssom/#resolved-value">resolved value</a> of 'transform-origin' is the <a href="https://www.w3.org/TR/CSS21/cascade.html#used-value">used value</a> (i.e., percentages are resolved to absolute lengths).


<h2 id="transform-box">Transform reference box: the 'transform-box' property</h2>

<pre class='propdef'>
Name: transform-box
Value: border-box | fill-box | view-box
Initial: border-box
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: Same as specified value.
Media: visual
Animatable: no
</pre>

All transformations defined by the 'transform' and 'transform-origin' property are relative to the position and dimension of one of the following <dfn>reference box</dfn>es:

<dl dfn-for=transform-box>
  <dt><dfn dfn-type=value>border-box</dfn>
  <dd>
    Uses the border box as reference box. The reference box of a table is the border box of its <a href="https://www.w3.org/TR/CSS21/tables.html#model">table wrapper box</a>, not its table box.

  <dt><dfn dfn-type=value>fill-box</dfn>
  <dd>
    Uses the <a>object bounding box</a> as reference box.

  <dt><dfn dfn-type=value>view-box</dfn>
  <dd>
    <p>Uses the nearest <a href="https://www.w3.org/TR/SVG11/intro.html#TermSVGViewport">SVG viewport</a> as reference box.
    <p>If a {{viewBox}} attribute is specified for the <a href="https://www.w3.org/TR/SVG11/intro.html#TermSVGViewport">SVG viewport</a> creating element:
      <ul>
        <li>The reference box is positioned at the origin of the coordinate system established by the {{viewBox}} attribute.
        <li>The dimension of the reference box is set to the <em>width</em> and <em>height</em> values of the {{viewBox}} attribute.
      </ul>


</dl>

A reference box adds an additional offset to the origin specified by the 'transform-origin' property.

For SVG elements without an associated CSS layout box, the <a>used value</a> for <a value for=transform-box>border-box</a> is <a value for=transform-box>view-box</a>.

For elements with an associated CSS layout box, the <a>used value</a> for <a value for=transform-box>fill-box</a> and <a value for=transform-box>view-box</a> is <a value for=transform-box>border-box</a>.


<!--
   /$$                                             /$$$$$$
  | $$                                            /$$__  $$
 /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$$| $$  \__//$$$$$$   /$$$$$$
|_  $$_/   /$$__  $$|____  $$| $$__  $$ /$$_____/| $$$$   /$$__  $$ /$$__  $$
  | $$    | $$  \__/ /$$$$$$$| $$  \ $$|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/
  | $$ /$$| $$      /$$__  $$| $$  | $$ \____  $$| $$    | $$  | $$| $$
  |  $$$$/| $$     |  $$$$$$$| $$  | $$ /$$$$$$$/| $$    |  $$$$$$/| $$
   \___/  |__/      \_______/|__/  |__/|_______/ |__/     \______/ |__/



                                   /$$               /$$
                                  | $$              | $$
 /$$$$$$/$$$$           /$$$$$$$ /$$$$$$   /$$   /$$| $$  /$$$$$$
| $$_  $$_  $$ /$$$$$$ /$$_____/|_  $$_/  | $$  | $$| $$ /$$__  $$
| $$ \ $$ \ $$|______/|  $$$$$$   | $$    | $$  | $$| $$| $$$$$$$$
| $$ | $$ | $$         \____  $$  | $$ /$$| $$  | $$| $$| $$_____/
| $$ | $$ | $$         /$$$$$$$/  |  $$$$/|  $$$$$$$| $$|  $$$$$$$
|__/ |__/ |__/        |_______/    \___/   \____  $$|__/ \_______/
                                           /$$  | $$
                                          |  $$$$$$/
                                           \______/
-->

<h2 id="transform-style-property">The 'transform-style' Property</h2>

<pre class='propdef'>
Name: transform-style
Value: auto | flat | preserve-3d
Initial: auto
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: Same as specified value.
Media: visual
Animatable: no
</pre>

A value of "flat" for 'transform-style' establishes a stacking context, and establishes a <a>3D rendering context</a>. Elements with a used value of "auto" are ignored for the purposes of 3D rendering context computation, and those with a used value of "preserve-3d" extend the 3D rendering context to which they belong, even if values for the ''transform'' or ''perspective'' properties would otherwise cause flattening. A value of "preserve-3d" establishes a stacking context, and a containing block.

<h3 id="grouping-property-values">Grouping property values</h3>

The following CSS property values require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore force the used value of ''transform-style'' to ''flat'':

* 'overflow': any value other than ''overflow/visible''.
* 'opacity': any value less than 1.
* 'filter': any value other than ''filter/none''.
* 'clip': any value other than ''clip/auto''.
* 'clip-path': any value other than ''clip-path/none''.
* 'isolation': used value of ''isolation/isolate''.
* 'mask-image': any value other than ''mask-image/none''.
* 'mask-border-source': any value other than ''mask-border-source/none''.
* 'mix-blend-mode': any value other than ''mix-blend-mode/normal''.

The following CSS property values cause an ''transform-style/auto'' value of ''transform-style'' to become ''transform-style/flat'':

* 'transform': any value other than ''transform/none''.
* 'perspective': any value other than ''perspective/none''.

In both cases the computed value of 'transform-style' is not affected.

Issue: Having overflow imply transform-style: flat causes every element with non-visible overflow to become
a stacking context, which is unwanted. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=28252">Bug 28252</a>.

<!--
  /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$   /$$$$$$$
 /$$__  $$ /$$__  $$ /$$__  $$ /$$_____/ /$$__  $$ /$$__  $$ /$$_____/
| $$  \ $$| $$$$$$$$| $$  \__/|  $$$$$$ | $$  \ $$| $$$$$$$$| $$
| $$  | $$| $$_____/| $$       \____  $$| $$  | $$| $$_____/| $$
| $$$$$$$/|  $$$$$$$| $$       /$$$$$$$/| $$$$$$$/|  $$$$$$$|  $$$$$$$
| $$____/  \_______/|__/      |_______/ | $$____/  \_______/ \_______/
| $$                                    | $$
| $$                                    | $$
|__/                                    |__/
   /$$     /$$
  | $$    |__/
 /$$$$$$   /$$ /$$    /$$ /$$$$$$
|_  $$_/  | $$|  $$  /$$//$$__  $$
  | $$    | $$ \  $$/$$/| $$$$$$$$
  | $$ /$$| $$  \  $$$/ | $$_____/
  |  $$$$/| $$   \  $/  |  $$$$$$$
   \___/  |__/    \_/    \_______/
-->

<h2 id="perspective-property">The 'perspective' Property</h2>

<pre class='propdef'>
Name: perspective
Value: none | <<length>>
Initial: none
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: Absolute length or "none".
Media: visual
Animatable: as <a href="https://drafts.csswg.org/css3-transitions/#animtype-length">length</a>
</pre>

Where <<length>> values must be positive.

<dl dfn-for="perspective">
  <dt><dfn><<length>></dfn>
  <dd>
    <p>Distance to the center of projection.

Issue: Verify that projection is the distance to the center of projection.


  <dt><dfn>none</dfn>
  <dd>
    No perspective transform is applied. The effect is mathematically similar to an infinite <<length>> value. All objects appear to be flat on the canvas.

</dl>

The use of this property with any value other than ''perspective/none'' establishes a stacking context. It also establishes a containing block (somewhat similar to ''position: relative''), just like the 'transform' property does.

The values of the 'perspective' and 'perspective-origin' properties are used to compute the <a>perspective matrix</a>, as described above.


<!--
  /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$$  /$$$$$$   /$$$$$$   /$$$$$$$
 /$$__  $$ /$$__  $$ /$$__  $$ /$$_____/ /$$__  $$ /$$__  $$ /$$_____/
| $$  \ $$| $$$$$$$$| $$  \__/|  $$$$$$ | $$  \ $$| $$$$$$$$| $$
| $$  | $$| $$_____/| $$       \____  $$| $$  | $$| $$_____/| $$
| $$$$$$$/|  $$$$$$$| $$       /$$$$$$$/| $$$$$$$/|  $$$$$$$|  $$$$$$$
| $$____/  \_______/|__/      |_______/ | $$____/  \_______/ \_______/
| $$                                    | $$
| $$                                    | $$
|__/                                    |__/
   /$$     /$$                                                 /$$
  | $$    |__/                                                |__/
 /$$$$$$   /$$ /$$    /$$ /$$$$$$           /$$$$$$   /$$$$$$  /$$  /$$$$$$
|_  $$_/  | $$|  $$  /$$//$$__  $$ /$$$$$$ /$$__  $$ /$$__  $$| $$ /$$__  $$
  | $$    | $$ \  $$/$$/| $$$$$$$$|______/| $$  \ $$| $$  \__/| $$| $$  \ $$
  | $$ /$$| $$  \  $$$/ | $$_____/        | $$  | $$| $$      | $$| $$  | $$
  |  $$$$/| $$   \  $/  |  $$$$$$$        |  $$$$$$/| $$      | $$|  $$$$$$$
   \___/  |__/    \_/    \_______/         \______/ |__/      |__/ \____  $$
                                                                   /$$  \ $$
                                                                  |  $$$$$$/
                                                                   \______/
 /$$
|__/
 /$$ /$$$$$$$
| $$| $$__  $$
| $$| $$  \ $$
| $$| $$  | $$
| $$| $$  | $$
|__/|__/  |__/
-->

<h2 id="perspective-origin-property">The 'perspective-origin' Property</h2>

The 'perspective-origin' property establishes the origin for the 'perspective' property. It effectively sets the X and Y position at which the viewer appears to be looking at the children of the element.

<pre class='propdef'>
Name: perspective-origin
Value: <<position>>
Initial: 50% 50%
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: refer to the size of the <a>reference box</a>
Computed value: For <<length>> the absolute value, otherwise a percentage.
Media: visual
Animatable: as <a href="https://drafts.csswg.org/css3-transitions/#animtype-simple-list">simple list</a> of <a href="https://drafts.csswg.org/css3-transitions/#animtype-lpcalc">length, percentage, or calc</a>
</pre>

The values of the 'perspective' and 'perspective-origin' properties are used to compute the <a>perspective matrix</a>, as described above.

The values for 'perspective-origin' represent an offset of the perspective origin from the top left corner of the <a>reference box</a>.

<dl dfn-for="perspective-origin" dfn-type="value">
  <dt><dfn><<percentage>></dfn>
  <dd>
    <p>A percentage for the horizontal perspective offset is relative to the width of the <a>reference box</a>. A percentage for the vertical offset is relative to height of the <a>reference box</a>. The value for the horizontal and vertical offset represent an offset from the top left corner of the <a>reference box</a>.

  <dt><dfn><<length>></dfn>

  <dd>
    <p>A length value gives a fixed length as the offset. The value for the horizontal
      and vertical offset represent an offset from the top left corner of the
      <a>reference box</a>.

  <dt><dfn>top</dfn>

  <dd>Computes to ''0%'' for the vertical position if one or two
    values are given, otherwise specifies the top edge as the origin for the
    next offset.

  <dt><dfn>right</dfn>

  <dd>Computes to ''100%'' for the horizontal position if one or two
    values are given, otherwise specifies the right edge as the origin
    for the next offset.

  <dt><dfn>bottom</dfn>

  <dd>Computes to ''100%'' for the vertical position if one or two
    values are given, otherwise specifies the bottom edge as the origin
    for the next offset.

  <dt><dfn>left</dfn>

  <dd>Computes to ''0%'' for the horizontal position if one or two
    values are given, otherwise specifies the left edge as the origin
    for the next offset.

  <dt><dfn>center</dfn>

  <dd>Computes to ''50%'' (''left 50%'') for the
    horizontal position if the horizontal position is not otherwise
    specified, or ''50%'' (''top 50%'') for the vertical position if
    it is.
</dl>

The <a>resolved value</a> of 'perspective-origin' is the <a>used value</a> (i.e., percentages are resolved to absolute lengths).

<!--
 /$$                           /$$        /$$$$$$
| $$                          | $$       /$$__  $$
| $$$$$$$   /$$$$$$   /$$$$$$$| $$   /$$| $$  \__//$$$$$$   /$$$$$$$  /$$$$$$
| $$__  $$ |____  $$ /$$_____/| $$  /$$/| $$$$   |____  $$ /$$_____/ /$$__  $$
| $$  \ $$  /$$$$$$$| $$      | $$$$$$/ | $$_/    /$$$$$$$| $$      | $$$$$$$$
| $$  | $$ /$$__  $$| $$      | $$_  $$ | $$     /$$__  $$| $$      | $$_____/
| $$$$$$$/|  $$$$$$$|  $$$$$$$| $$ \  $$| $$    |  $$$$$$$|  $$$$$$$|  $$$$$$$
|_______/  \_______/ \_______/|__/  \__/|__/     \_______/ \_______/ \_______/



                    /$$           /$$ /$$       /$$ /$$ /$$   /$$
                   |__/          |__/| $$      |__/| $$|__/  | $$
         /$$    /$$ /$$  /$$$$$$$ /$$| $$$$$$$  /$$| $$ /$$ /$$$$$$   /$$   /$$
 /$$$$$$|  $$  /$$/| $$ /$$_____/| $$| $$__  $$| $$| $$| $$|_  $$_/  | $$  | $$
|______/ \  $$/$$/ | $$|  $$$$$$ | $$| $$  \ $$| $$| $$| $$  | $$    | $$  | $$
          \  $$$/  | $$ \____  $$| $$| $$  | $$| $$| $$| $$  | $$ /$$| $$  | $$
           \  $/   | $$ /$$$$$$$/| $$| $$$$$$$/| $$| $$| $$  |  $$$$/|  $$$$$$$
            \_/    |__/|_______/ |__/|_______/ |__/|__/|__/   \___/   \____  $$
                                                                      /$$  | $$
                                                                     |  $$$$$$/
                                                                      \______/
-->

<h2 id="backface-visibility-property">The 'backface-visibility' Property</h2>

<pre class='propdef'>
Name: backface-visibility
Value: visible | hidden
Initial: visible
Applies to: <a>transformable elements</a>
Inherited: no
Percentages: N/A
Computed value: Same as specified value.
Media: visual
Animatable: no
</pre>

The visibility of an element with ''backface-visibility: hidden'' is determined as follows:

1. Compute the element's <var>accumulated 3D transformation matrix</var>.
2. If the component of the matrix in row 3, column 3 is negative, then the element should be hidden. Otherwise it is visible.

Issue: Backface-visibility cannot be tested by only looking at m33. See <a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=23014">Bug 23014</a>.

Note: The reasoning for this definition is as follows. Assume elements are rectangles in the <var>x</var>&ndash;<var>y</var> plane with infinitesimal thickness. The front of the untransformed element has coordinates like (<var>x</var>, <var>y</var>, <var>&epsilon;</var>), and the back is (<var>x</var>, <var>y</var>, &minus;<var>&epsilon;</var>), for some very small <var>&epsilon;</var>. We want to know if after the transformation, the front of the element is closer to the viewer than the back (higher <var>z</var>-value) or further away. The <var>z</var>-coordinate of the front will be m<sub>13</sub><var>x</var> + m<sub>23</sub><var>y</var> + m<sub>33</sub><var>&epsilon;</var> + m<sub>43</sub>, before accounting for perspective, and the back will be m<sub>13</sub><var>x</var> + m<sub>23</sub><var>y</var> &minus; m<sub>33</sub><var>&epsilon;</var> + m<sub>43</sub>.  The first quantity is greater than the second if and only if m<sub>33</sub> > 0. (If it equals zero, the front and back are equally close to the viewer. This probably means something like a 90-degree rotation, which makes the element invisible anyway, so we don't really care whether it vanishes.)

<!--
                                         /$$
                                        | $$
  /$$$$$$$ /$$    /$$ /$$$$$$          /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$
 /$$_____/|  $$  /$$//$$__  $$ /$$$$$$|_  $$_/   /$$__  $$|____  $$| $$__  $$
|  $$$$$$  \  $$/$$/| $$  \ $$|______/  | $$    | $$  \__/ /$$$$$$$| $$  \ $$
 \____  $$  \  $$$/ | $$  | $$          | $$ /$$| $$      /$$__  $$| $$  | $$
 /$$$$$$$/   \  $/  |  $$$$$$$          |  $$$$/| $$     |  $$$$$$$| $$  | $$
|_______/     \_/    \____  $$           \___/  |__/      \_______/|__/  |__/
                     /$$  \ $$
                    |  $$$$$$/
                     \______/
            /$$$$$$
           /$$__  $$
  /$$$$$$$| $$  \__//$$$$$$   /$$$$$$  /$$$$$$/$$$$
 /$$_____/| $$$$   /$$__  $$ /$$__  $$| $$_  $$_  $$
|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/| $$ \ $$ \ $$
 \____  $$| $$    | $$  | $$| $$      | $$ | $$ | $$
 /$$$$$$$/| $$    |  $$$$$$/| $$      | $$ | $$ | $$
|_______/ |__/     \______/ |__/      |__/ |__/ |__/
-->

<h2 id="svg-transform">The SVG 'transform' Attribute</h2>

The SVG 1.1 specification did not specify the attributes "transform", <{linearGradient/gradientTransform}> or <{pattern/patternTransform}> as <a>presentation attributes</a> [[!SVG11]]. In order to improve the integration of SVG and HTML, this specification makes these SVG attributes presentation attributes and makes the 'transform' property one that applies to <a>transformable elements</a> in the SVG namespace.

This specification will also introduce the new presentation attributes 'transform-origin', 'perspective', 'perspective-origin', 'transform-style' and 'backface-visibility'.

Values on new introduced presentation attributes get parsed following the syntax rules on <a href="#svg-data-types">SVG Data Types</a> [[!SVG11]].

<h3 id="transform-attribute-specificity">
  SVG 'transform' attribute specificity
</h3>

Since the previously named SVG attributes become presentation attributes, their participation in the CSS cascade is determined by the specificity of <a>presentation attributes</a> in the SVG specification.

<div class="example">

This example shows the combination of the 'transform' style property and the 'transform' presentation attribute.

  <pre>
  &lt;svg xmlns="http://www.w3.org/2000/svg">
    &lt;style>
    .container {
      transform: translate(100px, 100px);
    }
    &lt;/style>

    &lt;g class="container" transform="translate(200 200)">
      &lt;rect width="100" height="100" fill="blue" />
    &lt;/g>
  &lt;/svg>
  </pre>

  <div class="figure">
    <img src="examples/svg-translate1.svg" width="470" height="240" alt="Translated SVG container element.">
  </div>

Because of the participation to the CSS cascade, the 'transform' style property overrides the 'transform' presentation attribute. Therefore the container gets translated by ''100px'' in both the horizontal and the vertical directions, instead of ''200px''.

</div>

<h3 id="svg-syntax">Syntax of the SVG 'transform' attribute</h3>

To provide backwards compatibility, the syntax of the 'transform' presentation attribute differs from the syntax of the 'transform' style property as shown in the example above. However, the syntax used for the 'transform' style property can be used for a 'transform' presentation attribute value. Authors are advised to follow the rules of CSS Values and Units Module [[!CSS3VAL]]. Therefore an author should write ''transform="translate(200px, 200px)"'' instead of ''transform="translate  (200 200)"'' because the second example with the spaces before the ''('', the missing comma between the arguments and the values without the explicit unit notation would be valid for the attribute only.

<h4 id="svg-transform-list">Transform List</h4>

The value for the 'transform' attribute consists of a transform list with zero or more transform functions using <a href="#svg-functional-notation">functional notation</a>. If the transform list consists of more than one transform function, these functions are separated by optional whitespace, an optional comma ('','') and optional whitespace. The transform list can have optional whitespace characters before and after the list.

<h4 id="svg-functional-notation">Functional Notation</h4>

The syntax starts with the name of the function followed by a left parenthesis followed by optional whitespace followed by the argument(s) to the notation followed by optional whitespace followed by a right parenthesis. If a function takes more than one argument, the arguments are either separated by a comma ('','') with optional whitespace characters before and after the comma, or by one or more whitespace characters.

Note: Unlike SVG 1.1, this specification does not allow optional whitespace between the name of the function and the left parenthesis.

<h4 id="svg-data-types">SVG Data Types</h4>

Arguments on all new introduced presentation attributes consist of data types in the sense of CSS Values and Units Module [[!CSS3VAL]]. The definitions of data types in CSS Values and Units Module are enhanced as follows:

<h5 id="svg-transform-value">
  The <<length>> type
</h5>

A <<length>> can be a <<number>> without an unit identifier. In this case the <a href="#svg-number">number</a> gets interpreted as "user unit". A user unit in the the <a href="https://www.w3.org/TR/2003/REC-SVG11-20030114/coords.html#InitialCoordinateSystem">initial coordinate system</a> is equivalent to the parent environment's notion of a pixel unit.

<h5 id="svg-angle">The <<angle>> type</h5>

An angle can be a <<number>> without an unit identifier. In this case the <a href="#svg-number">number</a> gets interpreted as a value in degrees.

<h5 id="svg-number">The <<number>> type</h5>

SVG supports scientific notations for numbers. Therefore a number gets parsed like described in SVG <a href="https://www.w3.org/TR/SVG/types.html#DataTypeNumber">Basic data types</a> for SVG attributes.

<h3 id="svg-gradient-transform-pattern-transform">
  The SVG <{linearGradient/gradientTransform}> and <{pattern/patternTransform}> attributes
</h3>

SVG specifies the attributes <{linearGradient/gradientTransform}> and <{pattern/patternTransform}>. This specification makes both attributes presentation attributes. Both attributes use the same <a href="#svg-syntax">syntax</a> as the SVG 'transform' attribute. This specification does not introduce corresponding CSS style properties. Both, the <{linearGradient/gradientTransform}> and the <{pattern/patternTransform}> attribute, are presentation attributes for the 'transform' property.

<h3 id="svg-transform-functions">
  SVG transform functions
</h3>

For backwards compatibility with existing SVG content, this specification supports all transform functions defined by <a href="https://www.w3.org/TR/SVG/coords.html#TransformAttribute">The â€˜transformâ€™ attribute</a> in [[SVG11]]. Therefore the two-dimensional transform function ''rotate(&lt;angle>)'' is extended as follows:

<dl>
  <dt id="rotate-three-function">
    <pre class='prod'><a>rotate()</a> = rotate( <<angle>> [, <<length>>, <<length>>]? )</pre>

  <dd>
    specifies a <a href="#RotateDefined">2D rotation</a> by the angle specified in the parameter about the origin of the element, as defined by the 'transform-origin' property. If the optional translation values are specified, the transform origin is translated by that amount (using the current transformation matrix) for the duration of the rotate operation. For example ''rotate(90deg, 100px, 100px)'' would cause elements to appear rotated one-quarter of a turn in the clockwise direction after a translation of the transform-origin of 100 pixel in the horizontal and vertical directions.

</dl>

User agents are just required to support the two optional arguments for translation on elements in the SVG namespace.

<h3 id="svg-three-dimensional-functions">SVG and 3D transform functions</h3>

This specification explicitly requires three-dimensional transform functions to apply to the <a>container elements</a>: <{a}>, <{g}>, <{svg}>, all <a>graphics elements</a>, all <a>graphics referencing elements</a> and the SVG <{foreignObject}> element.

Three-dimensional transform functions and the properties 'perspective', 'perspective-origin', 'transform-style' and 'backface-visibility' can not be used for the elements: <{clipPath}>, <{linearGradient}>, <{radialGradient}> and <{pattern}>. If a transform list includes a three-dimensional transform function, the complete transform list must be ignored. The values of every previously named property must be ignored. <var>Transformable elements</var> that are contained by one of these elements can have three-dimensional transform functions. The <{clipPath}>, <{mask}>, <{pattern}> elements require the user agent to create a flattened representation of the descendant elements before they can be applied, and therefore override the behavior of ''transform-style: preserve-3d''.

If the 'vector-effect' property is set to ''non-scaling-stroke'' and an object is within a <a>3D rendering context</a> the property has no affect on stroking the object.

<h3 id="svg-user-coordinate-space">User coordinate space</h3>

For the <{pattern}>, <{linearGradient}>, <{radialGradient}> and <{clipPath}> elements the 'transform', <{pattern/patternTransform}>, <{linearGradient/gradientTransform}> presentation attributes represents values in the current user coordinate system in place at the time when these elements are referenced (i.e., the user coordinate system for the element referencing the <{pattern}> element via a 'fill' or 'stroke' property). Percentage values are relative to the <a>reference box</a> of the referencing element.

In particular the <{pattern/patternUnits}>, <{linearGradient/gradientUnits}> and <{mask/maskUnits}> attributes don't affect the user coordinate system used for transformations [[SVG11]].

For all other <a>transformable elements</a> the 'transform' presentation attribute represents values in the current user coordinate system of the parent. All percentage values of the 'transform' presentation attribute are relative to the element's <a>reference box</a>.

<div class="example">

The 'transform-origin' property on the pattern in the following example specifies a ''50%'' translation of the origin in the horizontal and vertical dimension. The 'transform' property specifies a translation as well, but in absolute lengths.

  <pre>
  &lt;svg xmlns="http://www.w3.org/2000/svg">
    &lt;style>
    pattern {
      transform: rotate(45deg);
      transform-origin: 50% 50%;
    }
    &lt;/style>

    &lt;defs>
    &lt;pattern id="pattern-1">
      &lt;rect id="rect1" width="100" height="100" fill="blue" />
    &lt;/pattern>
    &lt;/defs>

    &lt;rect width="200" height="200" fill="url(#pattern-1)" />
  &lt;/svg>
  </pre>

An SVG <{pattern}> element doesn't have a bounding box. The <a>reference box</a> of the referencing <{rect}> element is used instead to solve the relative values of the 'transform-origin' property. Therefore the point of origin will get translated  by 100 pixels temporarily to rotate the user space of the <{pattern}> elements content.

</div>

<h3 id="transform-attribute-dom">
  SVG DOM interface for the 'transform' attribute
</h3>

The SVG specification defines the "<a href="https://www.w3.org/TR/2011/REC-SVG11-20110816/coords.html#InterfaceSVGAnimatedTransformList">SVGAnimatedTransformList</a>" interface in the SVG DOM to provide access to the animated and the base value of the SVG 'transform', <{linearGradient/gradientTransform}> and <{pattern/patternTransform}> attributes. To ensure backwards compatibility, this API must still be supported by user agents.

The 'transform' property contributes to the CSS cascade. According to SVG 1.1 user agents conceptually insert a <a href="https://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes">new author style sheet</a> for presentation attributes, which is the first in the author style sheet collection. {{baseVal}} gives the author the possibility to access and modify the values of the SVG 'transform' attribute. To provide the necessary backwards compatibility to the SVG DOM, {{baseVal}} must reflect the values of this author style sheet. All modifications to SVG DOM objects of {{baseVal}} must affect this author style sheet immediately.

{{animVal}} represents the computed style of the 'transform' property. Therefore it includes all applied <a href="https://www.w3.org/TR/css3-transitions/">CSS3 Transitions</a>, <a href="https://www.w3.org/TR/css3-animations/">CSS3 Animations</a> or <a href="#svg-animation">SVG Animations</a> if any of those are underway. The computed style and SVG DOM objects of {{animVal}} can not be modified.

The attribute "<a href="https://www.w3.org/TR/SVG/coords.html#__svg__SVGTransform__type">type</a>" of '<a href="https://www.w3.org/TR/SVG/coords.html#InterfaceSVGTransform">SVGTransform</a>" must return "<a href="https://www.w3.org/TR/SVG/coords.html#__svg__SVGTransform__SVG_TRANSFORM_UNKNOWN">SVG_TRANSFORM_UNKNOWN</a>" for <a href="#transform-functions">Transform Functions</a> or unit types that are not supported by this interface. If a two-dimensional transform function is not supported, the attribute "<a href="https://www.w3.org/TR/SVG/coords.html#__svg__SVGTransform__matrix">matrix</a>" must return a 3x2 "<a href="https://www.w3.org/TR/SVG/coords.html#InterfaceSVGMatrix">SVGMatrix</a>" with the corresponding values as described in the section <a href="#mathematical-description">Mathematical Description of Transform Functions</a>.

<h2 id="svg-animation">SVG Animation</h2>

<h3 id="svg-animate-element">
  The <{animate}> and <{set}> element
</h3>

With this specification, the <{animate}> element and the <{set}> element can animate the data type <<transform-list>>.

The animation effect is post-multiplied to the underlying value for additive <{animate}> animations (see below) instead of added to the underlying value, due to the specific behavior of <<transform-list>> animations.

<var>From-to</var>, <var>from-by</var> and <var>by</var> animations are defined in SMIL to be equivalent to a corresponding <var>values</var> animation. However, <var>to</var> animations are a mixture of additive and non-additive behavior [[SMIL3]].

<var>To</var> animations on <{animate}> provide specific functionality to get a smooth change from the underlying value to the <var>to</var> attribute value, which conflicts mathematically with the requirement for additive transform animations to be post-multiplied. As a consequence, the behavior of <var>to</var> animations for <{animate}> is undefined. Authors are suggested to use <var>from-to</var>, <var>from-by</var>, <var>by</var> or <var>values</var> animations to achieve any desired transform animation.

The value "paced" is undefined for the attribute <{animate/calcMode}> on <{animate}> for animations of the data type <<transform-list>>. If specified, UAs may choose the value "linear" instead. Future versions of this specification may define how paced animations can be performed on <<transform-list>>.

Note: The following paragraphs extend <a href="https://www.w3.org/TR/SVG/animate.html#complexDistances">Elements, attributes and properties that can be animated</a> [[SVG11]].

The introduce presentation attributes 'transform', 'transform-origin', 'perspective', 'perspective-origin', 'transform-style' and 'backface-visibility' are animatable. 'transform-style' and 'backface-visibility' are non-additive.

With this specification the SVG basic data type <<transform-list>> is equivalent to a list of <<transform-function>>s. <<transform-list>> is animatable and additive. The data type can be animated using the SVG <{animate}> element and the SVG <{set}> element. SVG animations must run the same animation steps as described in section <a href="#interpolation-of-transforms">Transitions and Animations between Transform Values</a>.

<table class="data">
  <caption>Animatable data types</caption>
  <thead>
    <tr>
      <th>Data type
      <th>Additive?
      <th><{animate}>
      <th><{set}>
      <th><{animateColor}>
      <th><{animateTransform}>
      <th>Notes

  </thead>
  <tbody>
    <tr>
      <th><<transform-list>>
      <td>yes
      <td>yes
      <td>yes
      <td>no
      <td>yes
      <td>Additive for <{animateTransform}> means that a transformation is post-multiplied to the base set of
        transformations.

  </tbody>
</table>

<h3 id="neutral-element">Neutral element for addition</h3>

Some animations require a neutral element for addition. For transform functions this is a scalar or a list of scalars of 0. Examples of neutral elements for transform functions are ''translate(0)'', ''translate3d(0, 0, 0)'', ''translateX(0)'', ''translateY(0)'', ''translateZ(0)'', ''scale(0)'', ''scaleX(0)'', ''scaleY(0)'', ''scaleZ(0)'', ''rotate(0)'', ''rotate3d(v<sub>x</sub>, v<sub>y</sub>, v<sub>z</sub>, 0)'' (where <var>v</var> is a context dependent vector), ''rotateX(0)'', ''rotateY(0)'', ''rotateZ(0)'', ''skew(0, 0)'', ''skewX(0)'', ''skewY(0)'', ''matrix(0, 0, 0, 0, 0, 0)'', ''matrix3d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)'' and ''perspective(0)''.

Note: Animations to or from the neutral element of additions ''matrix()'', ''matrix3d()'' and ''perspective()'' fall back to discrete animations (See [[#matrix-interpolation]]).

<div class="example">

A <var>by</var> animation with a by value v<sub>b</sub> is equivalent to the same animation with a values list with 2 values, the neutral element for addition for the domain of the target attribute (denoted 0) and v<sub>b</sub>, and ''additive="sum"''. [[SMIL3]]

  <pre>
  &lt;rect width="100" height="100">
  &lt;animateTransform attributeName="transform" attributeType="XML"
  type="scale" by="1" dur="5s" fill="freeze"/>
  &lt;/rect>
  </pre>

The neutral element for addition when performing a <var>by</var> animation with ''type="scale"'' is the value 0. Thus, performing the animation of the example above causes the rectangle to be invisible at time 0s (since the animated transform list value is ''scale(0)''), and be scaled back to its original size at time 5s (since the animated transform list value is ''scale(1)'').

</div>

<h3 id="svg-attribute-name">
  The SVG '<a href="https://www.w3.org/TR/SVG/animate.html#TargetAttributes">attributeName</a>' attribute
</h3>

<a href="https://www.w3.org/TR/SVG/animate.html">SVG 1.1 Animation</a> defines the "<a href="https://www.w3.org/TR/SVG/animate.html#TargetAttributes">attributeName</a>" attribute to specify the name of the target attribute. For the presentation attributes <{linearGradient/gradientTransform}> and <{pattern/patternTransform}> it will also be possible to use the value 'transform'. The same 'transform' property will get animated.

<div class="example">

In this example the gradient transformation of the linear gradient gets animated.

  <pre>&lt;linearGradient gradientTransform="scale(2)">
&lt;animate attributeName="gradientTransform" from="scale(2)" to="scale(4)"
dur="3s" additive="sum"/>
&lt;animate attributeName="transform" from="translate(0, 0)" to="translate(100px, 100px)"
dur="3s" additive="sum"/>
&lt;/linearGradient></pre>

The <{linearGradient}> element specifies the <{linearGradient/gradientTransform}> presentation attribute. The two <{animate}> elements address the target attribute <{linearGradient/gradientTransform}> and 'transform'. Even so all animations apply to the same gradient transformation by taking the value of the <{linearGradient/gradientTransform}> presentation attribute, applying the scaling of the first animation and applying the translation of the second animation one after the other.

</div>

<!--
   /$$                                             /$$$$$$
  | $$                                            /$$__  $$
 /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$$| $$  \__//$$$$$$   /$$$$$$
|_  $$_/   /$$__  $$|____  $$| $$__  $$ /$$_____/| $$$$   /$$__  $$ /$$__  $$
  | $$    | $$  \__/ /$$$$$$$| $$  \ $$|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/
  | $$ /$$| $$      /$$__  $$| $$  | $$ \____  $$| $$    | $$  | $$| $$
  |  $$$$/| $$     |  $$$$$$$| $$  | $$ /$$$$$$$/| $$    |  $$$$$$/| $$
   \___/  |__/      \_______/|__/  |__/|_______/ |__/     \______/ |__/



                        /$$$$$$                                 /$$     /$$
                       /$$__  $$                               | $$    |__/
 /$$$$$$/$$$$         | $$  \__//$$   /$$ /$$$$$$$   /$$$$$$$ /$$$$$$   /$$
| $$_  $$_  $$ /$$$$$$| $$$$   | $$  | $$| $$__  $$ /$$_____/|_  $$_/  | $$
| $$ \ $$ \ $$|______/| $$_/   | $$  | $$| $$  \ $$| $$        | $$    | $$
| $$ | $$ | $$        | $$     | $$  | $$| $$  | $$| $$        | $$ /$$| $$
| $$ | $$ | $$        | $$     |  $$$$$$/| $$  | $$|  $$$$$$$  |  $$$$/| $$
|__/ |__/ |__/        |__/      \______/ |__/  |__/ \_______/   \___/  |__/





  /$$$$$$  /$$$$$$$   /$$$$$$$
 /$$__  $$| $$__  $$ /$$_____/
| $$  \ $$| $$  \ $$|  $$$$$$
| $$  | $$| $$  | $$ \____  $$
|  $$$$$$/| $$  | $$ /$$$$$$$/
 \______/ |__/  |__/|_______/
-->

<h2 id="transform-functions">The Transform Functions</h2>

The value of the 'transform' property is a list of <dfn>&lt;transform-function></dfn>. The set of allowed transform functions is given below. Wherever <<angle>> is used in this specification, a <<number>> that is equal to zero is also allowed, which is treated the same as an angle of zero degrees. A percentage for horizontal translations is relative to the width of the <a>reference box</a>. A percentage for vertical translations is relative to the height of the <a>reference box</a>.

<h3 id="two-d-transform-functions">2D Transform Functions</h3>
<dl dfn-for="transform">
  <dt>
    <span class='prod'><dfn>matrix()</dfn> = matrix( <<number>> [, <<number>> ]{5,5} )</span>

  <dd>
    specifies a 2D transformation in the form of a <a href="#MatrixDefined">transformation matrix</a> of the six values a-f.

  <dt>
    <span class='prod'><dfn>translate()</dfn> = translate( <<length-percentage>> [, <<length-percentage>> ]? )</span>

  <dd>
    specifies a <a href="#TranslateDefined">2D translation</a> by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <em>&lt;ty></em> is not provided, ty has zero as a value.

  <dt>
    <span class='prod'><dfn>translateX()</dfn> = translateX( <<length-percentage>> )</span>

  <dd>
    specifies a <a href="#TranslateDefined">translation</a> by the given amount in the X direction.

  <dt>
    <span class='prod'><dfn>translateY()</dfn> = translateY( <<length-percentage>> )</span>

  <dd>
    specifies a <a href="#TranslateDefined">translation</a> by the given amount in the Y direction.

  <dt>
    <span class='prod'><dfn>scale()</dfn> = scale( <<number>> [, <<number>> ]? )</span>

  <dd>
    specifies a <a href="#ScaleDefined">2D scale</a> operation by the [sx,sy] scaling vector described by the 2 parameters. If the second parameter is not provided, it takes a value equal to the first. For example, scale(1, 1) would leave an element unchanged, while scale(2, 2) would cause it to appear twice as long in both the X and Y axes, or four times its typical geometric size.

  <dt>
    <span class='prod'><dfn>scaleX()</dfn> = scaleX( <<number>> )</span>

  <dd>
    specifies a <a href="#ScaleDefined">2D scale</a> operation using the [sx,1] scaling vector, where sx is given as the parameter.

  <dt>
    <span class='prod'><dfn>scaleY()</dfn> = scaleY( <<number>> )</span>

  <dd>
    specifies a <a href="#ScaleDefined">2D scale</a> operation using the [1,sy] scaling vector, where sy is given as the parameter.

  <dt>
    <span class='prod'><dfn>rotate()</dfn> = rotate( <<angle>> )</span>

  <dd>
    specifies a <a href="#RotateDefined">2D rotation</a> by the angle specified in the parameter about the origin of the element, as
    defined by the 'transform-origin' property. For example, ''rotate(90deg)''
    would cause elements to appear rotated one-quarter of a turn in the clockwise direction.

  <dt>
    <span class='prod'><dfn>skew()</dfn> = skew( <<angle>> [, <<angle>> ]? )</span>

  <dd>
    specifies a <a href="#SkewDefined">2D skew</a> by [ax,ay] for X and Y. If the second parameter is not provided, it has a zero value.
    <p class="note">Note that the behavior of ''skew()'' is different from multiplying ''skewX()'' with ''skewY()''. Implementations must support this function for compatibility with legacy content.

  <dt>
    <span class='prod'><dfn>skewX()</dfn> = skewX( <<angle>> )</span>

  <dd>
    specifies a <a href="#SkewXDefined">2D skew transformation along the X axis</a> by the given angle.

  <dt>
    <span class='prod'><dfn>skewY()</dfn> = skewY( <<angle>> )</span>

  <dd>
    specifies a <a href="#SkewYDefined">2D skew transformation along the Y axis</a> by the given angle.

</dl>


<h3 id="three-d-transform-functions">3D Transform Functions</h3>

<dl>
  <dt>
    <span class='prod'><dfn>matrix3d()</dfn> = matrix3d( <<number>> [, <<number>> ]{15,15} )</span>

  <dd>
    specifies a 3D transformation as a 4x4 homogeneous matrix of 16 values in column-major order.

  <dt>
    <span class='prod'><dfn>translate3d()</dfn> = translate3d( <<length-percentage>> , <<length-percentage>> , <<length>> )</span>

  <dd>
    specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [tx,ty,tz], with tx, ty and tz being the first, second and third translation-value parameters respectively.

  <dt>
    <span class='prod'><dfn>translateZ()</dfn> = translateZ( <<length>> )</span>

  <dd>
    specifies a <a href="#Translate3dDefined">3D translation</a> by the vector [0,0,tz] with the given amount in the Z direction.

  <dt>
    <span class='prod'><dfn>scale3d()</dfn> = scale3d( <<number>> , <<number>>, <<number>> )</span>

  <dd>
    specifies a <a href="#Scale3dDefined">3D scale</a> operation by the [sx,sy,sz] scaling vector described by the 3 parameters.

  <dt>
    <span class='prod'><dfn>scaleZ()</dfn> = scaleZ( <<number>> )</span>

  <dd>
    specifies a <a href="#Scale3dDefined">3D scale</a> operation using the [1,1,sz] scaling vector, where sz is given as the parameter.

  <dt>
    <span class='prod'><dfn>rotate3d()</dfn> = rotate3d( <<number>> , <<number>> , <<number>> , <<angle>> )</span>

  <dd>
    specifies a <a href="#Rotate3dDefined">3D rotation</a> by the angle specified in last parameter about the [x,y,z] direction vector described by the first three parameters. A direction vector that cannot be normalized, such as [0,0,0], will cause the rotation to not be applied.
    <p class="note">Note that the rotation is clockwise as one looks from the end of the vector toward the origin.

  <dt>
    <span class='prod'><dfn>rotateX()</dfn> = rotateX( <<angle>> )</span>

  <dd>
    same as ''rotate3d(1, 0, 0, &lt;angle>)''.

  <dt>
    <span class='prod'><dfn>rotateY()</dfn> = rotateY( <<angle>> )</span>

  <dd>
    same as ''rotate3d(0, 1, 0, &lt;angle>)''.

  <dt>
    <span class='prod'><dfn>rotateZ()</dfn> = rotateZ( <<angle>> )</span>

  <dd>
    same as ''rotate3d(0, 0, 1, &lt;angle>)'', which is also the same as ''rotate(&lt;angle>)''.

  <dt>
    <span class='prod'><dfn>perspective()</dfn> = perspective( <<length>> )</span>

  <dd>
    specifies a <a href="#PerspectiveDefined">perspective projection matrix</a>. This matrix scales points in X and Y based on their Z value, scaling points with positive Z values away from the origin, and those with negative Z values towards the origin. Points on the z=0 plane are unchanged. The parameter represents the distance of the z=0 plane from the viewer. Lower values give a more flattened pyramid and therefore a more pronounced perspective effect. For example, a value of 1000px gives a moderate amount of foreshortening and a value of 200px gives an extreme amount. The value for depth must be greater than zero, otherwise the function is invalid.

</dl>

<!--
   /$$                                             /$$$$$$
  | $$                                            /$$__  $$
 /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$$| $$  \__//$$$$$$   /$$$$$$
|_  $$_/   /$$__  $$|____  $$| $$__  $$ /$$_____/| $$$$   /$$__  $$ /$$__  $$
  | $$    | $$  \__/ /$$$$$$$| $$  \ $$|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/
  | $$ /$$| $$      /$$__  $$| $$  | $$ \____  $$| $$    | $$  | $$| $$
  |  $$$$/| $$     |  $$$$$$$| $$  | $$ /$$$$$$$/| $$    |  $$$$$$/| $$
   \___/  |__/      \_______/|__/  |__/|_______/ |__/     \______/ |__/



                        /$$$$$$                                 /$$     /$$
                       /$$__  $$                               | $$    |__/
 /$$$$$$/$$$$         | $$  \__//$$   /$$ /$$$$$$$   /$$$$$$$ /$$$$$$   /$$
| $$_  $$_  $$ /$$$$$$| $$$$   | $$  | $$| $$__  $$ /$$_____/|_  $$_/  | $$
| $$ \ $$ \ $$|______/| $$_/   | $$  | $$| $$  \ $$| $$        | $$    | $$
| $$ | $$ | $$        | $$     | $$  | $$| $$  | $$| $$        | $$ /$$| $$
| $$ | $$ | $$        | $$     |  $$$$$$/| $$  | $$|  $$$$$$$  |  $$$$/| $$
|__/ |__/ |__/        |__/      \______/ |__/  |__/ \_______/   \___/  |__/



                             /$$ /$$             /$$
                            | $$|__/            | $$
  /$$$$$$  /$$$$$$$         | $$ /$$  /$$$$$$$ /$$$$$$
 /$$__  $$| $$__  $$ /$$$$$$| $$| $$ /$$_____/|_  $$_/
| $$  \ $$| $$  \ $$|______/| $$| $$|  $$$$$$   | $$
| $$  | $$| $$  | $$        | $$| $$ \____  $$  | $$ /$$
|  $$$$$$/| $$  | $$        | $$| $$ /$$$$$$$/  |  $$$$/
 \______/ |__/  |__/        |__/|__/|_______/    \___/
-->

<h2 id="transform-function-lists">The Transform Function Lists</h2>

If a list of <<transform-function>> is provided, then the net effect is as if each transform function had been specified separately in the order provided. For example,

<pre>
&lt;div style="transform:translate(-10px,-20px) scale(2) rotate(45deg) translate(5px,10px)"/>
</pre>

is functionally equivalent to:

<pre>
&lt;div style="transform:translate(-10px,-20px)">
  &lt;div style="transform:scale(2)">
    &lt;div style="transform:rotate(45deg)">
      &lt;div style="transform:translate(5px,10px)">
      &lt;/div>
    &lt;/div>
  &lt;/div>
&lt;/div>
</pre>

That is, in the absence of other styling that affects position and dimensions, a nested set of transforms is equivalent to a single list of transform functions, applied from the outside in. The resulting transform is the matrix multiplication of the list of transforms.

If a transform function causes the <a>current transformation matrix (CTM)</a> of an object to be non-invertible, the object and its content do not get displayed.

<div class="example">

The object in the following example gets scaled by 0.

  <pre>
  &lt;style>
  .box {
    transform: scale(0);
  }
  &lt;/style>

  &lt;div class="box">
    Not visible
  &lt;/div>
  </pre>

The scaling causes a non-invertible CTM for the coordinate space of the div box. Therefore neither the div box, nor the text in it get displayed.

</div>

<!--
 /$$$$$$             /$$                                             /$$
|_  $$_/            | $$                                            | $$
  | $$   /$$$$$$$  /$$$$$$    /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$ | $$
  | $$  | $$__  $$|_  $$_/   /$$__  $$ /$$__  $$ /$$__  $$ /$$__  $$| $$
  | $$  | $$  \ $$  | $$    | $$$$$$$$| $$  \__/| $$  \ $$| $$  \ $$| $$
  | $$  | $$  | $$  | $$ /$$| $$_____/| $$      | $$  | $$| $$  | $$| $$
 /$$$$$$| $$  | $$  |  $$$$/|  $$$$$$$| $$      | $$$$$$$/|  $$$$$$/| $$
|______/|__/  |__/   \___/   \_______/|__/      | $$____/  \______/ |__/
                                                | $$
                                                | $$
                                                |__/
             /$$     /$$
            | $$    |__/
  /$$$$$$  /$$$$$$   /$$  /$$$$$$  /$$$$$$$
 |____  $$|_  $$_/  | $$ /$$__  $$| $$__  $$
  /$$$$$$$  | $$    | $$| $$  \ $$| $$  \ $$
 /$$__  $$  | $$ /$$| $$| $$  | $$| $$  | $$
|  $$$$$$$  |  $$$$/| $$|  $$$$$$/| $$  | $$
 \_______/   \___/  |__/ \______/ |__/  |__/
-->

<h2 id="interpolation-of-transforms">Interpolation of Transforms</h2>

When animating or transitioning transforms, the transform function lists must be interpolated. For interpolation between one transform <em>from-transform</em> and a second transforms <em>to-transform</em>, the rules described below are applied.

<ul>
  <li id="none-none-animation">
    If both the <em>from-</em> and <em>to-transform</em> are ''transform/none'':
    <ul>
      <li>
        There is no interpolation necessary. The computed value stays ''transform/none''.

    </ul>

  <li id="none-transform-animation">
    If one of the <em>from-</em> or <em>to-transforms</em> is ''transform/none''.
    <ul>
      <li>
        The value ''transform/none'' is replaced by an equivalent <a>identity transform function</a> list for the corresponding transform function list. Both transform function lists get interpolated following the next rule.

    </ul>
    <div class="example">
      <p>
        For example, if <em>from-transform</em> is ''scale(2)'' and <em>to-transform</em> is ''transform/none'' then the value ''scale(1)'' will be used for <em>to-transform</em> and animation will proceed using the next rule. Similarly, if <em>from-transform</em> is ''transform/none'' and <em>to-transform</em> is ''scale(2) rotate(50deg)'' then the animation will execute as if <em>from-transform</em> is ''scale(1) rotate(0)''.

    </div>

  <li id="transform-transform-animation">
    If <em>from-</em> and <em>to-transform</em> have the same number of transform functions, each transform function pair has either the same name, or is a derivative of the same <a href="#transform-primitives">primitive</a>.
    <ul>
      <li>
        Interpolate each transform function pair as described in <a href="#interpolation-of-transform-functions">Interpolation of transform functions</a>. The computed value is the resulting transform function list.

    </ul>
    <div class="example">
      <p>
        For example, if <em>from-transform</em> is ''scale(1) translate(0)'' and <em>to-transform</em> is ''translate(100px) scale(2)'' then ''scale(1)'' and ''translate(100px)'' as well as ''translate(0)'' and ''scale(2)'' don't share a common primitive and therefore can not get interpolated following this rule.

    </div>

  <li id="other-animation">
    In all other cases:
    <ul>
      <li>
        The transform functions of each transform function list on the <em>from-</em> and <em>to-transform</em> get post multiplied and converted into 4x4 matrices. Each of the matrices gets interpolated following the instructions in <a href="#matrix-interpolation">Interpolation of matrices</a>. The computed value is the transform function ''matrix'' if both initial matrices can be represented by a correlating 3x2 matrix and ''matrix3d'' otherwise.

    </ul>

</ul>

In some cases, an animation might cause a transformation matrix to be singular or non-invertible. For example, an animation in which scale moves from 1 to -1. At the time when the matrix is in such a state, the transformed element is not rendered.

<!--
   /$$                                             /$$$$$$
  | $$                                            /$$__  $$
 /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$   /$$$$$$$| $$  \__//$$$$$$   /$$$$$$
|_  $$_/   /$$__  $$|____  $$| $$__  $$ /$$_____/| $$$$   /$$__  $$ /$$__  $$
  | $$    | $$  \__/ /$$$$$$$| $$  \ $$|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/
  | $$ /$$| $$      /$$__  $$| $$  | $$ \____  $$| $$    | $$  | $$| $$
  |  $$$$/| $$     |  $$$$$$$| $$  | $$ /$$$$$$$/| $$    |  $$$$$$/| $$
   \___/  |__/      \_______/|__/  |__/|_______/ |__/     \______/ |__/



                                           /$$               /$$   /$$     /$$
                                          |__/              |__/  | $$    |__/
 /$$$$$$/$$$$           /$$$$$$   /$$$$$$  /$$ /$$$$$$/$$$$  /$$ /$$$$$$   /$$
| $$_  $$_  $$ /$$$$$$ /$$__  $$ /$$__  $$| $$| $$_  $$_  $$| $$|_  $$_/  | $$
| $$ \ $$ \ $$|______/| $$  \ $$| $$  \__/| $$| $$ \ $$ \ $$| $$  | $$    | $$
| $$ | $$ | $$        | $$  | $$| $$      | $$| $$ | $$ | $$| $$  | $$ /$$| $$
| $$ | $$ | $$        | $$$$$$$/| $$      | $$| $$ | $$ | $$| $$  |  $$$$/| $$
|__/ |__/ |__/        | $$____/ |__/      |__/|__/ |__/ |__/|__/   \___/  |__/
                      | $$
                      | $$
                      |__/


 /$$    /$$ /$$$$$$   /$$$$$$$
|  $$  /$$//$$__  $$ /$$_____/
 \  $$/$$/| $$$$$$$$|  $$$$$$
  \  $$$/ | $$_____/ \____  $$
   \  $/  |  $$$$$$$ /$$$$$$$/
    \_/    \_______/|_______/
-->

<h2 id="transform-primitives">
  Transform function primitives and derivatives
</h2>

Some transform functions can be represented by more generic transform functions. These transform functions are called derived transform functions, the generic transform functions primitives. Primitives for two-dimensional and three-dimensional transform functions are listed below.

Two-dimensional primitives with derived transform functions are:

<dl>
  <dt id="translate-primitive">
    ''translate()''

  <dd>
    for ''translateX()'', ''translateY()'' and ''translate()''.

  <dt id="rotate-three-primitive">
    ''rotate()'' with three arguments

  <dd>
    for ''rotate()'' with one or three arguments if <a href="#svg-transform-functions">rotate with three arguments</a> is supported.

  <dt id="scale-primitive">
    ''scale()''

  <dd>
    for ''scaleX()'', ''scaleY()'' and ''scale()''.

</dl>

Three-dimensional primitives with derived transform functions are:

<dl>
  <dt id="translate3d-primitive">
    ''translate3d()''

  <dd>
    for ''translateX()'', ''translateY()'', ''translateZ()'' and ''translate()''.

  <dt id="scale3d-primitive">
    ''scale3d()''

  <dd>
    for ''scaleX()'', ''scaleY()'', ''scaleZ()'' and ''scale()''.

  <dt id="rotate3d-primitive">
    ''rotate3d()''

  <dd>
    for ''rotate()'', ''rotateX()'', ''rotateY()'' and ''rotateZ()''.

</dl>

<p id="interpolation-two-three-dimensional-function">
  For derived transform functions that have a two-dimensional primitive and a three-dimensional primitive, the context decides about the used primitive. See <a href="#interpolation-of-transform-functions">Interpolation of primitives and derived transform functions</a>.


<!--
 /$$$$$$             /$$                                             /$$
|_  $$_/            | $$                                            | $$
  | $$   /$$$$$$$  /$$$$$$    /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$ | $$
  | $$  | $$__  $$|_  $$_/   /$$__  $$ /$$__  $$ /$$__  $$ /$$__  $$| $$
  | $$  | $$  \ $$  | $$    | $$$$$$$$| $$  \__/| $$  \ $$| $$  \ $$| $$
  | $$  | $$  | $$  | $$ /$$| $$_____/| $$      | $$  | $$| $$  | $$| $$
 /$$$$$$| $$  | $$  |  $$$$/|  $$$$$$$| $$      | $$$$$$$/|  $$$$$$/| $$
|______/|__/  |__/   \___/   \_______/|__/      | $$____/  \______/ |__/
                                                | $$
                                                | $$
                                                |__/
             /$$                         /$$
            | $$                        | $$
  /$$$$$$  /$$$$$$    /$$$$$$          /$$$$$$    /$$$$$$  /$$$$$$  /$$$$$$$
 |____  $$|_  $$_/   /$$__  $$ /$$$$$$|_  $$_/   /$$__  $$|____  $$| $$__  $$
  /$$$$$$$  | $$    | $$$$$$$$|______/  | $$    | $$  \__/ /$$$$$$$| $$  \ $$
 /$$__  $$  | $$ /$$| $$_____/          | $$ /$$| $$      /$$__  $$| $$  | $$
|  $$$$$$$  |  $$$$/|  $$$$$$$          |  $$$$/| $$     |  $$$$$$$| $$  | $$
 \_______/   \___/   \_______/           \___/  |__/      \_______/|__/  |__/



            /$$$$$$                                           /$$$$$$
           /$$__  $$                                         /$$__  $$
  /$$$$$$$| $$  \__//$$$$$$   /$$$$$$  /$$$$$$/$$$$         | $$  \__//$$   /$$
 /$$_____/| $$$$   /$$__  $$ /$$__  $$| $$_  $$_  $$ /$$$$$$| $$$$   | $$  | $$
|  $$$$$$ | $$_/  | $$  \ $$| $$  \__/| $$ \ $$ \ $$|______/| $$_/   | $$  | $$
 \____  $$| $$    | $$  | $$| $$      | $$ | $$ | $$        | $$     | $$  | $$
 /$$$$$$$/| $$    |  $$$$$$/| $$      | $$ | $$ | $$        | $$     |  $$$$$$/
|_______/ |__/     \______/ |__/      |__/ |__/ |__/        |__/      \______/
-->

<h2 id="interpolation-of-transform-functions">
  Interpolation of primitives and derived transform functions
</h2>

Two transform functions with the same name and the same number of arguments are interpolated numerically without a former conversion. The calculated value will be of the same transform function type with the same number of arguments. Special rules apply to ''rotate3d()'', ''matrix()'', ''matrix3d()'' and ''perspective()''.

<div class="example">

The two transform functions ''translate(0)'' and ''translate(100px)'' are of the same type, have the same number of arguments and therefore can get interpolated numerically. ''translateX(100px)'' is not of the same type and ''translate(100px, 0)'' does not have the same number of arguments, therefore these transform functions can not get interpolated without a former conversion step.

</div>

Two different types of transform functions that share the same primitive, or transform functions of the same type with different number of arguments can be interpolated. Both transform functions need a former conversion to the common primitive first and get interpolated numerically afterwards. The computed value will be the primitive with the resulting interpolated arguments.

<div class="example">

The following example describes a transition from ''translateX(100px)'' to ''translateY(100px)'' in 3 seconds on hovering over the div box. Both transform functions derive from the same primitive ''translate()''
and therefore can be interpolated.

  <pre>
  div {
    transform: translateX(100px);
  }

  div:hover {
    transform: translateY(100px);
    transition: transform 3s;
  }
  </pre>

For the time of the transition both transform functions get transformed to the common primitive. ''translateX(100px)'' gets converted to ''translate(100px, 0)'' and ''translateY(100px)'' gets converted to ''translate(0, 100px)''. Both transform functions can then get interpolated numerically.
</div>

If both transform functions share a primitive in the two-dimensional space, both transform functions get converted to the two-dimensional primitive. If one or both transform functions are three-dimensional transform functions, the common three-dimensional primitive is used.

<div class="example">

In this example a two-dimensional transform function gets animated to a three-dimensional transform function. The common primitive is ''translate3d()''.

  <pre>
  div {
    transform: translateX(100px);
  }

  div:hover {
    transform: translateZ(100px);
    transition: transform 3s;
  }
  </pre>

First ''translateX(100px)'' gets converted to ''translate3d(100px, 0, 0)'' and ''translateZ(100px)'' to ''translate3d(0, 0, 100px)'' respectively. Then both converted transform functions get interpolated numerically.

</div>

The transform functions ''matrix()'', ''matrix3d()'' and ''perspective()'' get converted into 4x4 matrices first and interpolated as defined in section <a href="#matrix-interpolation">Interpolation of Matrices</a> afterwards.

For interpolations with the primitive ''rotate3d()'', the direction vectors of the transform functions get normalized first. If the normalized vectors are equal, the rotation angle gets interpolated numerically. Otherwise the transform functions get converted into 4x4 matrices first and interpolated as defined in section <a href="#matrix-interpolation">Interpolation of Matrices</a> afterwards.

<!--
                           /$$               /$$                  /$$
                          | $$              |__/                 |__/
 /$$$$$$/$$$$   /$$$$$$  /$$$$$$    /$$$$$$  /$$ /$$   /$$        /$$ /$$$$$$$
| $$_  $$_  $$ |____  $$|_  $$_/   /$$__  $$| $$|  $$ /$$//$$$$$$| $$| $$__  $$
| $$ \ $$ \ $$  /$$$$$$$  | $$    | $$  \__/| $$ \  $$$$/|______/| $$| $$  \ $$
| $$ | $$ | $$ /$$__  $$  | $$ /$$| $$      | $$  >$$  $$        | $$| $$  | $$
| $$ | $$ | $$|  $$$$$$$  |  $$$$/| $$      | $$ /$$/\  $$       | $$| $$  | $$
|__/ |__/ |__/ \_______/   \___/  |__/      |__/|__/  \__/       |__/|__/  |__/



   /$$                                             /$$             /$$     /$$
  | $$                                            | $$            | $$    |__/
 /$$$$$$    /$$$$$$   /$$$$$$   /$$$$$$   /$$$$$$ | $$  /$$$$$$  /$$$$$$   /$$
|_  $$_/   /$$__  $$ /$$__  $$ /$$__  $$ /$$__  $$| $$ |____  $$|_  $$_/  | $$
  | $$    | $$$$$$$$| $$  \__/| $$  \ $$| $$  \ $$| $$  /$$$$$$$  | $$    | $$
  | $$ /$$| $$_____/| $$      | $$  | $$| $$  | $$| $$ /$$__  $$  | $$ /$$| $$
  |  $$$$/|  $$$$$$$| $$      | $$$$$$$/|  $$$$$$/| $$|  $$$$$$$  |  $$$$/| $$
   \___/   \_______/|__/      | $$____/  \______/ |__/ \_______/   \___/  |__/
                              | $$
                              | $$
                              |__/


  /$$$$$$  /$$$$$$$
 /$$__  $$| $$__  $$
| $$  \ $$| $$  \ $$
| $$  | $$| $$  | $$
|  $$$$$$/| $$  | $$
 \______/ |__/  |__/
-->

<h2 id="matrix-interpolation">Interpolation of Matrices</h2>

When interpolating between two matrices, each matrix is decomposed into the corresponding translation, rotation, scale, skew and (for a <a>3D matrix</a>) perspective values. Each corresponding component of the decomposed matrices gets interpolated numerically and recomposed back to a matrix in a final step.

In the following example the element gets translated by 100 pixel in both the X and Y directions and rotated by 1170&deg; on hovering. The initial transformation is 45&deg;. With the usage of transition, an author might expect a animated, clockwise rotation by three and a quarter turns (1170&deg;).

<div class="example">
  <pre>
  &lt;style>
  div {
    transform: rotate(45deg);
  }
  div:hover {
    transform: translate(100px, 100px) rotate(1215deg);
    transition: transform 3s;
  }
  &lt;/style>

  &lt;div>&lt;/div>
  </pre>
</div>

The number of transform functions on the source transform ''rotate(45deg)'' differs from the number of transform functions on the destination transform ''translate(100px, 100px) rotate(1125deg)''. According to the last rule of <a href="#interpolation-of-transforms">Interpolation of Transforms</a>, both transforms must be interpolated by matrix interpolation. With converting the transformation functions to matrices, the information about the three turns gets lost and the element gets rotated by just a quarter turn (90&deg;).

To achieve the three and a quarter turns for the example above, source and destination transforms must fulfill the third rule of <a href="#interpolation-of-transforms">Interpolation of Transforms</a>. Source transform could look like ''translate(0, 0) rotate(45deg)'' for a linear interpolation of the transform functions.

In the following we differ between the <a href="#interpolation-of-2d-matrices">interpolation of two 2D matrices</a> and the <a href="#interpolation-of-3d-matrices">interpolation of two matrices</a> where at least one matrix is not a <a>2D matrix</a>.

If one of the matrices for interpolation is non-invertible, the used animation function must fall-back to a discrete animation according to the rules of the respective animation specification.

<h3 id="supporting-functions">Supporting functions</h3>

The pseudo code in the next subsections make use of the following supporting functions:

<pre>
Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix, vector is a 4 component vector):
  double  determinant(matrix)          returns the 4x4 determinant of the matrix
  matrix  inverse(matrix)              returns the inverse of the passed matrix
  matrix  transpose(matrix)            returns the transpose of the passed matrix
  point   multVecMatrix(point, matrix) multiplies the passed point by the passed matrix
                                       and returns the transformed point
  double  length(point)                returns the length of the passed vector
  point   normalize(point)             normalizes the length of the passed point to 1
  double  dot(point, point)            returns the dot product of the passed points
  double  sqrt(double)                 returns the root square of passed value
  double  max(double y, double x)      returns the bigger value of the two passed values
  double  dot(vector, vector)         returns the dot product of the passed vectors
  vector  multVector(vector, vector)  multiplies the passed vectors
  double  sqrt(double)                returns the root square of passed value
  double  max(double y, double x)     returns the bigger value of the two passed values
  double  min(double y, double x)     returns the smaller value of the two passed values
  double  cos(double)                 returns the cosines of passed value
  double  sin(double)                 returns the sine of passed value
  double  acos(double)                returns the inverse cosine of passed value
  double  abs(double)                  returns the absolute value of the passed value
  double  rad2deg(double)              transforms a value in radian to degree and returns it
  double  deg2rad(double)              transforms a value in degree to radian and returns it

Decomposition also makes use of the following function:
  point combine(point a, point b, double ascl, double bscl)
      result[0] = (ascl * a[0]) + (bscl * b[0])
      result[1] = (ascl * a[1]) + (bscl * b[1])
      result[2] = (ascl * a[2]) + (bscl * b[2])
      return result
</pre>

<h3 id="interpolation-of-2d-matrices">Interpolation of 2D matrices</h3>

<h4 id="decomposing-a-2d-matrix">Decomposing a 2D matrix</h4>

The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo".

<pre>
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 2 component vector
        scale       ; a 2 component vector
        angle       ; rotation
        m11         ; 1,1 coordinate of 2x2 matrix
        m12         ; 1,2 coordinate of 2x2 matrix
        m21         ; 2,1 coordinate of 2x2 matrix
        m22         ; 2,2 coordinate of 2x2 matrix
Returns false if the matrix cannot be decomposed, true if it can


double row0x = matrix[0][0]
double row0y = matrix[0][1]
double row1x = matrix[1][0]
double row1y = matrix[1][1]

translate[0] = matrix[3][0]
translate[1] = matrix[3][1]

scale[0] = sqrt(row0x * row0x + row0y * row0y)
scale[1] = sqrt(row1x * row1x + row1y * row1y)

// If determinant is negative, one axis was flipped.
double determinant = row0x * row1y - row0y * row1x
if (determinant < 0)
    // Flip axis with minimum unit vector dot product.
    if (row0x < row1y)
        scale[0] = -scale[0]
    else
        scale[1] = -scale[1]

// Renormalize matrix to remove scale.
if (scale[0])
    row0x *= 1 / scale[0]
    row0y *= 1 / scale[0]
if (scale[1])
    row1x *= 1 / scale[1]
    row1y *= 1 / scale[1]

// Compute rotation and renormalize matrix.
angle = atan2(row0y, row0x);

if (angle)
    // Rotate(-angle) = [cos(angle), sin(angle), -sin(angle), cos(angle)]
    //                = [row0x, -row0y, row0y, row0x]
    // Thanks to the normalization above.
    double sn = -row0y
    double cs = row0x
    double m11 = row0x
    double m12 = row0y
    double m21 = row1x
    double m22 = row1y
    row0x = cs * m11 + sn * m21
    row0y = cs * m12 + sn * m22
    row1x = -sn * m11 + cs * m21
    row1y = -sn * m12 + cs * m22

m11 = row0x
m12 = row0y
m21 = row1x
m22 = row1y

// Convert into degrees because our rotation functions expect it.
angle = rad2deg(angle)

return true
</pre>

<h4 id="interpolation-of-decomposed-2d-matrix-values">
  Interpolation of decomposed 2D matrix values
</h4>

Before two decomposed 2D matrix values can be interpolated, the following

<pre>
Input: translationA ; a 2 component vector
       scaleA       ; a 2 component vector
       angleA       ; rotation
       m11A         ; 1,1 coordinate of 2x2 matrix
       m12A         ; 1,2 coordinate of 2x2 matrix
       m21A         ; 2,1 coordinate of 2x2 matrix
       m22A         ; 2,2 coordinate of 2x2 matrix
       translationB ; a 2 component vector
       scaleB       ; a 2 component vector
       angleB       ; rotation
       m11B         ; 1,1 coordinate of 2x2 matrix
       m12B         ; 1,2 coordinate of 2x2 matrix
       m21B         ; 2,1 coordinate of 2x2 matrix
       m22B         ; 2,2 coordinate of 2x2 matrix


// If x-axis of one is flipped, and y-axis of the other,
// convert to an unflipped rotation.
if ((scaleA[0] < 0 && scaleB[1] < 0) || (scaleA[1] < 0 && scaleB[0] < 0))
    scaleA[0] = -scaleA[0]
    scaleA[1] = -scaleA[1]
    angleA += angleA < 0 ? 180 : -180

// Don't rotate the long way around.
if (!angleA)
    angleA = 360
if (!angleB)
    angleB = 360

if (abs(angleA - angleB) > 180)
    if (angleA > angleB)
        angleA -= 360
    else
        angleB -= 360
</pre>

Afterwards, each component of the decomposed values translation, scale, angle, m11 to m22 of the source matrix get linearly interpolated with each corresponding component of the destination matrix.

<h4 id="recomposing-to-a-2d-matrix">Recomposing to a 2D matrix</h4>

After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below:

<pre>
Input:  translation ; a 2 component vector
        scale       ; a 2 component vector
        angle       ; rotation
        m11         ; 1,1 coordinate of 2x2 matrix
        m12         ; 1,2 coordinate of 2x2 matrix
        m21         ; 2,1 coordinate of 2x2 matrix
        m22         ; 2,2 coordinate of 2x2 matrix
Output: matrix      ; a 4x4 matrix initialized to identity matrix


matrix[0][0] = m11
matrix[0][1] = m12
matrix[1][0] = m21
matrix[1][1] = m22

// Translate matrix.
matrix[3][0] = translate[0] * m11 + translate[1] * m21
matrix[3][1] = translate[0] * m12 + translate[1] * m22

// Rotate matrix.
angle = deg2rad(angle);
double cosAngle = cos(angle);
double sinAngle = sin(angle);

// New temporary, identity initialized, 4x4 matrix rotateMatrix
rotateMatrix[0][0] = cosAngle
rotateMatrix[0][1] = sinAngle
rotateMatrix[1][0] = -sinAngle
rotateMatrix[1][1] = cosAngle

matrix = multiply(matrix, rotateMatrix)

// Scale matrix.
matrix[0][0] *= scale[0]
matrix[0][1] *= scale[0]
matrix[1][0] *= scale[1]
matrix[1][1] *= scale[1]
</pre>

<h3 id="interpolation-of-3d-matrices">Interpolation of 3D matrices</h3>

<h4 id="decomposing-a-3d-matrix">Decomposing a 3D matrix</h4>

The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo", but modified to use Quaternions instead of Euler angles to avoid the problem of Gimbal Locks.

The following pseudocode works on a 4x4 homogeneous matrix:

<pre>
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Returns false if the matrix cannot be decomposed, true if it can


// Normalize the matrix.
if (matrix[3][3] == 0)
    return false

for (i = 0; i < 4; i++)
    for (j = 0; j < 4; j++)
        matrix[i][j] /= matrix[3][3]

// perspectiveMatrix is used to solve for perspective, but it also provides
// an easy way to test for singularity of the upper 3x3 component.
perspectiveMatrix = matrix

for (i = 0; i < 3; i++)
    perspectiveMatrix[i][3] = 0

perspectiveMatrix[3][3] = 1

if (determinant(perspectiveMatrix) == 0)
    return false

// First, isolate perspective.
if (matrix[0][3] != 0 || matrix[1][3] != 0 || matrix[2][3] != 0)
    // rightHandSide is the right hand side of the equation.
    rightHandSide[0] = matrix[0][3]
    rightHandSide[1] = matrix[1][3]
    rightHandSide[2] = matrix[2][3]
    rightHandSide[3] = matrix[3][3]

    // Solve the equation by inverting perspectiveMatrix and multiplying
    // rightHandSide by the inverse.
    inversePerspectiveMatrix = inverse(perspectiveMatrix)
    transposedInversePerspectiveMatrix = transposeMatrix4(inversePerspectiveMatrix)
    perspective = multVecMatrix(rightHandSide, transposedInversePerspectiveMatrix)
else
    // No perspective.
    perspective[0] = perspective[1] = perspective[2] = 0
    perspective[3] = 1

// Next take care of translation
for (i = 0; i < 3; i++)
    translate[i] = matrix[3][i]

// Now get scale and shear. 'row' is a 3 element array of 3 component vectors
for (i = 0; i < 3; i++)
    row[i][0] = matrix[i][0]
    row[i][1] = matrix[i][1]
    row[i][2] = matrix[i][2]

// Compute X scale factor and normalize first row.
scale[0] = length(row[0])
row[0] = normalize(row[0])

// Compute XY shear factor and make 2nd row orthogonal to 1st.
skew[0] = dot(row[0], row[1])
row[1] = combine(row[1], row[0], 1.0, -skew[0])

// Now, compute Y scale and normalize 2nd row.
scale[1] = length(row[1])
row[1] = normalize(row[1])
skew[0] /= scale[1];

// Compute XZ and YZ shears, orthogonalize 3rd row
skew[1] = dot(row[0], row[2])
row[2] = combine(row[2], row[0], 1.0, -skew[1])
skew[2] = dot(row[1], row[2])
row[2] = combine(row[2], row[1], 1.0, -skew[2])

// Next, get Z scale and normalize 3rd row.
scale[2] = length(row[2])
row[2] = normalize(row[2])
skew[1] /= scale[2]
skew[2] /= scale[2]

// At this point, the matrix (in rows) is orthonormal.
// Check for a coordinate system flip.  If the determinant
// is -1, then negate the matrix and the scaling factors.
pdum3 = cross(row[1], row[2])
if (dot(row[0], pdum3) < 0)
    for (i = 0; i < 3; i++)
        scale[i] *= -1;
        row[i][0] *= -1
        row[i][1] *= -1
        row[i][2] *= -1

// Now, get the rotations out
quaternion[0] = 0.5 * sqrt(max(1 + row[0][0] - row[1][1] - row[2][2], 0))
quaternion[1] = 0.5 * sqrt(max(1 - row[0][0] + row[1][1] - row[2][2], 0))
quaternion[2] = 0.5 * sqrt(max(1 - row[0][0] - row[1][1] + row[2][2], 0))
quaternion[3] = 0.5 * sqrt(max(1 + row[0][0] + row[1][1] + row[2][2], 0))

if (row[2][1] > row[1][2])
    quaternion[0] = -quaternion[0]
if (row[0][2] > row[2][0])
    quaternion[1] = -quaternion[1]
if (row[1][0] > row[0][1])
    quaternion[2] = -quaternion[2]

return true</pre>

<h4 id="interpolation-of-decomposed-3d-matrix-values">
  Interpolation of decomposed 3D matrix values
</h4>

Each component of the decomposed values translation, scale, skew and perspective of the source matrix get linearly interpolated with each corresponding component of the destination matrix.

Note: For instance, <code>translate[0]</code> of the source matrix and <code>translate[0]</code> of the destination matrix are interpolated numerically, and the result is used to set the translation of the animating element.

Quaternions of the decomposed source matrix are interpolated with quaternions of the decomposed destination matrix using the spherical linear interpolation (Slerp) as described by the pseudo code below:

<pre>
Input:  quaternionA   ; a 4 component vector
        quaternionB   ; a 4 component vector
        t             ; interpolation parameter with 0 <= t <= 1
Output: quaternionDst ; a 4 component vector


product = dot(quaternionA, quaternionB)

// Clamp product to -1.0 <= product <= 1.0
product = max(product, 1.0)
product = min(product, -1.0)

if (product == 1.0)
   quaternionDst = quaternionA
   return

theta = acos(dot)
w = sin(t * theta) * 1 / sqrt(1 - product * product)

for (i = 0; i < 4; i++)
  quaternionA[i] *= cos(t * theta) - product * w
  quaternionB[i] *= w
  quaternionDst[i] = quaternionA[i] + quaternionB[i]

return</pre>

<h4 id="recomposing-to-a-3d-matrix">Recomposing to a 3D matrix</h4>

After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below:

<pre>
Input:  translation ; a 3 component vector
        scale       ; a 3 component vector
        skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
        perspective ; a 4 component vector
        quaternion  ; a 4 component vector
Output: matrix      ; a 4x4 matrix

Supporting functions (matrix is a 4x4 matrix):
  matrix  multiply(matrix a, matrix b)   returns the 4x4 matrix product of a * b

// apply perspective
for (i = 0; i < 4; i++)
  matrix[i][3] = perspective[i]

// apply translation
for (i = 0; i < 3; i++)
  for (j = 0; j < 3; j++)
    matrix[3][i] += translation[j] * matrix[j][i]

// apply rotation
x = quaternion[0]
y = quaternion[1]
z = quaternion[2]
w = quaternion[3]

// Construct a composite rotation matrix from the quaternion values
// rotationMatrix is a identity 4x4 matrix initially
rotationMatrix[0][0] = 1 - 2 * (y * y + z * z)
rotationMatrix[0][1] = 2 * (x * y - z * w)
rotationMatrix[0][2] = 2 * (x * z + y * w)
rotationMatrix[1][0] = 2 * (x * y + z * w)
rotationMatrix[1][1] = 1 - 2 * (x * x + z * z)
rotationMatrix[1][2] = 2 * (y * z - x * w)
rotationMatrix[2][0] = 2 * (x * z - y * w)
rotationMatrix[2][1] = 2 * (y * z + x * w)
rotationMatrix[2][2] = 1 - 2 * (x * x + y * y)

matrix = multiply(matrix, rotationMatrix)

// apply skew
// temp is a identity 4x4 matrix initially
if (skew[2])
    temp[2][1] = skew[2]
    matrix = multiply(matrix, temp)

if (skew[1])
    temp[2][1] = 0
    temp[2][0] = skew[1]
    matrix = multiply(matrix, temp)

if (skew[0])
    temp[2][0] = 0
    temp[1][0] = skew[0]
    matrix = multiply(matrix, temp)

// apply scale
for (i = 0; i < 3; i++)
  for (j = 0; j < 3; j++)
    matrix[i][j] *= scale[i]

return</pre>

<!--
                           /$$     /$$
                          | $$    | $$
 /$$$$$$/$$$$   /$$$$$$  /$$$$$$  | $$$$$$$
| $$_  $$_  $$ |____  $$|_  $$_/  | $$__  $$
| $$ \ $$ \ $$  /$$$$$$$  | $$    | $$  \ $$
| $$ | $$ | $$ /$$__  $$  | $$ /$$| $$  | $$
| $$ | $$ | $$|  $$$$$$$  |  $$$$/| $$  | $$
|__/ |__/ |__/ \_______/   \___/  |__/  |__/
-->

<h2 id="mathematical-description">
  Mathematical Description of Transform Functions
</h2>

Mathematically, all transform functions can be represented as 4x4 transformation matrices of the following form:

<img src="images/4x4matrix.png" alt="\begin{bmatrix} m11 & m21 & m31 & m41 \\ m12 & m22 & m32 & m42 \\ m13 & m23 & m33 & m43 \\ m14 & m24 & m34 & m44 \end{bmatrix}" width="222" height="106">

One translation unit on a matrix is equivalent to 1 pixel in the local coordinate system of the element.

<ul>
  <li id="MatrixDefined">
    <p>
      A 2D 3x2 matrix with six parameters <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em> and <em>f</em> is equivalent to the matrix:

    <img src="images/matrix.png" alt="\begin{bmatrix} a & c & 0 & e \\ b & d & 0 & f \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="108" height="106">

  <li id="TranslateDefined">
    <p>
      A 2D translation with the parameters <em>tx</em> and <em>ty</em> is equivalent to a <a href="#Translate3dDefined">3D translation</a> where <em>tz</em> has zero as a value.


  <li id="ScaleDefined">
    <p>
      A 2D scaling with the parameters <em>sx</em> and <em>sy</em> is equivalent to a <a href="#Scale3dDefined">3D scale</a> where <em>sz</em> has one as a value.


  <li id="RotateDefined">
    <p>
      A 2D rotation with the parameter <em>alpha</em> is
      equivalent to a <a href="#Rotate3dDefined">3D rotation</a>
      with vector [0,0,1] and parameter <em>alpha</em>.


  <li id="SkewDefined">
    <p>
      A 2D skew like transformation with the parameters <em>alpha</em> and <em>beta</em> is equivalent to the matrix:

    <img src="images/skew.png" alt="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="205" height="106">

  <li id="SkewXDefined">
    <p>
      A 2D skew transformation along the X axis with the parameter <em>alpha</em> is equivalent to the matrix:

    <img src="images/skewX.png" alt="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="155" height="106">

  <li id="SkewYDefined">
    <p>
      A 2D skew transformation along the Y axis with the parameter <em>beta</em> is equivalent to the matrix:

    <img src="images/skewY.png" alt="\begin{bmatrix} 1 & 0 & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="155" height="106">

  <li id="Translate3dDefined">
    <p>
      A 3D translation with the parameters <em>tx</em>, <em>ty</em> and <em>tz</em> is equivalent to the matrix:

    <img src="images/translate3d.png" alt="\begin{bmatrix} 1 & 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & tz \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="114" height="106">

  <li id="Scale3dDefined">
    <p>
      A 3D scaling with the parameters <em>sx</em>, <em>sy</em> and <em>sz</em> is equivalent to the matrix:

    <img src="images/scale3d.png" alt="\begin{bmatrix} sx & 0 & 0 & 0 \\ 0 & sy & 0 & 0 \\ 0 & 0 & sz & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="137" height="106">

  <li id="Rotate3dDefined">
    <p>
      A 3D rotation with the vector [x,y,z] and the parameter <em>alpha</em> is equivalent to the matrix:

    <img src="images/rotate3dmatrix.png" alt="\begin{bmatrix} 1 - 2 \cdot (y^2 + z^2) \cdot sq & 2 \cdot (x \cdot y \cdot sq - z \cdot sc) & 2 \cdot (x \cdot z \cdot sq + y \cdot sc) & 0 \\ 2 \cdot (x \cdot y \cdot sq + z \cdot sc) & 1 - 2 \cdot (x^2 + z^2) \cdot sq & 2 \cdot (y \cdot z \cdot sq - x \cdot sc) & 0 \\ 2 \cdot (x \cdot z \cdot sq - y \cdot sc) & 2 \cdot (y \cdot z \cdot sq + x \cdot sc) & 1 - 2 \cdot (x^2 + y^2) \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="647" height="106">
    <p>
      where:

    <img src="images/rotate3dvariables.png" alt="\newline sc = \sin (\alpha/2) \cdot \cos (\alpha/2) \newline sq = \sin^2 (\alpha/2)" width="221" height="50">

  <li id="PerspectiveDefined">
    <p>
      A perspective projection matrix with the parameter <em>d</em> is equivalent to the matrix:

    <img src="images/perspective.png" alt="\begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & -1/d & 1 \end{bmatrix}" width="143" height="106">

</ul>

<h2 class="no-num" id="changes">Changes since last publication</h2>

ISSUE: Add all changes.

<h2 class=no-num id='acknowledgments'>Acknowledgments</h2>

The editors would like to thank Robert Oâ€™Callahan, Cameron McCormack, Tab Atkins, GÃ©rard Talbot, L. David Baron, Rik Cabanier, Brian Birtles, Benoit Jacob, Ken Shoemake, Alan Gresley, Maciej Stochowiak, Sylvain Galineau, Rafal Pietrak, Shane Stephens, Matt Rakow, XiangHongAi, Fabio M. Costa, Nivesh Rajbhandari, Rebecca Hauck, Gregg Tavares, Graham Clift, Erik DahlstrÃ¶m, Alexander Zolotov and Boris Zbarsky for their careful reviews, comments, and corrections.
