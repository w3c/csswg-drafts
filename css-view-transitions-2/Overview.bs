<pre class='metadata'>
Title: CSS View Transitions Module Level 2
Shortname: css-view-transitions-2
Level: 2
Status: ED
Group: csswg
Date: 2023-05-30
Prepare for TR: yes
ED: https://drafts.csswg.org/css-view-transitions-2/
Work Status: exploring
Editor: Noam Rosenthal, Google, w3cid 121539
Editor: Khushal Sagar, Google, w3cid 122787
Editor: Vladimir Levin, Google, w3cid 75295
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Abstract: This module defines how the View Transition API works with cross-document navigations.
Markup Shorthands: css yes, markdown yes
</pre>

<pre class=link-defaults>
spec:css-view-transitions-1;
	text: active view transition; type: dfn;
	text: capture the old state; type: dfn;
	text: activate view transition; type: dfn;
	text: skip the view transition; type: dfn;
	text: ViewTransition; type: interface;
	text: named elements; for: ViewTransition; type: dfn;
	text: finished promise; for: ViewTransition; type: dfn;
	text: ready promise; for: ViewTransition; type: dfn;
	text: update callback; for: ViewTransition; type: dfn;
	text: update callback done promise; for: ViewTransition; type: dfn;
	text: initial snapshot containing block size; for: ViewTransition; type: dfn;
	text: captured elements; type: dfn;
	text: updateCallbackDone; type: property; for: ViewTransition;
	text: phase; type: dfn; for: ViewTransition;
	text: call the update callback; type: dfn;
	text: perform pending transition operations; type: dfn;
	text: setup view transition; type: dfn;
	text: named view transition pseudo-element; type: dfn;
	text: rendering suppression for view transitions; type: dfn;
spec:dom; type:dfn; text:document
spec:css22; type:dfn; text:element
spec:selectors-4; type:dfn;
	text:selector
	text:type selector
spec:html
	text: latest entry; type: dfn;
	text: was created via cross-origin redirects; type: dfn;
	text: run the animation frame callbacks; type: dfn;
	text: unload; type: dfn;
	text: pagereveal; type: dfn; for: Window;
	text: has been revealed; type: dfn;
spec:infra; type:dfn; text:list
</pre>

<style>
	spec-scaler {
		display: block;
	}
	spec-scaler:not(:defined) > * {
		display: none;
	}
	.spec-slides {
		width: 100%;
		height: 100%;
		border: none;
		display: block;
	}
	.spec-slide-controls {
		text-align: center;
	}
	.main-example-video {
		display: block;
		width: 100%;
		max-width: 702px;
		height: auto;
		margin: 0 auto;
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
		padding: .5em;
		border: thin solid #ddd; border-radius: .5em;
		margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
		margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
		margin-bottom: 0;
	}
	[data-algorithm] [data-algorithm] {
		margin: 1em 0;
	}
	pre {
		tab-size: 2;
	}
</style>
<script async type="module" src="diagrams/resources/scaler.js"></script>

# Introduction # {#intro}

	*This section is non-normative.*

	View Transitions, as specified in [[css-view-transitions-1]], is a feature that allows developers
	to create animated transitions between visual states of the [=/document=].

	Level 2 extends that specification, by adding the necessary API and lifecycle to enable
	transitions across a same-origin cross-document navigation.


## Lifecycle ## {#lifecycle}

	*This section is non-normative.*

	A successful cross-document view transition goes through the following phases:

	1. The user navigates, by clicking a link, submitting a form, traversing history using the
		browser UI, etc.

	1. Once it's time to [=unload=] the old document, if the navigation is [=same origin=]
		and the old {{Document}} has opted in to cross-document view-transitions, the old state is captured.

	1. An event named {{Window/pagereveal}} is fired on the new {{Document}}, with a `viewTransition` property,
		which is a {{ViewTransition}} object. This {{ViewTransition}}'s <code>{{ViewTransition/updateCallbackDone}}</code> is already resolved,
		and its [=captured elements=] are populated from the old {{Document}}.

	1. Right before the new {{Document}} has the first [=rendering opportunity=], its state is captured as
		the "new" state.

	1. From this point forward, the transition continues as if it was a same-document transition, as per [=activate view transition=].

## Examples ## {#examples}

### Cross-document view-transitions ### {#cross-doc-example}

	<div class=example>
		To generate the same cross-fade as in the first example [[css-view-transitions-1#examples]],
		but across documents, we don't need JavaScript.

		Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:

		```css
		// in both documents:
		@view-transition {
			navigation: auto;
		}
		```

		A link from page 1 to or from page 2 would generate a crossfade transition for example 1.
		To achieve the effect examples 2, 3 & 4, simply put the CSS for the pseudo-elements in both
		documents.
	</div>

	<div class="example">
		To achieve the effect in [[css-view-transitions-1#examples|example 5]], we have to do several
		things:

		- Opt-in to navigation-triggered view-transitions in both pages.
		- Pass the click location to the new document, e.g. via {{WindowSessionStorage/sessionStorage}}.
		- Intercept the {{ViewTransition}} object in the new document, using the {{Window/pagereveal}} event.

		In both pages:
		```css
		@view-transition {
			navigation: auto;
		}

		```

		In the old page:
		```js
		addEventListener('click', event => {
			sessionStorage.setItem("lastClickX", event.clientX);
			sessionStorage.setItem("lastClickY", event.clientY);
		});
		```

		In the new page:
		```js
		// This would run both on initial load and on reactivation from BFCache.
		addEventListener("pagereveal", async event => {
			if (!event.viewTransition)
				return;

			const x = sessionStorage.getItem("lastClickX") ?? innerWidth / 2;
			const y = sessionStorage.getItem("lastClickY") ?? innerHeight / 2;

			const endRadius = Math.hypot(
				Math.max(x, innerWidth - x),
				Math.max(y, innerHeight - y)
			);

			await event.viewTransition.ready;

			// Animate the new document's view
			document.documentElement.animate(
				{
					clipPath: [
						`circle(0 at ${x}px ${y}px)`,
						`circle(${endRadius}px at ${x}px ${y}px)`,
					],
				},
				{
					duration: 500,
					easing: 'ease-in',
					pseudoElement: '::view-transition-new(root)'
				}
			);
		})
		```
	</div>

### 'view-transition-class' ### {#vt-class-example}

view-transition-class provides a way to use the same style
for multiple view transition pseudo elements without having to replicate the corresponding pseudo-elements.

	<div class="example">
	This example creates a transition with each box participating under its own name, while applying
	a 1-second duration to the animation of all the boxes:

	```html
	<div class="box" id="red-box"></div>
	<div class="box" id="green-box"></div>
	<div class="box" id="yellow-box"></div>
	```

	```css
	div.box {
		view-transition-class: any-box;
		width: 100px;
		height: 100px;
	}
	#red-box {
		view-transition-name: red-box;
		background: red;
	}
	#green-box {
		view-transition-name: green-box;
		background: green;
	}
	#yellow-box {
		view-transition-name: yellow-box;
		background: yellow;
	}

	/* The following style would apply to all the boxes, thanks to 'view-transition-class' */
	::view-transition-group(*.any-box) {
		animation-duration: 1s;
	}
	```

	</div>


# CSS Properties # {#css-properties}

## Applying the same style to multiple participating elements: the 'view-transition-class' property ## {#view-transition-class-prop}

	<pre class=propdef>
	Name: view-transition-class
	Value: none | <<custom-ident>>*
	Initial: none
	Inherited: no
	Percentages: n/a
	Computed Value: as specified
	Animation type: discrete
	</pre>

	The 'view-transition-class' can be used to apply the same style rule to multiple [=named view transition pseudo-elements=] which may have a different 'view-transition-name'.
	While 'view-transition-name' is used to match between the element in the old state with its corresponding element in the new state, 'view-transition-class' is used
	only to apply styles using the view-transition pseudo-elements
	(''::view-transition-group()'', ''::view-transition-image-pair()'', ''::view-transition-old()'', ''::view-transition-new()'').

	Note that 'view-transition-class' by itself doesn't mark an element for capturing, it is only used as an additional
	way to style an element that already has a 'view-transition-name'.

	<dl dfn-type=value dfn-for=view-transition-class>
		: <dfn>none</dfn>
		:: No class would apply to the [=named view transition pseudo-elements=] generated for this element.

		: <dfn><<custom-ident>>*</dfn>
		:: All of the specified <<custom-ident>> values (apart from <css>none</css>) are applied when used in [=named view transition pseudo-element=] selectors.
			<css>none</css> is an invalid <<custom-ident>> for 'view-transition-class', even when combined with other <<custom-ident>>s.

			Note: If the same 'view-transition-name' is specified for an element both in the old and new states of the transition,
			only the 'view-transition-class' values from the new state apply. This also applies for cross-document view-transitions:
			classes from the old document would only apply if their corresponding 'view-transition-name' was not specified in the new document.
	</dl>

# Pseudo-classes # {#pseudo-classes}

## Active View Transition Pseudo-class '':active-view-transition()''' ## {#the-active-view-transition-pseudo}

The <dfn id='active-view-transition-pseudo'>:active-view-transition(<<vt-type-selector>>)</dfn> pseudo-class applies to the root element of the document, if it has a matching [=active view transition=].
It has the following syntax definition:

<pre class=prod>
	:active-view-transition(<<vt-type-selector>>)
	<dfn>&lt;vt-type-selector></dfn> = '*' | <<custom-ident>>#
</pre>

The [=specificity=] of an '':active-view-transition()'' is one pseudo-class selector if it has value is ''*'', and two if it has any other value.

An '':active-view-transition()'' pseudo-class matches the [=document element=] when it has an non-null [=active view transition=] |viewTransition|, for which any of the following are true:

* The <<vt-type-selector>> is ''*''
* |viewTransition|'s [=ViewTransition/active types=] [=list/contains=] at least one of the <<custom-ident>> values of the <<vt-type-selector>>.

<div class=example>
For example, the developer might start a transition in the following manner:
```js
document.startViewTransition({update: updateTheDOMSomehow, types: ["slide-in", "reverse"]});
```

This will activate any of the following ':active-view-transition()'' selectors:
```css
:root:active-view-transition(slide-in) {}
:root:active-view-transition(reverse) {}
:root:active-view-transition(slide-in, reverse) {}
:root:active-view-transition(slide-in, something-else) {}
:root:active-view-transition(*) {}
```

While starting a transition without selecting transition types, would only activate ':active-view-transition()'' with ''*'':

```js
document.startViewTransition(updateTheDOMSomehow);
// or
document.startViewTransition({update: updateTheDOMSomehow});
```

```css
/* This would be active */
:root { }
:root:active-view-transition(*) {}

/* This would not be active */
:root:active-view-transition(slide-in) {}
:root:active-view-transition(any-type-at-all-except-star) {}
```
</div>

# Additions to named view-transition pseudo-elements # {#pseudo-element-additions}

	The [=named view transition pseudo-elements=]
	(''view-transition-group()'', ''view-transition-image-pair()'', ''view-transition-old()'', ''view-transition-new()'')
	are extended to support the following syntax:

	<pre class=prod>
		::view-transition-group(<<pt-name-selector>><<pt-class-selector>>)
		::view-transition-image-pair(<<pt-name-selector>><<pt-class-selector>>)
		::view-transition-old(<<pt-name-selector>><<pt-class-selector>>)
		::view-transition-new(<<pt-name-selector>><<pt-class-selector>>)
	</pre>

	where <<pt-name-selector>> works as previously defined, and
	<<pt-class-selector>> has the following syntax definition:

	<pre class=prod>
		<dfn>&lt;pt-class-selector></dfn> = ['.' <<custom-ident>>]*
	</pre>

	A [=named view transition pseudo-element=] [=selector=] which has one or more <<custom-ident>> values
	in its <<pt-class-selector>> would only match an element if the [=captured element/class list=] value in
	[=ViewTransition/named elements=] for the pseudo-element's 'view-transition-name' [=list/contains=] all of those values.

	The [=specificity=] of a [=named view transition pseudo-element=] [=selector=] with either:
		* a <<pt-name-selector>> with a <<custom-ident>>; or
		* a <<pt-class-selector>> with at least one <<custom-ident>>,

	is equivalent to a [=type selector=].

	The [=specificity=] of a [=named view transition pseudo-element=] [=selector=]
	with a ''*'' argument and with an empty <<pt-class-selector>> is zero.

# CSS rules # {#css-rules}

## The <dfn id="at-view-transition-rule">''@view-transition''</dfn> rule ## {#view-transition-rule}

The ''@view-transition'' rule is used by a document to indicate that cross-document navigations
should setup and activate a {{ViewTransition}}. To take effect, it must be present in the old document
when unloading, and in the new document when the {{Window/pagereveal}} is fired.


## @view-transition rule grammar ## {#view-transition-grammar}

The ''@view-transition'' rule has the following syntax:

<pre class=prod>
	@view-transition {
		<<declaration-list>>
	}
</pre>

Note: as per default behavior, the ''@view-transition'' rule can be nested inside a
[=conditional group rule=] such as ''@media'' or ''@supports''.

## The [=@view-transition/navigation=] descriptor ## {#view-transition-navigation-descriptor}

	<pre class='descdef'>
	Name: navigation
	For: @view-transition
	Value: auto | none
	Initial: none
	</pre>

	The '<dfn for="@view-transition">navigation</dfn>' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type.
	It needs to be enabled both in the old document (when unloading) and in the new document (when reveal).

	<dl dfn-type=value dfn-for="@view-transition/navigation">
		: <dfn>none</dfn>
		:: There will be no transition.

		: <dfn>auto</dfn>
		:: The transition will be enabled if the navigation is same-origin, without cross-origin
			redirects, and whoes {{NavigationType}} is
			* {{NavigationType/traverse}} or
			* {{NavigationType/push}} or {{NavigationType/replace}} with <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#user-navigation-involvement">user navigation involvement</a> not equal to `"browser UI"`.

			Note: Navigations excluded from ''@view-transition/navigation/auto'' are for example, navigating
			via the URL address bar or clicking a bookmark, as well as any form of user or script initiated {{NavigationType/reload}}.

	</dl>

## The [=@view-transition/type=] descriptor ## {#view-transition-type-descriptor}

	<pre class='descdef'>
	Name: type
	For: @view-transition
	Value: none | <<custom-ident>>*
	Initial: none
	</pre>

	The '<dfn for="@view-transition">type</dfn>' descriptor sets the [=ViewTransition/active types=] for the transition
	when capturing and performing the transition, equivalent to calling {{Document/startViewTransition(callbackOptions)}} with that {{StartViewTransitionOptions/type}}.

# API # {#api}

## Additions to {{Document}} ## {#additions-to-document-api}

	<xmp class=idl>
		dictionary StartViewTransitionOptions {
			UpdateCallback? update = null;
			sequence<DOMString>? type = null;
		};

		partial interface Document {

			ViewTransition startViewTransition(optional (UpdateCallback or StartViewTransitionOptions) callbackOptions = {});
		};
	</xmp>

### {{Document/startViewTransition(callbackOptions)}} Method Steps ### {#ViewTransition-start-with-options}

	<div algorithm="start-vt-with-options">
		The [=method steps=] for <dfn method for=Document>startViewTransition(|callbackOptions|)</dfn> are as follows:

		1. Let |updateCallback| be null.

		1. If |callbackOptions| is an an {{UpdateCallback}}, set |updateCallback| to |callbackOptions|.

		1. Otherwise, if |callbackOptions| is a {{StartViewTransitionOptions}}, then set |updateCallback| to |callbackOptions|'s {{StartViewTransitionOptions/update}}.

		1. If |this|'s [=active view transition=] is not null and its [=outbound post-capture steps=] is not null,
			then:

			1. Let |preSkippedTransition| be a new {{ViewTransition}} in |this|'s [=relevant realm=] whose [=ViewTransition/update callback=] is |updateCallback|.

			1. [=Skip the view transition|Skip=] |preSkippedTransition| with an "{{InvalidStateError}}" {{DOMException}}.

			1. Return |preSkippedTransition|.

		1. Let |viewTransition| be the result of running the [=method steps=] for {{Document/startViewTransition(updateCallback)}} given |updateCallback|.

		1. If |callbackOptions| is a {{StartViewTransitionOptions}}, then set |viewTransition|'s [=ViewTransition/active types=] to |callbackOptions|'s {{StartViewTransitionOptions/type}}.

		1. Return |viewTransition|.
	</div>

## Extensions to the <code>CSSRule</code> interface</h3> ## {#extensions-to-cssrule-interface}

The <code>CSSRule</code> interface is extended as follows:

<pre class='idl'>
partial interface CSSRule {
	const unsigned short VIEW_TRANSITION_RULE = 15;
};
</pre>

## The <code>CSSViewTransitionRule</code> interface</h3> ## {#navgation-behavior-rule-interface}

The {{CSSViewTransitionRule}} represents a ''@view-transition'' rule.

<xmp class=idl>
		enum ViewTransitionNavigation { "auto", "none" };
		[Exposed=Window]
		interface CSSViewTransitionRule : CSSRule {
			attribute ViewTransitionNavigation navigation;
			attribute DOMTokenList typeList;
		};
</xmp>


# Algorithms # {#algorithms}
## Data Structures ## {#concepts}

### Additions to {{Document}} ### {#additions-to-document}
	A {{Document}} additionaly has:

	<dl dfn-for=document>
		: <dfn>inbound view transition params</dfn>
		:: a [=view transition params=], or null.
			Initially null.
	</dl>

### The View transition params struct ### {#view-transition-params-struct}

	A <dfn>view transition params</dfn> is a [=struct=] whose purpose is to serialize view transition information across documents.
	It has the following [=struct/items=]:

	<dl dfn-for="view transition params">
		: <dfn>named elements</dfn>
		:: a [=/map=], whose keys are strings and whose values are [=captured elements=].

		: <dfn>initial snapshot containing block size</dfn>
		:: a [=tuple=] of two numbers (width and height).
	</dl>

### Additions to {{ViewTransition}} ### {#view-transitions-extension}

	A {{ViewTransition}} additionally has:
	<dl dfn-for=ViewTransition>
		: <dfn>outbound post-capture steps</dfn>
		:: Null or a set of steps, initially null.

		: <dfn>active types</dfn>
		:: Null or a [=list=] of strings, initially null.
	</dl>

### Additions to [=captured element=] struct ### {#additions-to-captured-element-struct}

The [=captured element=] struct should contain these fields, in addition to the existing ones:

	<dl>
		: <dfn for="captured element">class list</dfn>
		:: a [=/list=] of strings, initially empty.
	</dl>

## Algorithm to capture 'view-transition-class': ## {#vt-class-algorithms}
<div algorithm="additional capture steps">
When capturing the old or new state for an element, perform the following steps given a [=captured element=] |capture| and an [=element=] |element|:

	1. Set |capture|'s [=captured element/class list=] to the [=computed value=] of |element|'s 'view-transition-class'.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

## Additions to skip steps: ## {#additional-skip-steps}
<div algorithm="additional skip steps">
Append the following steps to [=skip the view transition=] given a {{ViewTransition}} |transition|:
	1. If |transition|'s [=outbound post-capture steps=] is not null, then run |transition|'s [=outbound post-capture steps=] with null.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

## Addition to pending transition operations ## {#additions-to-pending-transition-operation}

Prepend this to the [=Perform pending transition operations=] algorithm given a {{Document}} |document|:
	1. If |document|'s [=active view transition=] is not null and its [=outbound post-capture steps=] is not null, then:

		1. Assert: |document|'s [=active view transition=]'s  [=ViewTransition/phase=] is "`pending-capture`".

		1. Let |viewTransitionParams| be null;

		1. Set |document|'s [=document/rendering suppression for view transitions=] to true.

			Issue: though [=capture the old state=] appears here as a synchronous step, it is in fact an asynchronous step
			as rendering an element into an image cannot be done synchronously. This should be more explicit in the L1 spec.

		1. [=Capture the old state=] for |transition|.

		1. Set |document|'s [=document/rendering suppression for view transitions=] to false.

		1. If this succeeded, then set |viewTransitionParams| to a new [=view transition params=] whose
			[=view transition params/named elements=] is a [=map/clone=] of |transition|'s [=ViewTransition/named elements=],
			and whose [=view transition params/initial snapshot containing block size=] is |transition|'s [=ViewTransition/initial snapshot containing block size=].

		1. Call |transition|'s [=outbound post-capture steps=] given |viewTransitionParams|.


## Monkey patches to HTML ## {#monkey-patch-to-html}

	<div algorithm="monkey patch to apply the history step">
		Prepend these steps at the beginning of the task [=queue a global task|queued=] on |navigable|'s [=active window=]
		when <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#apply-the-history-step">applying the history step</a> (14.11.1, <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#updating-the-traversable:queue-a-global-task-3">here</a>):

		This monkey-patch step assumes a boolean |changingNavigationContinuation|, a [=/navigable=] |navigable|, a {{Document}} |oldDocument|, a {{Document}} |newDocument|, a {{NavigationType}} |navigationType|,
		and a <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#user-navigation-involvement">user navigation involvement</a> |userInvolvementForNavigateEvents|.

		1. Let |isBrowserUINavigation| be true if |userInvolvementForNavigateEvents| is `"browser UI"`, otherwise false.

		1. If |changingNavigationContinuation| update-only is false, then [=setup cross-document view-transition=] given |oldDocument|, |newDocument|, |navigationType|, |isBrowserUINavigation|, and the remaining steps and return from these steps.

		Note: This would wait until a transition is captured or skipped before proceeding to unloading the old document and activating the new one.
	</div>


## Setting up and activating the cross-document view transition ## {#setting-up-and-activating-the-cross-document-view-transition}

### Resolving the ''@view-transition''' rule ### {#resolve-view-transition-rule-algo}

	<div algorithm>
		To get the <dfn>resolve @view-transition rule</dfn> for a {{Document}} |document|:

		1. If |document|'s [=Document/visibility state=] is "<code>hidden</code>",
			then return "<code>skip transition</code>".

		1. Let |matchingRule| be the last ''@view-transition'' rule in |document|.

		1. If |matchingRule| is not found, then return "<code>skip transition</code>".

		1. If |matchingRule|'s [=@view-transition/navigation=] descriptor's [=computed value=] is ''@view-transition/navigation/none'', then return "<code>skip transition</code>".

		1. Assert: |matchingRule|'s [=@view-transition/navigation=] descriptor's [=computed value=] is ''@view-transition/navigation/auto''.

		1. Let |typesDescriptor| be |matchingRule|'s [=@view-transition/type=] descriptor.

		1. If |typesDescriptor|'s [=computed value=] is ''@view-transition/type/none'', then return a [=/list=] « ».

		1. Return a [=list=] of strings corresponding to |typesDescriptor|'s [=computed value=].
	</div>

### Setting up the view-transition in the old {{Document}} ###  {#setup-old-document-vt}

	<div algorithm>
		To check if a <dfn export>navigation can trigger a cross-document view-transition?</dfn> given
		an [=/origin=] |oldOrigin|, an [=/origin=] |newOrigin|, a boolean |navigationHasCrossOriginRedirects|, a {{NavigationType}} |navigationType|, and a boolean |isBrowserUINavigation|:

			Note: this is called during navigation, potentially [=in parallel=], for documents that have opted-in to view-transitions using the ''@view-transition'' rule.

		1. If the user agent decides to display an [=implementation-defined=] navigation experience, e.g. a gesture-based transition for a back navigation,
			the user agent may ignore the author-defined view transition. If that is the case, return false.

		1. If |navigationType| is {{NavigationType/reload}}, then return false.

		1. If |isBrowserUINavigation| is true, and |navigationType| is {{NavigationType/push}} or {{NavigationType/replace}}, then return false.

		1. If |oldOrigin| is not [=same origin=] as |newOrigin| then return false.

		1. If |navigationHasCrossOriginRedirects| is true, then return false.

		1. Return true.
	</div>
	<div algorithm>
		To <dfn export>setup cross-document view-transition</dfn> given a {{Document}} |oldDocument|,
		a {{Document}} |newDocument|, and |proceedWithNavigation|, which is an algorithm accepting nothing:

		1. [=Assert=]: These steps are running as part of a [=task=] queued on |oldDocument|.

		1. If |oldDocument|'s [=has been revealed=] is false, then return null.

		1. Let |resolvedRule| be the result of [=Resolve @view-transition rule|resolving the @view-transition rule=] for |oldDocument|.

		1. If |resolvedRule| is "<code>skip transition</code>", then return null.

			Note: We don't know yet if |newDocument| has opted in, as it might not be parsed yet.
			We check the opt-in for |newDocument| when we fire the {{Window/pagereveal}} event.

		1. If |oldDocument|'s [=active view transition=] is not null,
			then [=skip the view transition|skip=] |oldDocument|'s [=active view transition=]
			with an "{{AbortError}}" {{DOMException}} in |oldDocument|'s [=relevant Realm=].

			Note: this means that any running transition would be skipped when the document is ready
			to unload.

		1. Let |outboundTransition| be a new {{ViewTransition}} object in |oldDocument|'s [=relevant Realm=],
			whose [=ViewTransition/active types=] is |resolvedRule|.

			Note: the {{ViewTransition}} is skipped once the old document is hidden.

		1. Set |outboundTransition|'s [=outbound post-capture steps=] to the following steps given a [=view transition params=]-or-null |params|:
			1. Set |newDocument|'s [=inbound view transition params=] to |params|.

				Note: The inbound transition is activated after the dispatch of {{Window/pagereveal}} to ensure mutations made in this event apply to the captured new state.

			1. Call |proceedWithNavigation|.

		1. Set |oldDocument|'s [=active view transition=] to |outboundTransition|.

			Note: The process continues in [=perform pending transition operations=].

		1. The user agent should display the currently displayed frame until either:
			* The {{Window/pagereveal}} event is fired.
			* its [=active view transition=]'s [=ViewTransition/phase=] is "`done`".

			Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.

		1. Return |outboundTransition|.
	</div>

### Accessing the view-transition in the new {{Document}} ### {#access-view-transition-in-new-doc}

	<div algorithm>
		To <dfn export>resolve cross-document view-transition</dfn> for {{Document}} |document|:

		1. [=Assert=]: |document| is [=fully active=].

		1. Let |inboundViewTransitionParams| be |document|'s [=inbound view transition params=].

		1. If |inboundViewTransitionParams| is null, then return null.

		1. Set |document|'s [=inbound view transition params=] to null.

		1. If |document|'s [=active view transition=] is not null, then return null.

			Note: this means that starting a same-document transition before revealing the document would cancel a pending cross-document transition.

		1. [=Resolve @view-transition rule=] for |document| and let |resolvedRule| be the result.

		1. If |resolvedRule| is "<code>skip transition</code>", then return null.

		1. Let |transition| be a new {{ViewTransition}} in |document|'s [=relevant Realm=],
			whose [=ViewTransition/named elements=] is |inboundViewTransitionParams|'s [=view transition params/named elements=],
			and [=ViewTransition/initial snapshot containing block size=] is |inboundViewTransitionParams|'s [=view transition params/initial snapshot containing block size=].

		1. Set |document|'s [=active view transition=] to |transition|.

		1. [=Resolve=] |transition|’s [=ViewTransition/update callback done promise=] with undefined.

		1. Set |transition|’s [=ViewTransition/phase=] to "`update-callback-called`".

		1. Set |transition|'s [=ViewTransition/active types=] to |resolvedRule|.

		1. At any given time, the UA may decide to skip the inbound transition, e.g. after an [=implementation-defined=] timeout.
			To do so, the UA should [=queue a global task=] on the [=DOM manipulation task source=] given |document|'s [=relevant global object=] to perform the following step:
				If |transition|'s [=ViewTransition/phase=] is not "`done`", then [=skip the view transition=] |transition| with a "{{TimeoutError}}" {{DOMException}}.

		1. Return |transition|.
	</div>


<h2 id="priv" class="no-num">Privacy Considerations</h2>

This specification introduces no new privacy considerations.

<h2 id="sec" class="no-num">Security Considerations</h2>

To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for
same-origin navigations. As discussed in <a href="https://github.com/WICG/view-transitions/issues/200">WICG/view-transitions#200</a>,
this still presents two potential threats:

1. The [=environment settings object/cross-origin isolated capability=] in both documents might be different.
	This can cause a situation where a {{Document}} that is [=environment settings object/cross-origin isolated capability|cross-origin isolated=]
	can read image data from a document that is not cross-origin isolated. This is already mitigated in [[css-view-transitions-1#sec],
	as the same restriction applies for captured cross-origin iframes.

1. A same-origin navigation might still occur via a cross-origin redirect, e.g. <code>https://example.com</code>
	links to <code>https://auth-provider.com/</code> which redirects back to <code>https://example.com/loggedin</code>.

	This can cause a (minor) situation where the cross-origin party would redirect the user to an
	unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect.
	To mitigate this, currently view transitions are disabled for navigations if the {{Document}} [=was created via cross-origin redirects=].
	Note that this check doesn't apply when the {{Document}} is being [=Document/reactivated=], as in that case
	the cross-origin redirect has already taken place.

	Note: this only applies to server-side redirects. A client-side redirect, e.g. using
	[^meta/http-equiv/refresh^], is equivalent to a new navigation.

1. This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related.
	This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come
	from trusted sources to begin with, as CSS can learn about the document or change it in many ways.


See <a href="https://github.com/w3c/csswg-drafts/issues/8684">Issue #8684</a> and
<a href="https://github.com/WICG/view-transitions/issues/200">WICG/view-transitions#200</a> for
detailed discussion.
