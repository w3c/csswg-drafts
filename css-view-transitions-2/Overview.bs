<pre class='metadata'>
Title: CSS View Transitions Module Level 2
Shortname: css-view-transitions
Level: 2
Status: FPWD
Group: csswg
Date: 2024-05-09
Prepare for TR: yes
ED: https://drafts.csswg.org/css-view-transitions-2/
TR: https://www.w3.org/TR/css-view-transitions-2/
Work Status: exploring
Editor: Noam Rosenthal, Google, w3cid 121539
Editor: Khushal Sagar, Google, w3cid 122787
Editor: Vladimir Levin, Google, w3cid 75295
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Abstract: This module defines how the View Transition API works with cross-document navigations.
Markup Shorthands: css yes, markdown yes
</pre>

<pre class=link-defaults>
spec:css-view-transitions-1;
	text: active view transition; type: dfn;
	text: capture the new state; type: dfn;
	text: capture the old state; type: dfn;
	text: activate view transition; type: dfn;
	text: skip the view transition; type: dfn;
	text: ViewTransition; type: interface;
	text: named elements; for: ViewTransition; type: dfn;
	text: finished promise; for: ViewTransition; type: dfn;
	text: ready promise; for: ViewTransition; type: dfn;
	text: update callback; for: ViewTransition; type: dfn;
	text: update callback done promise; for: ViewTransition; type: dfn;
	text: initial snapshot containing block size; for: ViewTransition; type: dfn;
	text: captured elements; type: dfn;
	text: updateCallbackDone; type: property; for: ViewTransition;
	text: phase; type: dfn; for: ViewTransition;
	text: call the update callback; type: dfn;
	text: perform pending transition operations; type: dfn;
	text: setup view transition; type: dfn;
	text: named view transition pseudo-element; type: dfn;
	text: rendering suppression for view transitions; type: dfn;
spec:dom; type:dfn; text:document
spec:css22; type:dfn; text:element
spec:selectors-4; type:dfn;
	text:selector
	text:type selector
spec:html
	text: latest entry; type: dfn;
	text: was created via cross-origin redirects; type: dfn;
	text: run the animation frame callbacks; type: dfn;
	text: deactivate a document for a cross-document navigation; type: dfn;
	text: pagereveal; type: dfn; for: Window;
	text: has been revealed; type: dfn;
	text: render-blocking mechanism; type: dfn;
spec:infra; type:dfn; text:list
</pre>

<style>
	spec-scaler {
		display: block;
	}
	spec-scaler:not(:defined) > * {
		display: none;
	}
	.spec-slides {
		width: 100%;
		height: 100%;
		border: none;
		display: block;
	}
	.spec-slide-controls {
		text-align: center;
	}
	.main-example-video {
		display: block;
		width: 100%;
		max-width: 702px;
		height: auto;
		margin: 0 auto;
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
		padding: .5em;
		border: thin solid #ddd; border-radius: .5em;
		margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
		margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
		margin-bottom: 0;
	}
	[data-algorithm] [data-algorithm] {
		margin: 1em 0;
	}
	pre {
		tab-size: 2;
	}
</style>
<script async type="module" src="diagrams/resources/scaler.js"></script>

# Introduction # {#intro}

	*This section is non-normative.*

	View Transitions, as specified in [[css-view-transitions-1]], is a feature that allows developers
	to create animated transitions between visual states of the [=/document=].

	Level 2 extends that specification, by adding the necessary API and lifecycle to enable
	transitions across a same-origin cross-document navigation, as well as a few additions that
	make it easier to author pages with richer view transitions.

	Level 2 defines the following:

		* <a href="#cross-document-view-transitions">Cross-document view transitions</a>, including the ''@view-transition'' rule and the algorithms
			that enable the cross-document view transition lifecycle.
		* <a href="#selective-vt">Selective view transitions</a>, a way to match styles based on the existence of an [=active view transition=],
			and more specifically based on the active view transition being of a certain type.
		* <a href="#shared-style-with-vt-classes">Sharing styles between view transition pseudo-elements</a>, a way to declare a style once,
			and use it for multiple view transition pseudo-elements. This includes the 'view-transition-class' property, and <a href="#pseudo-element-class-additions">additions to named pseudo-elements</a>

# Cross-document view transitions # {#cross-document-view-transitions}

## Overview ## {#cross-doc-overview}

*This section is non-normative.*

### Activation ### {#activating-cross-document-view-transition}
With same-document view transitions, the author starts a view transition using JavaScript, by calling {{Document/startViewTransition}}.
In cross-document view transition, what triggers a view transition is a navigation between two documents, as long as the following conditions are met:

	* Both documents are of the [=same origin=];
	* The page is visible throughout the entire course of the navigation;
	* The user initiates the navigation by interacting with the page, e.g. by clicking a link or submitting a form; or by interacting with the browser UI to do a {{NavigationType/traverse}} navigation (back/forward). This excludes, for example, navigations initiated by the URL bar;
	* the navigation didn't include cross-origin redirects; and
	* both documents opted in to cross-document view transitions, using the ''@view-transition'' rule.

See the <a href="#lifecycle">lifecycle</a> section for more details.

### Waiting for the new state to stabilize ### {#waiting-for-stable-state}
In same-document view transitions, the author can indicate when the new state of the transition is in a stable state by using the callback passed to {{Document/startViewTransition}}.
Since cross-document view transitions are declarative, there is no such explicit promise. Instead, the user agent relies on the [=render-blocking mechanism=] to decide when the document has reached a stable state.
In this way, the author can use the the <code data-x="">blocking</code> attribute, to delay the transition until:
	* All expected scripts are executed, by using the script's {{HTMLScriptElement/blocking}} attribute on required scripts.
	* All expected styles are executed, by using the style or link's {{HTMLStyleElement/blocking}} attribute on required styles.
	* All expected HTML elements are seen by the parser, using an <{link/rel/expect}> {{HTMLLinkElement}} element.

Note: overusing the render-blocking mechanism could make it so that the old state remains frozen for a long time, resulting in a jarring user experience.
To avoid this, it's advised to ensure that the render-blocking elements are available in a timely manner.

<div class="example">

In this example, the last frame of the old document will be shown, and the animation will be delayed, until all the following conditions are met:
- `style.css` is applied, to ensure the new state has the correct styles
- `fixup.js` is run, to ensure the presentation is up to date with script-based fixups.
- The `main-article` section is seen and parsed, to ensure enough of the content is loaded before allowing the transition to proceed.

```html
<!DOCTYPE html>
<html>
	<head>
		< !-- This will be render-blocking by default -->
		<link rel="stylesheet" href="style.css">

		< !-- Since this script fixes up the layout, marking it as render blocking will
			  ensure it's run before the view transition is activated -->
		<script async href="fixup.js" blocking="render"></script>

		< !-- Wait until the main-article element is seen and fully parsed before
			  activating the transition -->
		<link rel="expect" href="#main-article" blocking="render">
	</head>
	<body>
		<header>...</header>
		<main>
			<article id="main-article">...</article>
		</main>
		<article id="secondary-article">...</article>
	</body>
</html>
```
</div>

### Customization ### {#customizing-cross-document-view-transitions}
The {{ViewTransition}} object enables customizing the transition in script.
Same-document view transitions use a single {{ViewTransition}} object returned from the {{Document/startViewTransition}} call for the entire lifecycle.
Cross-document view transitions have two {{ViewTransition}} objects, one in the old document and one in the new document.

#### Handling the view transition in the old document #### {#old-doc-event}

The {{Window/pageswap}} event is fired at the last moment before a document is about to be unloaded and swapped by another document.
It can be used to find out whether a view transition is about to take place, customize it using {{ViewTransition/types}}, make last minute changes to the captured elements, or skip it if necessary.
The {{PageSwapEvent}} interface has a {{PageSwapEvent/viewTransition}} object, which would be non-null when the navigation is eligible to a view transition,
and a {{PageSwapEvent/activation}} object, providing handy information about the navigation, like the URL after redirects.
The transition's {{ViewTransition/finished}} promise can be used for cleaning up after the transition, in case the document is later restored from BFCache.

#### Handling the view transition in the new document #### {#new-doc-event}

The {{Window/pagereveal}} event is fired right before presenting the first frame of the new document.
It can be used to find out if the view transition is still valid, by querying the {{PageRevealEvent/viewTransition}} attribute.
Similar to a same-document view transition, the author can now select different {{ViewTransition/types}}, make last minute changes to the captured elements, wait for the transition to be {{ViewTransition/ready}} in order to animate it, or skip it altogether.

### Lifecycle ### {#lifecycle}

	*This section is non-normative.*

	A successful cross-document view transition goes through the following phases:

	1. In the old {{Document}}:

		1. The user initiates a navigation, by clicking a link, submitting a form, pressing the browser's back button, etc.

			Note: some navigations do not trigger a view-transition, e.g. typing a new address in the URL bar.

		1. When the new {{Document}} is ready to be activated, the {{Window/pageswap}} event is fired.

		1. If the navigation is [=same origin=], has no cross-origin redirects,
			and the old {{Document}} has <a href="#cross-doc-opt-in">opted in to cross-document view transitions</a>, the event's {{PageSwapEvent/viewTransition}} attribute would be
			a {{ViewTransition}} object.

		1. The author can now customize the transition, e.g. by mutating its {{ViewTransition/types}}, or {{ViewTransition/skipTransition()|skip}} it altogether.

		1. If the {{ViewTransition}} is not skipped, the state of the old document is [=capture the old state|captured=].

		1. The navigation proceeds: the old {{Document}} is unloaded, and the new {{Document}} is now active.

	1. Then, in the new {{Document}}:

		1. When the new {{Document}} is ready for its first [=rendering opportunity=], an event named {{Window/pagereveal}} is fired on the new {{Document}}, with a {{PageRevealEvent/viewTransition}} attribute.

		1. This {{ViewTransition}}'s <code>{{ViewTransition/updateCallbackDone}}</code> promise is already resolved,
			and its [=captured elements=] are populated from the old {{Document}}.

		1. This is another opportunity for the author to customize the transition, e.g. by mutating its {{ViewTransition/types}}, or {{ViewTransition/skipTransition()|skip}} it altogether.

		1. The state of the new document is [=capture the new state|captured=] as the "new" state of the transition.

		1. From this point forward, the transition continues in a similar fashion to a same-document transition, as per [=activate view transition=].

## Examples ## {#cross-doc-examples}

<div class=example>
	To generate the same cross-fade as in the first example [[css-view-transitions-1#examples]],
	but across documents, we don't need JavaScript.

	Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:

	```css
	// in both documents:
	@view-transition {
		navigation: auto;
	}
	```

	A link from page 1 to or from page 2 would generate a crossfade transition for example 1.
	To achieve the effect examples 2, 3 & 4, simply put the CSS for the pseudo-elements in both
	documents.
</div>

<div class=example>
	Note that the ''@view-transition'' rule can be used together with media queries.
	For example, this would only perform the transition when the screen width is greater than:

	```css
	@view-transition {
		navigation: auto;
	}

	@media (max-width: 600px) {
		navigation: none;
	}
	```
</div>

<div class="example">
	To achieve the effect in [[css-view-transitions-1#examples|example 5]], we have to do several
	things:

	- Opt-in to navigation-triggered view-transitions in both pages.
	- Pass the click location to the new document, e.g. via {{WindowSessionStorage/sessionStorage}}.
	- Intercept the {{ViewTransition}} object in the new document, using the {{Window/pagereveal}} event.

	In both pages:
	```css
	@view-transition {
		navigation: auto;
	}

	```
	In the old page:
	```js
	addEventListener('click', event => {
		sessionStorage.setItem("lastClickX", event.clientX);
		sessionStorage.setItem("lastClickY", event.clientY);
	});
	```

	In the new page:
	```js
	// This would run both on initial load and on reactivation from BFCache.
	addEventListener("pagereveal", async event => {
		if (!event.viewTransition)
			return;

		const x = sessionStorage.getItem("lastClickX") ?? innerWidth / 2;
		const y = sessionStorage.getItem("lastClickY") ?? innerHeight / 2;

		const endRadius = Math.hypot(
			Math.max(x, innerWidth - x),
			Math.max(y, innerHeight - y)
		);

		await event.viewTransition.ready;

		// Animate the new document's view
		document.documentElement.animate(
			{
				clipPath: [
					`circle(0 at ${x}px ${y}px)`,
					`circle(${endRadius}px at ${x}px ${y}px)`,
				],
			},
			{
				duration: 500,
				easing: 'ease-in',
				pseudoElement: '::view-transition-new(root)'
			}
		);
	})
	```
</div>

<div class="example">
	To choose which elements are captured based on properties of the navigation, and whether certain images are loaded:

	In the old page:
	```js
		window.addEventListener("pageswap", event => {
			// For example, the page was hidden, or the navigation is cross-document.
			if (!event.viewTransition)
				return;

			// If you don't want view transition for back/forward navigations...
			if (event.activation.navigationType === "traverse") {
				event.viewTransition.skipTransition();
			}

			const newURL = new URL(event.activation.entry.url);
			if (newURL.pathname === "/details" && thumbnail.complete) {
				thumbnail.classList.add("transition-to-hero");

				// This will cleanup the state if the page is restored from BFCache.
				event.viewTransition.finished.then(() => {
					thumbnail.classList.remove("transition-to-hero");
				});
			}

		});
	```

	In the new page:
	```js
		window.addEventListener("pagereveal", event => {
			// For example, the page was hidden, the navigation is cross-document, or the transition was skipped in the old document.
			if (!event.viewTransition)
				return;

			const oldURL = new URL(navigation.activation.from.url);
			if (newURL.pathname === "/list") {
				event.viewTransition.types.add("coming-from-list");

				// This will show the thumbnail until the view transition is finished.
				if (!hero.complete) {
					setToThumbnail(hero);
					event.viewTransition.finished.then(() => {
						setToFullResolution(hero);
					})
				}
			}
		});
	```
</div>

## Opting in to cross-document view transitions ## {#cross-doc-opt-in}

### The <dfn id="at-view-transition-rule">''@view-transition''</dfn> rule ### {#view-transition-rule}

The ''@view-transition'' rule is used by a document to indicate that cross-document navigations
should setup and activate a {{ViewTransition}}.

The ''@view-transition'' rule has the following syntax:

<pre class=prod>
	@view-transition {
		<<declaration-list>>
	}
</pre>

The ''@view-transition'' rule accepts the [=@view-transition/navigation=] and [=@view-transition/types=] descriptors.

Note: as per default behavior, the ''@view-transition'' rule can be nested inside a
[=conditional group rule=] such as ''@media'' or ''@supports''.

When the ''@view-transition'' rule changes for {{Document}} |document|, the user agent must [=update the opt-in state for outbound transitions=] given |document|.

Note: this needs to be cached in the boolean because the result needs to be read [=in parallel=], when navigating.

### The [=@view-transition/navigation=] descriptor ### {#view-transition-navigation-descriptor}

	<pre class='descdef'>
	Name: navigation
	For: @view-transition
	Value: auto | none
	Initial: none
	</pre>

	The '<dfn for="@view-transition">navigation</dfn>' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type.
	Must be present on both the old and new document.

	<dl dfn-type=value dfn-for="@view-transition/navigation">
		: <dfn>none</dfn>
		:: There will be no transition.

		: <dfn>auto</dfn>
		:: The transition will be enabled if the navigation is same-origin, without cross-origin
			redirects, and whose {{NavigationType}} is
			* {{NavigationType/traverse}}, or
			* {{NavigationType/push}} or {{NavigationType/replace}}, with <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#user-navigation-involvement">user navigation involvement</a> not equal to `"browser UI"`.

			Note: Navigations excluded from ''@view-transition/navigation/auto'' are for example, navigating
			via the URL address bar or clicking a bookmark, as well as any form of user or script initiated {{NavigationType/reload}}.
	</dl>

### Accessing the ''@view-transition'' rule using CSSOM ### {#cssom}

The <code>CSSRule</code> interface is extended as follows:

<pre class='idl'>
partial interface CSSRule {
	const unsigned short VIEW_TRANSITION_RULE = 15;
};
</pre>

The {{CSSViewTransitionRule}} represents a ''@view-transition'' rule.

<xmp class=idl>
		enum ViewTransitionNavigation { "auto", "none" };

		[Exposed=Window]
		interface CSSViewTransitionRule : CSSRule {
			readonly attribute ViewTransitionNavigation navigation;
			[SameObject] readonly attribute FrozenArray<CSSOMString> types;
		};
</xmp>

# Selective view transitions # {#selective-vt}

## Overview ## {#selective-vt-overview}

*This section is non-normative.*

For simple pages, with a single view transition, setting the ''view-transition-name'' property on participating elements should be sufficient.
However, in more complex scenarios, the author might want to declare various view transitions, and only run one of them simultaneously.
For example, sliding the whole page when clicking on the navigation bar, and sorting a list when one if its items is dragged.

To make sure each view transition only captures what it needs to, and different transitions don't interfere with each other,
this spec introduces the concept of [=active types=], alongside the '':active-view-transition'' and '':active-view-transition-type()'' pseudo-classes.

'':active-view-transition'' matches the [=document element=] when it has an [=active view transition=], and '':active-view-transition-type()''
matches the [=document element=] if the types in the selectors match the [=active view transition=]'s [=ViewTransition/active types=].

The {{ViewTransition}}'s [=active types=] are populated in one of the following ways:

	1. Passed as part of the arguments to {{Document/startViewTransition(callbackOptions)}}
	1. Mutated at any time, using the transition's {{ViewTransition/types}}
	1. Declared for a cross-document view transition, using the [=@view-transition/types=] descriptor.

## Examples ## {#active-view-transition-pseudo-examples}

<div class=example>
For example, the developer might start a transition in the following manner:
```js
document.startViewTransition({update: updateTheDOMSomehow, types: ["slide-in", "reverse"]});
```

This will activate any of the following selectors:
```css
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(reverse) {}
:root:active-view-transition-type(slide-in, reverse) {}
:root:active-view-transition-type(slide-in, something-else) {}
:root:active-view-transition {}
```

While starting a transition without providing transition types, would only activate ':active-view-transition'':

```js
document.startViewTransition(updateTheDOMSomehow);
// or
document.startViewTransition({update: updateTheDOMSomehow});
```

```css
/* This would be active */
:root { }
:root:active-view-transition {}

/* This would not be active */
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(any-type-at-all-except-star) {}
```
</div>

## Selecting based on the active view transition ## {#pseudo-classes-for-selective-vt}
### The '':active-view-transition'' pseudo-class ### {#the-active-view-transition-pseudo}

The <dfn id='active-view-transition-pseudo'>:active-view-transition</dfn> pseudo-class applies to the root element of the document, if it has an [=active view transition=].

The [=specificity=] of an '':active-view-transition'' is one pseudo-class selector.

An '':active-view-transition'' pseudo-class matches the [=document element=] when its [=node document=] has an non-null [=active view transition=].

### The '':active-view-transition-type()'' pseudo-class ### {#the-active-view-transition-type-pseudo}

The <dfn id='active-view-transition-type-pseudo'>:active-view-transition-type()</dfn> pseudo-class applies to the root element of the document, if it has a matching [=active view transition=].
It has the following syntax definition:

<pre class=prod>
	:active-view-transition-type(<<custom-ident>>#)
</pre>

The [=specificity=] of an '':active-view-transition-type()'' is one pseudo-class selector.

An '':active-view-transition-type()'' pseudo-class matches the [=document element=] when its [=node document=] has an non-null [=active view transition=],
whose [=ViewTransition/active types=] [=list/contains=] at least one of the <<custom-ident>> arguments.

## Changing the types of an ongoing view transition ## {#view-transitions-extension-types}

The {{ViewTransition}} interface is extended as follows:

<xmp class='idl'>
[Exposed=Window]
interface ViewTransitionTypeSet {
	setlike<DOMString>;
};

[Exposed=Window]
partial interface ViewTransition {
	attribute ViewTransitionTypeSet types;
};
</xmp>

The {{ViewTransitionTypeSet}} object represents a [=/set=] of strings, without special semantics.

Note: a {{ViewTransitionTypeSet}} can contain strings that are invalid for '':active-view-transition-type'', e.g.
strings that are not a <<custom-ident>>.

The {{ViewTransition/types}} [=getter steps=] are to return [=this=]'s [=ViewTransition/active types=].

## Activating the transition type for cross-document view transitions ## {#types-cross-doc}

The [=@view-transition/types=] descriptor

	<pre class='descdef'>
	Name: types
	For: @view-transition
	Value: none | <<custom-ident>>+
	Initial: none
	</pre>

	The '<dfn for="@view-transition">types</dfn>' descriptor sets the [=ViewTransition/active types=] for the transition
	when capturing or performing the transition, equivalent to calling {{Document/startViewTransition(callbackOptions)}} with that {{StartViewTransitionOptions/types}}.

	Note: the [=@view-transition/types=] descriptor only applies to the {{Document}} in which it is defined.
	The author is responsible for using their chosen set of types in both documents.

# Sharing styles between view transition pseudo-elements # {#shared-style-with-vt-classes}

## Overview ## {#shared-style-overview}

*This section is non-normative.*

When styling multiple elements in the DOM in a similar way, it is common to use the [=Element/class=] attribute:
setting a name that's shared across multiple elements, and then using the [=class selector=] to declare the shared style.

[=Named view transition pseudo-elements|The view transition pseudo-elements=] (e.g. ''view-transition-group()'') are not defined in the DOM, but rather by using the ''view-transition-name'' property.
For that purpose, the ''view-transition-class''' CSS property provides view transitions with the equivalent of HTML [=Element/class|classes=].
When an element with a ''view-transition-name'' also has a ''view-transition-class'' value, that class would be selectable by the pseudo-elements, as per the <a href="#vt-class-example">examples</a>.

## Examples ## {#vt-class-example}

<div class="example">
This example creates a transition with each box participating under its own name, while applying
a 1-second duration to the animation of all the boxes:

```html
<div class="box" id="red-box"></div>
<div class="box" id="green-box"></div>
<div class="box" id="yellow-box"></div>
```

```css
div.box {
	view-transition-class: any-box;
	width: 100px;
	height: 100px;
}
#red-box {
	view-transition-name: red-box;
	background: red;
}
#green-box {
	view-transition-name: green-box;
	background: green;
}
#yellow-box {
	view-transition-name: yellow-box;
	background: yellow;
}

/* The following style would apply to all the boxes, thanks to 'view-transition-class' */
::view-transition-group(*.any-box) {
	animation-duration: 1s;
}
```
</div>

## The 'view-transition-class' property ## {#view-transition-class-prop}

	<pre class=propdef>
	Name: view-transition-class
	Value: none | <<custom-ident>>+
	Initial: none
	Inherited: no
	Percentages: n/a
	Computed Value: as specified
	Animation type: discrete
	</pre>

	The 'view-transition-class' can be used to apply the same style rule to multiple [=named view transition pseudo-elements=] which may have a different 'view-transition-name'.
	While 'view-transition-name' is used to match between the element in the old state with its corresponding element in the new state, 'view-transition-class' is used
	only to apply styles using the view transitionpseudo-elements
	(''::view-transition-group()'', ''::view-transition-image-pair()'', ''::view-transition-old()'', ''::view-transition-new()'').

	Note that 'view-transition-class' by itself doesn't mark an element for capturing, it is only used as an additional
	way to style an element that already has a 'view-transition-name'.

	<dl dfn-type=value dfn-for=view-transition-class>
		: <dfn>none</dfn>
		:: No class would apply to the [=named view transition pseudo-elements=] generated for this element.

		: <dfn><<custom-ident>>+</dfn>
		:: All of the specified <<custom-ident>> values (apart from <css>none</css>) are applied when used in [=named view transition pseudo-element=] selectors.
			<css>none</css> is an invalid <<custom-ident>> for 'view-transition-class', even when combined with another <<custom-ident>>.

			Note: If the same 'view-transition-name' is specified for an element both in the old and new states of the transition,
			only the 'view-transition-class' values from the new state apply. This also applies for cross-document view transitions:
			classes from the old document would only apply if their corresponding 'view-transition-name' was not specified in the new document.
	</dl>

## Additions to named view transition pseudo-elements ## {#pseudo-element-class-additions}

	The [=named view transition pseudo-elements=]
	(''view-transition-group()'', ''view-transition-image-pair()'', ''view-transition-old()'', ''view-transition-new()'')
	are extended to support the following syntax:

	<pre class=prod>
		::view-transition-group(<<pt-name-and-class-selector>>)
		::view-transition-image-pair(<<pt-name-and-class-selector>>)
		::view-transition-old(<<pt-name-and-class-selector>>)
		::view-transition-new(<<pt-name-and-class-selector>>)
	</pre>

	where <<pt-name-selector>> works as previously defined, and
	<<pt-name-and-class-selector>> has the following syntax definition:

	<pre class=prod>
		<dfn>&lt;pt-name-and-class-selector></dfn> = <<pt-name-selector>> <<pt-class-selector>>? | <<pt-class-selector>>
		<dfn>&lt;pt-class-selector></dfn> = ['.' <<custom-ident>>]+
	</pre>

	When interpreting the above grammar, white space is forbidden:

		* Between <<pt-name-selector>> and <<pt-class-selector>>
		* Between any of the components of <<pt-class-selector>>.

	A [=named view transition pseudo-element=] [=selector=] which has one or more <<custom-ident>> values
	in its <<pt-class-selector>> would only match an element if the [=captured element/class list=] value in
	[=ViewTransition/named elements=] for the pseudo-element's 'view-transition-name' [=list/contains=] all of those values.

	The [=specificity=] of a [=named view transition pseudo-element=] [=selector=] with either:
		* a <<pt-name-selector>> with a <<custom-ident>>; or
		* a <<pt-class-selector>> with at least one <<custom-ident>>,

	is equivalent to a [=type selector=].

	The [=specificity=] of a [=named view transition pseudo-element=] [=selector=]
	with a ''*'' argument and with an empty <<pt-class-selector>> is zero.

# Extending {{Document/startViewTransition|document.startViewTransition()}} # {#extend-document-types}
	<xmp class=idl>
		dictionary StartViewTransitionOptions {
			UpdateCallback? update = null;
			sequence<DOMString>? types = null;
		};

		partial interface Document {

			ViewTransition startViewTransition(optional (UpdateCallback or StartViewTransitionOptions) callbackOptions = {});
		};
	</xmp>


	<div algorithm="start-vt-with-options">
		The [=method steps=] for <dfn method for=Document>startViewTransition(|callbackOptions|)</dfn> are as follows:

		1. Let |updateCallback| be null.

		1. If |callbackOptions| is an an {{UpdateCallback}}, set |updateCallback| to |callbackOptions|.

		1. Otherwise, if |callbackOptions| is a {{StartViewTransitionOptions}}, then set |updateCallback| to |callbackOptions|'s {{StartViewTransitionOptions/update}}.

		1. If |this|'s [=active view transition=] is not null and its [=outbound post-capture steps=] is not null,
			then:

			1. Let |preSkippedTransition| be a new {{ViewTransition}} in |this|'s [=relevant realm=] whose [=ViewTransition/update callback=] is |updateCallback|.

				Note: The |preSkippedTransition|'s {{ViewTransition/types}} are ignored here because the transition is never activated.

			1. [=Skip the view transition|Skip=] |preSkippedTransition| with an "{{InvalidStateError}}" {{DOMException}}.

			1. Return |preSkippedTransition|.

			Note: This ensures that a same-document transition that started after firing {{Window/pageswap}} is skipped.

		1. Let |viewTransition| be the result of running the [=method steps=] for {{Document/startViewTransition(updateCallback)}} given |updateCallback|.

		1. If |callbackOptions| is a {{StartViewTransitionOptions}}, set |viewTransition|'s [=ViewTransition/active types=] to a [=list/clone=] of {{StartViewTransitionOptions/types}} as a [=/set=].

		1. Return |viewTransition|.
	</div>

# Algorithms # {#algorithms}

## Data structures ## {#cross-doc-data-structures}

### Additions to {{Document}} ### {#cross-doc-data-structure-document}
A {{Document}} additionaly has:

<dl dfn-for=document>
	: <dfn>inbound view transition params</dfn>
	:: a [=view transition params=], or null.
		Initially null.

	: <dfn>can initiate outbound view transition</dfn>
	:: a boolean.
		Initially false.

		Note: this value can be read [=in parallel=] while navigating.
</dl>

### Additions to {{ViewTransition}} ### {#cross-doc-data-structure-vt}
A {{ViewTransition}} additionally has:
<dl dfn-for=ViewTransition>
	: <dfn>active types</dfn>
	:: A {{ViewTransitionTypeSet}}, initially empty.

	: <dfn>outbound post-capture steps</dfn>
	:: Null or a set of steps, initially null.
</dl>

### Serializable [=view transition params=] ### {#cross-doc-data-structure-serialization}
A <dfn>view transition params</dfn> is a [=struct=] whose purpose is to serialize view transition information across documents.
It has the following [=struct/items=]:

<dl dfn-for="view transition params">
	: <dfn>named elements</dfn>
	:: a [=/map=], whose keys are strings and whose values are [=captured elements=].

	: <dfn>initial snapshot containing block size</dfn>
	:: a [=tuple=] of two numbers (width and height).
</dl>

### Captured elements extension ### {#capture-classes-data-structure}
The [=captured element=] struct should contain these fields, in addition to the existing ones:
	<dl>
		: <dfn for="captured element">class list</dfn>
		:: a [=/list=] of strings, initially empty.
	</dl>

## Resolving the ''@view-transition'' rule ## {#vt-rule-algo}
	<div algorithm>
		To <dfn>resolve @view-transition rule</dfn> for a {{Document}} |document|:

		Note: this is called in both the old and new document.

		1. If |document|'s [=Document/visibility state=] is "<code>hidden</code>",
			then return "<code>skip transition</code>".

		1. Let |matchingRule| be the last ''@view-transition'' rule in |document|.

		1. If |matchingRule| is not found, then return "<code>skip transition</code>".

		1. If |matchingRule|'s [=@view-transition/navigation=] descriptor's [=computed value=] is ''@view-transition/navigation/none'', then return "<code>skip transition</code>".

		1. Assert: |matchingRule|'s [=@view-transition/navigation=] descriptor's [=computed value=] is ''@view-transition/navigation/auto''.

		1. Let |typesDescriptor| be |matchingRule|'s [=@view-transition/types=] descriptor.

		1. If |typesDescriptor|'s [=computed value=] is ''@view-transition/type/none'', then return a [=/set=] « ».

		1. Return a [=/set=] of strings corresponding to |typesDescriptor|'s [=computed value=].
	</div>

## Setting up the view transition in the old {{Document}} ## {#setup-old-document-vt}

### Check eligibility for outbound cross-document view transition ### {#check-eligibility}
<div algorithm>
	To check if a <dfn export>navigation can trigger a cross-document view-transition?</dfn> given
	a {{Document}} |oldDocument|, a {{Document}} |newDocument|, a {{NavigationType}} |navigationType|, and a boolean |isBrowserUINavigation|:

		Note: this is called during navigation, potentially [=in parallel=].

	1. If the user agent decides to display an [=implementation-defined=] navigation experience, e.g. a gesture-based transition for a back navigation,
		the user agent may ignore the author-defined view transition. If that is the case, return false.

	1. If |oldDocument|'s [=can initiate outbound view transition=] is false, then return false.

	1. If |navigationType| is {{NavigationType/reload}}, then return false.

	1. If |oldDocument|'s [=Document/origin=] is not [=same origin=] as |newDocument|'s [=Document/origin=], then return false.

	1. If |newDocument| [=was created via cross-origin redirects=], then return false.

	1. If |navigationType| is {{NavigationType/traverse}}, then return true.

	1. If |isBrowserUINavigation| is true, then return false.

	1. Return true.
</div>

### Setup the outbound transition when ready to swap pages ### {#setup-outbound-transition}
<div algorithm>
	To <dfn export>setup cross-document view-transition</dfn> given a {{Document}} |oldDocument|,
	a {{Document}} |newDocument|, and |proceedWithNavigation|, which is an algorithm accepting nothing:

	Note: This is called from the HTML spec.

	1. [=Assert=]: These steps are running as part of a [=task=] queued on |oldDocument|.

	1. If |oldDocument|'s [=can initiate outbound view transition=] is false, then return null.

	1. Let |transitionTypesFromRule| be the result of [=Resolve @view-transition rule|resolving the @view-transition rule=] for |oldDocument|.

	1. [=Assert=]: |transitionTypesFromRule| is not "<code>skip transition</code>".

		Note: We don't know yet if |newDocument| has opted in, as it might not be parsed yet.
		We check the opt-in for |newDocument| when we fire the {{Window/pagereveal}} event.

	1. If |oldDocument|'s [=active view transition=] is not null,
		then [=skip the view transition|skip=] |oldDocument|'s [=active view transition=]
		with an "{{AbortError}}" {{DOMException}} in |oldDocument|'s [=relevant Realm=].

		Note: this means that any running transition would be skipped when the document is ready
		to unload.

	1. Let |outboundTransition| be a new {{ViewTransition}} object in |oldDocument|'s [=relevant Realm=].

	1. Set |outboundTransition|'s [=ViewTransition/active types=] to |transitionTypesFromRule|.

		Note: the [=ViewTransition/active types=] are not shared between documents.
		Manipulating the {{ViewTransition/types}} in the new document does not affect the types in |newDocument|,
		which would be read from the [=@view-transition/types=] descriptor once |newDocument| is revealed.

		Note: the {{ViewTransition}} is skipped once the old document is hidden.

	1. Set |outboundTransition|'s [=outbound post-capture steps=] to the following steps given a [=view transition params=]-or-null |params|:
		1. Set |newDocument|'s [=inbound view transition params=] to |params|.

			Note: The inbound transition is activated after the dispatch of {{Window/pagereveal}} to ensure mutations made in this event apply to the captured new state.

		1. Call |proceedWithNavigation|.

	1. Set |oldDocument|'s [=active view transition=] to |outboundTransition|.

		Note: The process continues in [=perform pending transition operations=].

	1. The user agent should display the currently displayed frame until either:
		* The {{Window/pagereveal}} event is fired.
		* its [=active view transition=]'s [=ViewTransition/phase=] is "`done`".

		Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.

	1. Return |outboundTransition|.
</div>

### Update the opt-in flag to reflect the current state ### {#update-opt-in}
<div algorithm="update-opt-in-for-outbound">
To <dfn>update the opt-in state for outbound transitions</dfn> for a {{Document}} |document|:
	1. If |document| [=has been revealed=], and the result of [=resolve @view-transition rule|resolving the @view-transition rule=] is not "<code>skip transition</code>",
		then set |document|'s [=can initiate outbound view transition=] to true.
	1. Otherwise, set |document|'s [=can initiate outbound view transition=] to false.
</div>

### Proceed with navigation if view transition is skipped ### {#proceed-if-skipped}
<div algorithm="additional skip steps">
	Append the following steps to [=skip the view transition=] given a {{ViewTransition}} |transition|:
		1. If |transition|'s [=outbound post-capture steps=] is not null, then run |transition|'s [=outbound post-capture steps=] with null.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

### Proceed with cross-document view transition after capturing the old state ### {#cross-doc-after-capture}
<div algorithm="additional transition operation">
Prepend the following step to the [=Perform pending transition operations=] algorithm given a {{Document}} |document|:
	1. If |document|'s [=active view transition=] is not null and its [=outbound post-capture steps=] is not null, then:

		1. Assert: |document|'s [=active view transition=]'s  [=ViewTransition/phase=] is "`pending-capture`".

		1. Let |viewTransitionParams| be null;

		1. Set |document|'s [=document/rendering suppression for view transitions=] to true.

			Issue: Though [=capture the old state=] appears here as a synchronous step, it is in fact an asynchronous step
			as rendering an element into an image cannot be done synchronously. This should be more explicit in the L1 spec.

		1. [=Capture the old state=] for |transition|.

		1. If this succeeded, then set |viewTransitionParams| to a new [=view transition params=] whose
			[=view transition params/named elements=] is a [=map/clone=] of |transition|'s [=ViewTransition/named elements=],
			and whose [=view transition params/initial snapshot containing block size=] is |transition|'s [=ViewTransition/initial snapshot containing block size=].

		1. Set |document|'s [=document/rendering suppression for view transitions=] to false.

		1. Call |transition|'s [=outbound post-capture steps=] given |viewTransitionParams|.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

## Activating the view transition in the new {{Document}} ## {#access-view-transition-in-new-doc}

<div algorithm>
	To <dfn export>resolve inbound cross-document view-transition</dfn> for {{Document}} |document|:

	1. [=Assert=]: |document| is [=fully active=].

	1. [=Assert=]: |document| [=has been revealed=] is true.

	1. [=Update the opt-in state for outbound transitions=] for |document|.

	1. Let |inboundViewTransitionParams| be |document|'s [=inbound view transition params=].

	1. If |inboundViewTransitionParams| is null, then return null.

	1. Set |document|'s [=inbound view transition params=] to null.

	1. If |document|'s [=active view transition=] is not null, then return null.

		Note: this means that starting a same-document transition before revealing the document would cancel a pending cross-document transition.

	1. [=Resolve @view-transition rule=] for |document| and let |resolvedRule| be the result.

	1. If |resolvedRule| is "<code>skip transition</code>", then return null.

	1. Let |transition| be a new {{ViewTransition}} in |document|'s [=relevant Realm=],
		whose [=ViewTransition/named elements=] is |inboundViewTransitionParams|'s [=view transition params/named elements=],
		and [=ViewTransition/initial snapshot containing block size=] is |inboundViewTransitionParams|'s [=view transition params/initial snapshot containing block size=].

	1. Set |document|'s [=active view transition=] to |transition|.

	1. [=Resolve=] |transition|’s [=ViewTransition/update callback done promise=] with undefined.

	1. Set |transition|’s [=ViewTransition/phase=] to "`update-callback-called`".

	1. Set |transition|'s [=ViewTransition/active types=] to |resolvedRule|.

	1. At any given time, the UA may decide to skip the inbound transition, e.g. after an [=implementation-defined=] timeout.
		To do so, the UA should [=queue a global task=] on the [=DOM manipulation task source=] given |document|'s [=relevant global object=] to perform the following step:
			If |transition|'s [=ViewTransition/phase=] is not "`done`", then [=skip the view transition=] |transition| with a "{{TimeoutError}}" {{DOMException}}.

	1. Return |transition|.
</div>

## Capturing the 'view-transition-class' ## {#vt-class-algorithms}

<div algorithm="additional capture steps">
When capturing the old or new state for an element, perform the following steps given a [=captured element=] |capture| and an [=element=] |element|:

	1. Set |capture|'s [=captured element/class list=] to the [=computed value=] of |element|'s 'view-transition-class'.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

<h2 id="priv" class="no-num">Privacy Considerations</h2>

This specification introduces no new privacy considerations.

<h2 id="sec" class="no-num">Security Considerations</h2>

To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for
same-origin navigations. As discussed in <a href="https://github.com/WICG/view-transitions/issues/200">WICG/view-transitions#200</a>,
this still presents two potential threats:

1. The [=environment settings object/cross-origin isolated capability=] in both documents might be different.
	This can cause a situation where a {{Document}} that is [=environment settings object/cross-origin isolated capability|cross-origin isolated=]
	can read image data from a document that is not cross-origin isolated. This is already mitigated in [[css-view-transitions-1#sec],
	as the same restriction applies for captured cross-origin iframes.

1. A same-origin navigation might still occur via a cross-origin redirect, e.g. <code>https://example.com</code>
	links to <code>https://auth-provider.com/</code> which redirects back to <code>https://example.com/loggedin</code>.

	This can cause a (minor) situation where the cross-origin party would redirect the user to an
	unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect.
	To mitigate this, currently view transitions are disabled for navigations if the {{Document}} [=was created via cross-origin redirects=].
	Note that this check doesn't apply when the {{Document}} is being [=Document/reactivated=], as in that case
	the cross-origin redirect has already taken place.

	Note: this only applies to server-side redirects. A client-side redirect, e.g. using
	[^meta/http-equiv/refresh^], is equivalent to a new navigation.

1. This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related.
	This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come
	from trusted sources to begin with, as CSS can learn about the document or change it in many ways.


See <a href="https://github.com/w3c/csswg-drafts/issues/8684">Issue #8684</a> and
<a href="https://github.com/WICG/view-transitions/issues/200">WICG/view-transitions#200</a> for
detailed discussion.
