<pre class='metadata'>
Title: CSS View Transitions Module Level 2
Shortname: css-view-transitions
Level: 2
Status: ED
Group: csswg
Prepare for TR: no
ED: https://drafts.csswg.org/css-view-transitions-2/
TR: https://www.w3.org/TR/css-view-transitions-2/
Work Status: exploring
Editor: Noam Rosenthal, Google, w3cid 121539
Editor: Khushal Sagar, Google, w3cid 122787
Editor: Vladimir Levin, Google, w3cid 75295
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Abstract: This module defines how the View Transition API works with cross-document navigations.
Markup Shorthands: css yes, markdown yes
</pre>

<pre class=link-defaults>
spec:css-view-transitions-1;
	text: active view transition; type: dfn;
	text: capture the new state; type: dfn;
	text: capture the old state; type: dfn;
	text: activate view transition; type: dfn;
	text: skip the view transition; type: dfn;
	text: ViewTransition; type: interface;
	text: named elements; for: ViewTransition; type: dfn;
	text: finished promise; for: ViewTransition; type: dfn;
	text: ready promise; for: ViewTransition; type: dfn;
	text: update callback; for: ViewTransition; type: dfn;
	text: update callback done promise; for: ViewTransition; type: dfn;
	text: initial snapshot containing block size; for: ViewTransition; type: dfn;
	text: captured elements; type: dfn;
	text: snapshot containing block; type: dfn;
	text: old transform; for: captured element; type: dfn;
	text: new element; for: captured element; type: dfn;
	text: updateCallbackDone; type: property; for: ViewTransition;
	text: phase; type: dfn; for: ViewTransition;
	text: call the update callback; type: dfn;
	text: perform pending transition operations; type: dfn;
	text: setup view transition; type: dfn;
	text: named view transition pseudo-element; type: dfn;
	text: rendering suppression for view transitions; type: dfn;
	text: view transition tree; type: dfn;
	text: view transition name; type: dfn;
	text: group styles rule; type: dfn;
	text: update pseudo-element styles rule; type: dfn;
	text: document-scoped view transition name; type: dfn;
spec:dom; type:dfn; text:document
spec:css22; type:dfn; text:element
spec:selectors-4; type:dfn;
	text:selector
	text:type selector
spec:html
	text: latest entry; type: dfn;
	text: was created via cross-origin redirects; type: dfn;
	text: run the animation frame callbacks; type: dfn;
	text: deactivate a document for a cross-document navigation; type: dfn;
	text: pagereveal; type: dfn; for: Window;
	text: has been revealed; type: dfn;
	text: render-blocking mechanism; type: dfn;
spec:geometry-1
	text:multiply; type:dfn;
	text:matrix; type:dfn;
spec:infra; type:dfn; text:list
spec:css-borders-4; type: property; text:border-radius;
</pre>

<style>
	spec-scaler {
		display: block;
	}
	spec-scaler:not(:defined) > * {
		display: none;
	}
	.spec-slides {
		width: 100%;
		height: 100%;
		border: none;
		display: block;
	}
	.spec-slide-controls {
		text-align: center;
	}
	.main-example-video {
		display: block;
		width: 100%;
		max-width: 702px;
		height: auto;
		margin: 0 auto;
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
		padding: .5em;
		border: thin solid #ddd; border-radius: .5em;
		margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
		margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
		margin-bottom: 0;
	}
	[data-algorithm] [data-algorithm] {
		margin: 1em 0;
	}
	pre {
		tab-size: 2;
	}
</style>
<script async type="module" src="diagrams/resources/scaler.js"></script>

# Introduction # {#intro}

	*This section is non-normative.*

	View Transitions, as specified in [[css-view-transitions-1]], is a feature that allows developers
	to create animated transitions between visual states of the [=/document=].

	Level 2 extends that specification, by adding the necessary API and lifecycle to enable
	transitions across a same-origin cross-document navigation, as well as a few additions that
	make it easier to author pages with richer view transitions.

	Level 2 defines the following:

		* <a href="#cross-document-view-transitions">Cross-document view transitions</a>, including the ''@view-transition'' rule and the algorithms
			that enable the cross-document view transition lifecycle.
		* <a href="#selective-vt">Selective view transitions</a>, a way to match styles based on the existence of an [=active view transition=],
			and more specifically based on the active view transition being of a certain type.
		* <a href="#shared-style-with-vt-classes">Sharing styles between view transition pseudo-elements</a>, a way to declare a style once,
			and use it for multiple view transition pseudo-elements. This includes the 'view-transition-class' property, and <a href="#pseudo-element-class-additions">additions to named pseudo-elements</a>

# Cross-document view transitions # {#cross-document-view-transitions}

## Overview ## {#cross-doc-overview}

*This section is non-normative.*

### Activation ### {#activating-cross-document-view-transition}
With same-document view transitions, the author starts a view transition using JavaScript, by calling {{Document/startViewTransition}}.
In cross-document view transition, what triggers a view transition is a navigation between two documents, as long as the following conditions are met:

	* Both documents are of the [=same origin=];
	* The page is visible throughout the entire course of the navigation;
	* The user initiates the navigation by interacting with the page, e.g. by clicking a link or submitting a form; or by interacting with the browser UI to do a {{NavigationType/traverse}} navigation (back/forward). This excludes, for example, navigations initiated by the URL bar;
	* the navigation didn't include cross-origin redirects; and
	* both documents opted in to cross-document view transitions, using the ''@view-transition'' rule.

See the <a href="#lifecycle">lifecycle</a> section for more details.

### Waiting for the new state to stabilize ### {#waiting-for-stable-state}
In same-document view transitions, the author can indicate when the new state of the transition is in a stable state by using the callback passed to {{Document/startViewTransition}}.
Since cross-document view transitions are declarative, there is no such explicit promise. Instead, the user agent relies on the [=render-blocking mechanism=] to decide when the document has reached a stable state.
In this way, the author can use the <code data-x="">blocking</code> attribute, to delay the transition until:
	* All expected scripts are executed, by using the script's {{HTMLScriptElement/blocking}} attribute on required scripts.
	* All expected styles are executed, by using the style or link's {{HTMLStyleElement/blocking}} attribute on required styles.
	* All expected HTML elements are seen by the parser, using an <{link/rel/expect}> {{HTMLLinkElement}} element.

Note: overusing the render-blocking mechanism could make it so that the old state remains frozen for a long time, resulting in a jarring user experience.
To avoid this, it's advised to ensure that the render-blocking elements are available in a timely manner.

<div class="example">

In this example, the last frame of the old document will be shown, and the animation will be delayed, until all the following conditions are met:
- `style.css` is applied, to ensure the new state has the correct styles
- `fixup.js` is run, to ensure the presentation is up to date with script-based fixups.
- The `main-article` section is seen and parsed, to ensure enough of the content is loaded before allowing the transition to proceed.

```html
<!DOCTYPE html>
<html>
	<head>
		< !-- This will be render-blocking by default -->
		<link rel="stylesheet" href="style.css">

		< !-- Since this script fixes up the layout, marking it as render blocking will
			  ensure it's run before the view transition is activated -->
		<script async href="fixup.js" blocking="render"></script>

		< !-- Wait until the main-article element is seen and fully parsed before
			  activating the transition -->
		<link rel="expect" href="#main-article" blocking="render">
	</head>
	<body>
		<header>...</header>
		<main>
			<article id="main-article">...</article>
		</main>
		<article id="secondary-article">...</article>
	</body>
</html>
```
</div>

### Customization ### {#customizing-cross-document-view-transitions}
The {{ViewTransition}} object enables customizing the transition in script.
Same-document view transitions use a single {{ViewTransition}} object returned from the {{Document/startViewTransition}} call for the entire lifecycle.
Cross-document view transitions have two {{ViewTransition}} objects, one in the old document and one in the new document.

#### Handling the view transition in the old document #### {#old-doc-event}

The {{Window/pageswap}} event is fired at the last moment before a document is about to be unloaded and swapped by another document.
It can be used to find out whether a view transition is about to take place, customize it using {{ViewTransition/types}}, make last minute changes to the captured elements, or skip it if necessary.
The {{PageSwapEvent}} interface has a {{PageSwapEvent/viewTransition}} object, which would be non-null when the navigation is eligible to a view transition,
and a {{PageSwapEvent/activation}} object, providing handy information about the navigation, like the URL after redirects.
The transition's {{ViewTransition/finished}} promise can be used for cleaning up after the transition, in case the document is later restored from BFCache.

#### Handling the view transition in the new document #### {#new-doc-event}

The {{Window/pagereveal}} event is fired right before presenting the first frame of the new document.
It can be used to find out if the view transition is still valid, by querying the {{PageRevealEvent/viewTransition}} attribute.
Similar to a same-document view transition, the author can now select different {{ViewTransition/types}}, make last minute changes to the captured elements, wait for the transition to be {{ViewTransition/ready}} in order to animate it, or skip it altogether.

### Lifecycle ### {#lifecycle}

	*This section is non-normative.*

	A successful cross-document view transition goes through the following phases:

	1. In the old {{Document}}:

		1. The user initiates a navigation, by clicking a link, submitting a form, pressing the browser's back button, etc.

			Note: some navigations do not trigger a view-transition, e.g. typing a new address in the URL bar.

		1. When the new {{Document}} is ready to be activated, the {{Window/pageswap}} event is fired.

		1. If the navigation is [=same origin=], has no cross-origin redirects,
			and the old {{Document}} has <a href="#cross-doc-opt-in">opted in to cross-document view transitions</a>, the event's {{PageSwapEvent/viewTransition}} attribute would be
			a {{ViewTransition}} object.

		1. The author can now customize the transition, e.g. by mutating its {{ViewTransition/types}}, or {{ViewTransition/skipTransition()|skip}} it altogether.

		1. If the {{ViewTransition}} is not skipped, the state of the old document is [=capture the old state|captured=].

		1. The navigation proceeds: the old {{Document}} is unloaded, and the new {{Document}} is now active.

	1. Then, in the new {{Document}}:

		1. When the new {{Document}} is ready for its first [=rendering opportunity=], an event named {{Window/pagereveal}} is fired on the new {{Document}}, with a {{PageRevealEvent/viewTransition}} attribute.

		1. This {{ViewTransition}}'s <code>{{ViewTransition/updateCallbackDone}}</code> promise is already resolved,
			and its [=captured elements=] are populated from the old {{Document}}.

		1. This is another opportunity for the author to customize the transition, e.g. by mutating its {{ViewTransition/types}}, or {{ViewTransition/skipTransition()|skip}} it altogether.

		1. The state of the new document is [=capture the new state|captured=] as the "new" state of the transition.

		1. From this point forward, the transition continues in a similar fashion to a same-document transition, as per [=activate view transition=].

## Examples ## {#cross-doc-examples}

<div class=example>
	To generate the same cross-fade as in the first example [[css-view-transitions-1#examples]],
	but across documents, we don't need JavaScript.

	Instead, we opt in to triggering view-transitions on navigation in both page 1 and page 2:

	```css
	// in both documents:
	@view-transition {
		navigation: auto;
	}
	```

	A link from page 1 to or from page 2 would generate a crossfade transition for example 1.
	To achieve the effect examples 2, 3 & 4, simply put the CSS for the pseudo-elements in both
	documents.
</div>

<div class=example>
	Note that the ''@view-transition'' rule can be used together with media queries.
	For example, this would only perform the transition when the screen width is greater than:

	```css
	@view-transition {
		navigation: auto;
	}

	@media (max-width: 600px) {
		navigation: none;
	}
	```
</div>

<div class="example">
	To achieve the effect in [[css-view-transitions-1#examples|example 5]], we have to do several
	things:

	- Opt-in to navigation-triggered view-transitions in both pages.
	- Pass the click location to the new document, e.g. via {{WindowSessionStorage/sessionStorage}}.
	- Intercept the {{ViewTransition}} object in the new document, using the {{Window/pagereveal}} event.

	In both pages:
	```css
	@view-transition {
		navigation: auto;
	}

	```
	In the old page:
	```js
	addEventListener('click', event => {
		sessionStorage.setItem("lastClickX", event.clientX);
		sessionStorage.setItem("lastClickY", event.clientY);
	});
	```

	In the new page:
	```js
	// This would run both on initial load and on reactivation from BFCache.
	addEventListener("pagereveal", async event => {
		if (!event.viewTransition)
			return;

		const x = sessionStorage.getItem("lastClickX") ?? innerWidth / 2;
		const y = sessionStorage.getItem("lastClickY") ?? innerHeight / 2;

		const endRadius = Math.hypot(
			Math.max(x, innerWidth - x),
			Math.max(y, innerHeight - y)
		);

		await event.viewTransition.ready;

		// Animate the new document's view
		document.documentElement.animate(
			{
				clipPath: [
					`circle(0 at ${x}px ${y}px)`,
					`circle(${endRadius}px at ${x}px ${y}px)`,
				],
			},
			{
				duration: 500,
				easing: 'ease-in',
				pseudoElement: '::view-transition-new(root)'
			}
		);
	})
	```
</div>

<div class="example">
	To choose which elements are captured based on properties of the navigation, and whether certain images are loaded:

	In the old page:
	```js
		window.addEventListener("pageswap", event => {
			// For example, the page was hidden, or the navigation is cross-document.
			if (!event.viewTransition)
				return;

			// If you don't want view transition for back/forward navigations...
			if (event.activation.navigationType === "traverse") {
				event.viewTransition.skipTransition();
			}

			const newURL = new URL(event.activation.entry.url);
			if (newURL.pathname === "/details" && thumbnail.complete) {
				thumbnail.classList.add("transition-to-hero");

				// This will cleanup the state if the page is restored from BFCache.
				event.viewTransition.finished.then(() => {
					thumbnail.classList.remove("transition-to-hero");
				});
			}

		});
	```

	In the new page:
	```js
		window.addEventListener("pagereveal", event => {
			// For example, the page was hidden, the navigation is cross-document, or the transition was skipped in the old document.
			if (!event.viewTransition)
				return;

			const oldURL = new URL(navigation.activation.from.url);
			if (newURL.pathname === "/list") {
				event.viewTransition.types.add("coming-from-list");

				// This will show the thumbnail until the view transition is finished.
				if (!hero.complete) {
					setToThumbnail(hero);
					event.viewTransition.finished.then(() => {
						setToFullResolution(hero);
					})
				}
			}
		});
	```
</div>

## Opting in to cross-document view transitions ## {#cross-doc-opt-in}

### The <dfn id="at-view-transition-rule">''@view-transition''</dfn> rule ### {#view-transition-rule}

The ''@view-transition'' rule is used by a document to indicate that cross-document navigations
should setup and activate a {{ViewTransition}}.

The ''@view-transition'' rule has the following syntax:

<pre class=prod>
	@view-transition {
		<<declaration-list>>
	}
</pre>

The ''@view-transition'' rule accepts the [=@view-transition/navigation=] and [=@view-transition/types=] descriptors.

Note: as per default behavior, the ''@view-transition'' rule can be nested inside a
[=conditional group rule=] such as ''@media'' or ''@supports''.

When the ''@view-transition'' rule changes for {{Document}} |document|, the user agent must [=update the opt-in state for outbound transitions=] given |document|.

Note: this needs to be cached in the boolean because the result needs to be read [=in parallel=], when navigating.

### The [=@view-transition/navigation=] descriptor ### {#view-transition-navigation-descriptor}

	<pre class='descdef'>
	Name: navigation
	For: @view-transition
	Value: auto | none
	Initial: none
	</pre>

	The '<dfn for="@view-transition">navigation</dfn>' descriptor opts in to automatically starting a view transition when performing a navigation of a certain type.
	Must be present on both the old and new document.

	<dl dfn-type=value dfn-for="@view-transition/navigation">
		: <dfn>none</dfn>
		:: There will be no transition.

		: <dfn>auto</dfn>
		:: The transition will be enabled if the navigation is same-origin, without cross-origin
			redirects, and whose {{NavigationType}} is
			* {{NavigationType/traverse}}, or
			* {{NavigationType/push}} or {{NavigationType/replace}}, with <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#user-navigation-involvement">user navigation involvement</a> not equal to `"browser UI"`.

			Note: Navigations excluded from ''@view-transition/navigation/auto'' are for example, navigating
			via the URL address bar or clicking a bookmark, as well as any form of user or script initiated {{NavigationType/reload}}.
	</dl>

This at-rule conforms with the forward-compatible parsing requirement of CSS;
conformant parsers that don't understand these rules will ignore them without error.
Any descriptors that are not recognized or implemented by a given user agent,
or whose value does not match the grammars given here or in a future version of this specification,
must be ignored in their entirety;
they do not make the ''@view-transition'' rule invalid.

### Accessing the ''@view-transition'' rule using CSSOM ### {#cssom}

The {{CSSViewTransitionRule}} represents a ''@view-transition'' rule.

<xmp class=idl>
		[Exposed=Window]
		interface CSSViewTransitionRule : CSSRule {
			readonly attribute CSSOMString navigation;
			[SameObject] readonly attribute FrozenArray<CSSOMString> types;
		};
</xmp>

The {{CSSViewTransitionRule/navigation}} getter step is to return the value of the corresponding ''@view-transition/navigation'' descriptor if one exists, otherwise the empty string.

The {{CSSViewTransitionRule/types}} getter steps is to return the value of the corresponding ''@view-transition/types'' descriptor if one exists, otherwise an empty [=list=].

# Selective view transitions # {#selective-vt}

## Overview ## {#selective-vt-overview}

*This section is non-normative.*

For simple pages, with a single view transition, setting the ''view-transition-name'' property on participating elements should be sufficient.
However, in more complex scenarios, the author might want to declare various view transitions, and only run one of them simultaneously.
For example, sliding the whole page when clicking on the navigation bar, and sorting a list when one of its items is dragged.

To make sure each view transition only captures what it needs to, and different transitions don't interfere with each other,
this spec introduces the concept of [=active types=], alongside the '':active-view-transition'' and '':active-view-transition-type()'' pseudo-classes.

'':active-view-transition'' matches the [=document element=] when it has an [=active view transition=], and '':active-view-transition-type()''
matches the [=document element=] if the types in the selectors match the [=active view transition=]'s [=ViewTransition/active types=].

The {{ViewTransition}}'s [=active types=] are populated in one of the following ways:

	1. Passed as part of the arguments to {{Document/startViewTransition(callbackOptions)}}
	1. Mutated at any time, using the transition's {{ViewTransition/types}}
	1. Declared for a cross-document view transition, using the [=@view-transition/types=] descriptor.

## Examples ## {#active-view-transition-pseudo-examples}

<div class=example>
For example, the developer might start a transition in the following manner:
```js
document.startViewTransition({update: updateTheDOMSomehow, types: ["slide-in", "reverse"]});
```

This will activate any of the following selectors:
```css
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(reverse) {}
:root:active-view-transition-type(slide-in, reverse) {}
:root:active-view-transition-type(slide-in, something-else) {}
:root:active-view-transition {}
```

While starting a transition without providing transition types, would only activate ':active-view-transition'':

```js
document.startViewTransition(updateTheDOMSomehow);
// or
document.startViewTransition({update: updateTheDOMSomehow});
```

```css
/* This would be active */
:root { }
:root:active-view-transition {}

/* This would not be active */
:root:active-view-transition-type(slide-in) {}
:root:active-view-transition-type(any-type-at-all-except-star) {}
```
</div>

## Selecting based on the active view transition ## {#pseudo-classes-for-selective-vt}
### The '':active-view-transition'' pseudo-class ### {#the-active-view-transition-pseudo}

The <dfn id='active-view-transition-pseudo'>:active-view-transition</dfn> pseudo-class applies to the root element of the document, if it has an [=active view transition=].

The [=specificity=] of an '':active-view-transition'' is one pseudo-class selector.

An '':active-view-transition'' pseudo-class matches the [=document element=] when its [=node document=] has an non-null [=active view transition=].

### The '':active-view-transition-type()'' pseudo-class ### {#the-active-view-transition-type-pseudo}

The <dfn id='active-view-transition-type-pseudo'>:active-view-transition-type()</dfn> pseudo-class applies to the root element of the document, if it has a matching [=active view transition=].
It has the following syntax definition:

<pre class=prod>
	:active-view-transition-type(<<custom-ident>>#)
</pre>

The [=specificity=] of an '':active-view-transition-type()'' is one pseudo-class selector.

An '':active-view-transition-type()'' pseudo-class matches the [=document element=] when its [=node document=] has an non-null [=active view transition=],
whose [=ViewTransition/active types=] [=list/contains=] at least one of the <<custom-ident>> arguments.

## Changing the types of an ongoing view transition ## {#view-transitions-extension-types}

The {{ViewTransition}} interface is extended as follows:

<xmp class='idl'>
[Exposed=Window]
interface ViewTransitionTypeSet {
	setlike<DOMString>;
};

[Exposed=Window]
partial interface ViewTransition {
	attribute ViewTransitionTypeSet types;
};
</xmp>

The {{ViewTransitionTypeSet}} object represents a [=/set=] of strings, without special semantics.

Note: a {{ViewTransitionTypeSet}} can contain strings that are invalid for '':active-view-transition-type'', e.g.
strings that are not a <<custom-ident>>.

The {{ViewTransition/types}} [=getter steps=] are to return [=this=]'s [=ViewTransition/active types=].

## Activating the transition type for cross-document view transitions ## {#types-cross-doc}

The [=@view-transition/types=] descriptor

	<pre class='descdef'>
	Name: types
	For: @view-transition
	Value: none | <<custom-ident>>+
	Initial: none
	</pre>

	The '<dfn for="@view-transition">types</dfn>' descriptor sets the [=ViewTransition/active types=] for the transition
	when capturing or performing the transition, equivalent to calling {{Document/startViewTransition(callbackOptions)}} with that {{StartViewTransitionOptions/types}}.

	Note: the [=@view-transition/types=] descriptor only applies to the {{Document}} in which it is defined.
	The author is responsible for using their chosen set of types in both documents.

# Sharing styles between view transition pseudo-elements # {#shared-style-with-vt-classes}

## Overview ## {#shared-style-overview}

*This section is non-normative.*

When styling multiple elements in the DOM in a similar way, it is common to use the [=Element/class=] attribute:
setting a name that's shared across multiple elements, and then using the [=class selector=] to declare the shared style.

[=Named view transition pseudo-elements|The view transition pseudo-elements=] (e.g. ''view-transition-group()'') are not defined in the DOM, but rather by using the ''view-transition-name'' property.
For that purpose, the ''view-transition-class''' CSS property provides view transitions with the equivalent of HTML [=Element/class|classes=].
When an element with a ''view-transition-name'' also has a ''view-transition-class'' value, that class would be selectable by the pseudo-elements, as per the <a href="#vt-class-example">examples</a>.

## Examples ## {#vt-class-example}

<div class="example">
This example creates a transition with each box participating under its own name, while applying
a 1-second duration to the animation of all the boxes:

```html
<div class="box" id="red-box"></div>
<div class="box" id="green-box"></div>
<div class="box" id="yellow-box"></div>
```

```css
div.box {
	view-transition-class: any-box;
	width: 100px;
	height: 100px;
}
#red-box {
	view-transition-name: red-box;
	background: red;
}
#green-box {
	view-transition-name: green-box;
	background: green;
}
#yellow-box {
	view-transition-name: yellow-box;
	background: yellow;
}

/* The following style would apply to all the boxes, thanks to 'view-transition-class' */
::view-transition-group(*.any-box) {
	animation-duration: 1s;
}
```
</div>

## The 'view-transition-class' property ## {#view-transition-class-prop}

	<pre class=propdef>
	Name: view-transition-class
	Value: none | <<custom-ident>>+
	Initial: none
	Inherited: no
	Percentages: n/a
	Computed Value: as specified
	Animation type: discrete
	</pre>

	The 'view-transition-class' can be used to apply the same style rule to multiple [=named view transition pseudo-elements=] which may have a different 'view-transition-name'.
	While 'view-transition-name' is used to match between the element in the old state with its corresponding element in the new state, 'view-transition-class' is used
	only to apply styles using the view transitionpseudo-elements
	(''::view-transition-group()'', ''::view-transition-image-pair()'', ''::view-transition-old()'', ''::view-transition-new()'').

	Note that 'view-transition-class' by itself doesn't mark an element for capturing, it is only used as an additional
	way to style an element that already has a 'view-transition-name'.

	<dl dfn-type=value dfn-for=view-transition-class>
		: <dfn>none</dfn>
		:: No class would apply to the [=named view transition pseudo-elements=] generated for this element.

		: <dfn><<custom-ident>>+</dfn>
		:: All of the specified <<custom-ident>> values (apart from <css>none</css>) are applied when used in [=named view transition pseudo-element=] selectors.
			<css>none</css> is an invalid <<custom-ident>> for 'view-transition-class', even when combined with another <<custom-ident>>.

			Each 'view transition class' is a [=tree-scoped name=].

			Note: If the same 'view-transition-name' is specified for an element both in the old and new states of the transition,
			only the 'view-transition-class' values from the new state apply. This also applies for cross-document view transitions:
			classes from the old document would only apply if their corresponding 'view-transition-name' was not specified in the new document.
	</dl>

## Additions to named view transition pseudo-elements ## {#pseudo-element-class-additions}

	The [=named view transition pseudo-elements=]
	(''view-transition-group()'', ''view-transition-image-pair()'', ''view-transition-old()'', ''view-transition-new()'')
	are extended to support the following syntax:

	<pre class=prod>
		::view-transition-group(<<pt-name-and-class-selector>>)
		::view-transition-image-pair(<<pt-name-and-class-selector>>)
		::view-transition-old(<<pt-name-and-class-selector>>)
		::view-transition-new(<<pt-name-and-class-selector>>)
	</pre>

	where <<pt-name-selector>> works as previously defined, and
	<<pt-name-and-class-selector>> has the following syntax definition:

	<pre class=prod>
		<dfn>&lt;pt-name-and-class-selector></dfn> = <<pt-name-selector>> <<pt-class-selector>>? | <<pt-class-selector>>
		<dfn>&lt;pt-class-selector></dfn> = ['.' <<custom-ident>>]+
	</pre>

	When interpreting the above grammar, white space is forbidden:

		* Between <<pt-name-selector>> and <<pt-class-selector>>
		* Between any of the components of <<pt-class-selector>>.

	A [=named view transition pseudo-element=] [=selector=] which has one or more <<custom-ident>> values
	in its <<pt-class-selector>> would only match an element if the [=captured element/class list=] value in
	[=ViewTransition/named elements=] for the pseudo-element's 'view-transition-name' [=list/contains=] all of those values.

	The [=specificity=] of a [=named view transition pseudo-element=] [=selector=] with either:
		* a <<pt-name-selector>> with a <<custom-ident>>; or
		* a <<pt-class-selector>> with at least one <<custom-ident>>,

	is equivalent to a [=type selector=].

	The [=specificity=] of a [=named view transition pseudo-element=] [=selector=]
	with a ''*'' argument and with an empty <<pt-class-selector>> is zero.

# Extending {{Document/startViewTransition|document.startViewTransition()}} # {#extend-document-types}
	<xmp class=idl>
		dictionary StartViewTransitionOptions {
			ViewTransitionUpdateCallback? update = null;
			sequence<DOMString>? types = null;
		};

		partial interface Document {
			ViewTransition startViewTransition(optional (ViewTransitionUpdateCallback or StartViewTransitionOptions) callbackOptions = {});
		};
	</xmp>


	<div algorithm="start-vt-with-options">
		The [=method steps=] for <dfn method for=Document>startViewTransition(|callbackOptions|)</dfn> are as follows:

		1. Let |updateCallback| be null.

		1. If |callbackOptions| is a {{ViewTransitionUpdateCallback}}, set |updateCallback| to |callbackOptions|.

		1. Otherwise, if |callbackOptions| is a {{StartViewTransitionOptions}}, then set |updateCallback| to |callbackOptions|'s {{StartViewTransitionOptions/update}}.

		1. If |this|'s [=active view transition=] is not null and its [=outbound post-capture steps=] is not null,
			then:

			1. Let |preSkippedTransition| be a new {{ViewTransition}} in |this|'s [=relevant realm=] whose [=ViewTransition/update callback=] is |updateCallback|.

				Note: The |preSkippedTransition|'s {{ViewTransition/types}} are ignored here because the transition is never activated.

			1. [=Skip the view transition|Skip=] |preSkippedTransition| with an "{{InvalidStateError}}" {{DOMException}}.

			1. Return |preSkippedTransition|.

			Note: This ensures that a same-document transition that started after firing {{Window/pageswap}} is skipped.

		1. Let |viewTransition| be the result of running the [=method steps=] for {{Document/startViewTransition(updateCallback)}} given |updateCallback|.

		1. If |callbackOptions| is a {{StartViewTransitionOptions}}, set |viewTransition|'s [=ViewTransition/active types=] to a [=list/clone=] of {{StartViewTransitionOptions/types}} as a [=/set=].

		1. Return |viewTransition|.
	</div>

# Determining 'view-transition-name' automatically # {#auto-vt-name}

## Overview ## {#auto-vt-name-overview}

*This section is non-normative.*

For an element to participate in a view transition, it needs to receive a unique 'view-transition-name'.
This can be tedious and verbose when multiple elements are involved in the same view transition, especially in cases where many of those are same-element transitions,
as in, the element has the same 'view-transition-name' in the old and new state.

To make this easier, setting the 'view-transition-name' to ''view-transition-name/auto'' would generate a 'view-transition-name' for the element, or take it from the element's [=Element/id=] if present.

## Examples ## {#auto-vt-name-example}

<div class="example">
In this example, view transition is used to sort a list in an animated way:

```html
<ul>
	<li>Item 1</li>
	<li>Item 2</li>
	<li>Item 3</li>
	<li>Item 4</li>
	...
</ul>
```

Ordinarily, each of these items would have to receive a unique 'view-transition-name':

```css
li:nth-child(1) { view-transition-name: item1; }
li:nth-child(2) { view-transition-name: item1; }
li:nth-child(3) { view-transition-name: item1; }
li:nth-child(4) { view-transition-name: item1; }
...
```

With ''view-transition-name/auto'', this CSS would work:

```css
li {
	view-transition-name: auto;
}
```
</div>

## Additions to 'view-transition-name' ## {#additions-to-vt-name}

In addition to the existing values, the 'view-transition-name' also accepts an <dfn for=view-transition-name type=value export>auto</dfn> keyword.
To resolve the [=used value=] of 'view-transition-name' for |element|:
	1. Let |computed| be the [=computed value=] of 'view-transition-name'.
	1. If |computed| is <css>none</css>, return null.
	1. If |computed| is a <<custom-ident>>, return |computed|.
	1. Assert: |computed| is <css>auto</css>.
	1. If |element| has an associated [=Element/id=], and |computed| is associated with the same [=tree/root=] as |element|'s [=tree/root=], then return the value of |element|'s [=Element/id=].

		Note: this means that a ''::part()'' pseudo-element wouldn't resolve to its matching element's [=Element/id=].

	1. Return a unique string. The string should remain consistent and unique for this element and {{Document}}, at least for the lifetime of |element|'s [=node document=]'s [=active view transition=].

		Note: this string is not web-observable, and is used for addressing the element in internal algorithms.

		Note: When used in a cross-document view transition, generated <css>auto</css> values never match, resulting in separate ''::view-transition-group()'' pseudo-elements, one exiting and one entering.

A 'view-transition-name' generated by <css>auto</css> is a [=tree-scoped name=].

# Nested view-transitions # {#nested-view-transitions}

## Overview ## {#nested-overview}

*This section is non-normative.*

By default, setting `view-transition-name` on multiple elements generates a flat [=view transition tree=], where all the ''::view-transition-group()'' pseudo-elements are children of the ''::view-transition'' pseudo-element.
This is sufficient for many simple use-cases, but there are some styling use-cases that cannot be achieved with a flat tree.
The most prominent use-case is clipping: with a flat tree, all pseudo-elements are clipped to the [=snapshot containing block=], so clipping elements in the normal tree would lose their clipping during the view-transition, resulting in a broken visual effect.
The effects that have can have an unexpected visual effect in a flat tree:
* Clipping ('overflow', 'clip-path', 'border-radius'): clipping affects the children of the element.
* 'opacity', 'mask-image' and 'filter': These effects that are designed to work on a fully rasterized image of a tree, rather than on each item individually.
* 3D transforms ('transform-style', 'transform', 'perspective'): to display the full range of 3D transform animations, some hierarchy needs to be kept.

To enable these use cases, this specification introduces the concept of nesting view-transition pseudo-elements. By using the 'view-transition-group' CSS property,
the author can assign a "parent group" for a generated ''::view-transition-group()'' pseudo-element, creating a hierarchy in the [=view transition tree=].

## Examples ## {#nested-vt-example}

<div class="example">
This example creates a transition where the [=view transition tree=] is nested instead of flat:

```html
<section class="container">
	<article>Content</article>
</section>
```

```css
.container {
	view-transition-name: container;
}

.container,
::view-transition-group(container) {
	clip-path: circle();
}

article {
	view-transition-name: article;
	view-transition-group: container;
}
```

By applying the ''clip-path'' to both the containing element and its generated pseudo-element, we preserve the clip during the transition,
and by applying ''view-transition-group'' to the internal element referencing the container, we make the tree "nested" in a way that would apply this clipping.
</main>

## The 'view-transition-group' property ## {#view-transition-group-prop}

	<pre class=propdef>
	Name: view-transition-group
	Value: normal | contain | nearest | <<custom-ident>>
	Initial: normal
	Inherited: no
	Percentages: n/a
	Computed Value: as specified
	Animation type: discrete
	</pre>

	The 'view-transition-group' property can be used in conjuction with 'view-transition-name' to generate a hierarchy of [=named view transition pseudo-element=].

	The [=used value=] for 'view-transition-group' resolves to a 'view-transition-name' in its ancestor chain, or to ''view-transition-name/none''. When generating the [=named view transition pseudo-element=], the ''::view-transition-group()'' with that name
	would be the parent of the ''::view-transition-group()'' generated for this element's 'view-transition-name'.

# Algorithms # {#algorithms}

## Data structures ## {#cross-doc-data-structures}

### Additions to {{Document}} ### {#cross-doc-data-structure-document}
A {{Document}} additionaly has:

<dl dfn-for=document>
	: <dfn>inbound view transition params</dfn>
	:: a [=view transition params=], or null.
		Initially null.

	: <dfn>can initiate outbound view transition</dfn>
	:: a boolean.
		Initially false.

		Note: this value can be read [=in parallel=] while navigating.
</dl>

### Additions to {{ViewTransition}} ### {#cross-doc-data-structure-vt}
A {{ViewTransition}} additionally has:
<dl dfn-for=ViewTransition>
	: <dfn>active types</dfn>
	:: A {{ViewTransitionTypeSet}}, initially empty.

	: <dfn>outbound post-capture steps</dfn>
	:: Null or a set of steps, initially null.
</dl>

### Serializable [=view transition params=] ### {#cross-doc-data-structure-serialization}
A <dfn>view transition params</dfn> is a [=struct=] whose purpose is to serialize view transition information across documents.
It has the following [=struct/items=]:

<dl dfn-for="view transition params">
	: <dfn>named elements</dfn>
	:: a [=/map=], whose keys are strings and whose values are [=captured elements=].

	: <dfn>initial snapshot containing block size</dfn>
	:: a [=tuple=] of two numbers (width and height).
</dl>

## Additions to the view transition page-visibility change steps ## {#page-visibility-change-steps-additions}
	<div algorithm="visibility change step additions">
	The next steps are appended to the tasks [=view transition page-visibility change steps=] given |document|, after the current steps in the queued task:

	1. Set |document|'s [=inbound view transition params=] to null.

	Note: this is called from the HTML spec.
	</div>



### Captured elements extension ### {#capture-classes-data-structure}
The [=captured element=] struct should contain these fields, in addition to the existing ones:
	<dl>
		: <dfn for="captured element">class list</dfn>
		:: a [=/list=] of strings, initially empty.

		: <dfn for="captured element">containing group name</dfn>
		:: Null or a string, initially null.

		: <dfn for="captured element">transform from snapshot containing block</dfn>
		:: A [=matrix=], initially the identity matrix.
	</dl>

## Resolving the ''@view-transition'' rule ## {#vt-rule-algo}
	<div algorithm>
		To <dfn>resolve @view-transition rule</dfn> for a {{Document}} |document|:

		Note: this is called in both the old and new document.

		1. If |document|'s [=Document/visibility state=] is "<code>hidden</code>",
			then return "<code>skip transition</code>".

		1. Let |matchingRule| be the last ''@view-transition'' rule in |document|.

		1. If |matchingRule| is not found, then return "<code>skip transition</code>".

		1. If |matchingRule|'s [=@view-transition/navigation=] descriptor's [=computed value=] is ''@view-transition/navigation/none'', then return "<code>skip transition</code>".

		1. Assert: |matchingRule|'s [=@view-transition/navigation=] descriptor's [=computed value=] is ''@view-transition/navigation/auto''.

		1. Let |typesDescriptor| be |matchingRule|'s [=@view-transition/types=] descriptor.

		1. If |typesDescriptor|'s [=computed value=] is ''@view-transition/type/none'', then return a [=/set=] « ».

		1. Return a [=/set=] of strings corresponding to |typesDescriptor|'s [=computed value=].
	</div>

## Setting up the view transition in the old {{Document}} ## {#setup-old-document-vt}

### Check eligibility for outbound cross-document view transition ### {#check-eligibility}
<div algorithm>
	To check if a <dfn export>navigation can trigger a cross-document view-transition?</dfn> given
	a {{Document}} |oldDocument|, a {{Document}} |newDocument|, a {{NavigationType}} |navigationType|, and a boolean |isBrowserUINavigation|:

		Note: this is called during navigation, potentially [=in parallel=].

	1. If the user agent decides to display an [=implementation-defined=] navigation experience, e.g. a gesture-based transition for a back navigation,
		the user agent may ignore the author-defined view transition. If that is the case, return false.

	1. If |oldDocument|'s [=can initiate outbound view transition=] is false, then return false.

	1. If |navigationType| is {{NavigationType/reload}}, then return false.

	1. If |oldDocument|'s [=Document/origin=] is not [=same origin=] as |newDocument|'s [=Document/origin=], then return false.

	1. If |newDocument| [=was created via cross-origin redirects=] and |newDocument|'s [=latest entry=] is null, then return false.

		Note: A [=Document=]'s [=latest entry=] would be null if this is a new navigation, rather than a restore from BFCache.

	1. If |navigationType| is {{NavigationType/traverse}}, then return true.

	1. If |isBrowserUINavigation| is true, then return false.

	1. Return true.
</div>

### Setup the outbound transition when ready to swap pages ### {#setup-outbound-transition}
<div algorithm>
	To <dfn export>setup cross-document view-transition</dfn> given a {{Document}} |oldDocument|,
	a {{Document}} |newDocument|, and |proceedWithNavigation|, which is an algorithm accepting nothing:

	Note: This is called from the HTML spec.

	1. [=Assert=]: These steps are running as part of a [=task=] queued on |oldDocument|.

	1. If |oldDocument|'s [=can initiate outbound view transition=] is false, then return null.

	1. Let |transitionTypesFromRule| be the result of [=Resolve @view-transition rule|resolving the @view-transition rule=] for |oldDocument|.

	1. [=Assert=]: |transitionTypesFromRule| is not "<code>skip transition</code>".

		Note: We don't know yet if |newDocument| has opted in, as it might not be parsed yet.
		We check the opt-in for |newDocument| when we fire the {{Window/pagereveal}} event.

	1. If |oldDocument|'s [=active view transition=] is not null,
		then [=skip the view transition|skip=] |oldDocument|'s [=active view transition=]
		with an "{{AbortError}}" {{DOMException}} in |oldDocument|'s [=relevant Realm=].

		Note: this means that any running transition would be skipped when the document is ready
		to unload.

	1. Let |outboundTransition| be a new {{ViewTransition}} object in |oldDocument|'s [=relevant Realm=].

	1. Set |outboundTransition|'s [=ViewTransition/active types=] to |transitionTypesFromRule|.

		Note: the [=ViewTransition/active types=] are not shared between documents.
		Manipulating the {{ViewTransition/types}} in the new document does not affect the types in |newDocument|,
		which would be read from the [=@view-transition/types=] descriptor once |newDocument| is revealed.

		Note: the {{ViewTransition}} is skipped once the old document is hidden.

	1. Set |outboundTransition|'s [=outbound post-capture steps=] to the following steps given a [=view transition params=]-or-null |params|:
		1. Set |newDocument|'s [=inbound view transition params=] to |params|.

			Note: The inbound transition is activated after the dispatch of {{Window/pagereveal}} to ensure mutations made in this event apply to the captured new state.

		1. To skip the transition after a timeout, the user agent may perform the following steps [=in parallel=]:

			1. Wait for an [=implementation-defined=] [=duration=].

			1. [=Queue a global task=] on the [=DOM manipulation task source=] given |newDocument|'s [=relevant global object=] to perform the following step:

				1. If |newDocument|'s [=inbound view transition params=] is |params|, then set |newDocument|'s [=inbound view transition params=] to null.

		1. Call |proceedWithNavigation|.

	1. Set |oldDocument|'s [=active view transition=] to |outboundTransition|.

		Note: The process continues in [=perform pending transition operations=].

	1. The user agent should display the currently displayed frame until either:
		* The {{Window/pagereveal}} event is fired.
		* its [=active view transition=]'s [=ViewTransition/phase=] is "`done`".

		Note: this is to ensure that there are no unintended flashes between displaying the old and new state, to keep the transition smooth.

	1. Return |outboundTransition|.
</div>

### Update the opt-in flag to reflect the current state ### {#update-opt-in}
<div algorithm="update-opt-in-for-outbound">
To <dfn>update the opt-in state for outbound transitions</dfn> for a {{Document}} |document|:
	1. If |document| [=has been revealed=], and the result of [=resolve @view-transition rule|resolving the @view-transition rule=] is not "<code>skip transition</code>",
		then set |document|'s [=can initiate outbound view transition=] to true.
	1. Otherwise, set |document|'s [=can initiate outbound view transition=] to false.
</div>

### Proceed with navigation if view transition is skipped ### {#proceed-if-skipped}
<div algorithm="additional skip steps">
	Append the following steps to [=skip the view transition=] given a {{ViewTransition}} |transition|:
		1. If |transition|'s [=outbound post-capture steps=] is not null, then run |transition|'s [=outbound post-capture steps=] with null.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

### Proceed with cross-document view transition after capturing the old state ### {#cross-doc-after-capture}
<div algorithm="additional transition operation">
Prepend the following step to the [=Perform pending transition operations=] algorithm given a {{Document}} |document|:
	1. If |document|'s [=active view transition=] is not null and its [=outbound post-capture steps=] is not null, then:

		1. Assert: |document|'s [=active view transition=]'s  [=ViewTransition/phase=] is "`pending-capture`".

		1. Let |viewTransitionParams| be null;

		1. Set |document|'s [=document/rendering suppression for view transitions=] to true.

			Issue: Though [=capture the old state=] appears here as a synchronous step, it is in fact an asynchronous step
			as rendering an element into an image cannot be done synchronously. This should be more explicit in the L1 spec.

		1. [=Capture the old state=] for |transition|.

		1. If this succeeded, then set |viewTransitionParams| to a new [=view transition params=] whose
			[=view transition params/named elements=] is a [=map/clone=] of |transition|'s [=ViewTransition/named elements=],
			and whose [=view transition params/initial snapshot containing block size=] is |transition|'s [=ViewTransition/initial snapshot containing block size=].

		1. Set |document|'s [=document/rendering suppression for view transitions=] to false.

		1. Call |transition|'s [=outbound post-capture steps=] given |viewTransitionParams|.

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

## Activating the view transition in the new {{Document}} ## {#access-view-transition-in-new-doc}

<div algorithm>
	To <dfn export>resolve inbound cross-document view-transition</dfn> for {{Document}} |document|:

	1. [=Assert=]: |document| is [=fully active=].

	1. [=Assert=]: |document| [=has been revealed=] is true.

	1. [=Update the opt-in state for outbound transitions=] for |document|.

	1. Let |inboundViewTransitionParams| be |document|'s [=inbound view transition params=].

	1. If |inboundViewTransitionParams| is null, then return null.

	1. Set |document|'s [=inbound view transition params=] to null.

	1. If |document|'s [=active view transition=] is not null, then return null.

		Note: this means that starting a same-document transition before revealing the document would cancel a pending cross-document transition.

	1. [=Resolve @view-transition rule=] for |document| and let |resolvedRule| be the result.

	1. If |resolvedRule| is "<code>skip transition</code>", then return null.

	1. Let |transition| be a new {{ViewTransition}} in |document|'s [=relevant Realm=],
		whose [=ViewTransition/named elements=] is |inboundViewTransitionParams|'s [=view transition params/named elements=],
		and [=ViewTransition/initial snapshot containing block size=] is |inboundViewTransitionParams|'s [=view transition params/initial snapshot containing block size=].

	1. Set |document|'s [=active view transition=] to |transition|.

	1. [=Resolve=] |transition|’s [=ViewTransition/update callback done promise=] with undefined.

	1. Set |transition|’s [=ViewTransition/phase=] to "`update-callback-called`".

	1. Set |transition|'s [=ViewTransition/active types=] to |resolvedRule|.


	1. Return |transition|.
</div>

## Capturing the 'view-transition-class' ## {#vt-class-algorithms}

<div algorithm="additional capture steps">
When capturing the old or new state for an element, perform the following steps given a [=captured element=] |capture| and an [=element=] |element|:

	1. Set |capture|'s [=captured element/class list=] to the [=computed value=] of |element|'s 'view-transition-class', if it is associated with |element|'s [=node document=].

	Note: This is written in a monkey-patch manner, and will be merged into the algorithm once the L1 spec graduates.
</div>

## Capturing and applying 'view-transition-group' ## {#vt-group-algorithm}

### Resolving the 'view-transition-group' value ### {#vt-group-value-resolve}

<div algorithm="resolve the document-scoped view-transition-group">
To get the <dfn>document-scoped view transition group</dfn> of an {{Element}} |element|, perform the following steps:

	1. Let |computedGroup| be the [=computed value=] of element's 'view-transition-group' property.
	1. If |computedGroup| is associated with |element|'s [=node document=], return |computedGroup|.
	1. Return ''view-transition-group/normal''.
</div>

### Resolving the containing group name ### {#vt-containing-group-name-resolve}

<div algorithm="resolve nearest containing group name">

To resolve the <dfn>nearest containing group name</dfn> of an {{Element}} |element|, perform the following steps given a {{ViewTransition}} |viewTransition|:
	1. Assert: |element| participates in |viewTransition|.
	1. Let |ancestorGroup| be |element|'s nearest [=flat tree=] [=tree/ancestor=] who participates in |viewTransition| and whose [=document-scoped view transition group=] is not ''view-transition-group/normal''.
	1. If |ancestorGroup| exists, return |ancestorGroup|'s [=document-scoped view transition name=].
	1. Return ''view-transition-name/none''.
</div>

### Resolving the group name ### {#vt-group-name-resolve}

<div algorithm="resolve used group name">
To resolve the <dfn>used group name</dfn> of an {{Element}} |element|, perform the following steps given a {{ViewTransition}} |transition|:

	1. Assert: |element| participates in |transition|.
	1. Let |group| be |element|'s [=document-scoped view transition group=].
	1. Let |containingGroupName| be |element|'s [=nearest containing group name=] given |transition|.
	1. Return the first matching statement, switching on |group|:

	<dl dfn-type=value dfn-for=view-transition-group>
		: <dfn>normal</dfn>
		: <dfn>contain</dfn>
		:: |containingGroupName|.

			Note: an element with ''view-transition-group/contain'' becomes the [=nearest containing group name=] for its descendants.

		: <dfn>nearest</dfn>
		:: The [=document-scoped view transition name=] of the element's nearest [=flat tree=] ancestor which participates in the |transition|.

		: <dfn><<custom-ident>></dfn>
		:: |group| if the element has a [=flat tree=] [=tree/ancestor=] whose [=document-scoped view transition name=] is |group| and participates in |transition|; Otherwise |containingGroupName|.
	</dl>
</div>

### Compute the old 'view-transition-group' ### {#vt-group-capture-old}
<div algorithm="additional old capture steps (group)">
When  [[css-view-transitions-1#capture-old-state-algorithm|capturing the old state for an element]], perform the following steps given a [=captured element=] |capturedElement|, a {{ViewTransition}} |transition|, and an [=element=] |element|:

	1. Set |capturedElement|'s [=captured element/containing group name=] to |element|'s [=used group name=] given |transition|.
</div>

### Compute the new 'view-transition-group' ### {#vt-group-capture-new}
<div algorithm="additional new capture steps (group)">
When [[css-view-transitions-1#capture-new-state-algorithm|capturing the new state for an element]], perform the following steps given a [=captured element=] |capturedElement| a {{ViewTransition}} |transition|, and an [=element=] |element|:

	1. Set |capturedElement|'s [=captured element/containing group name=] to |element|'s [=used group name=] given |transition|.
</div>

### Reparent a ''::view-transition-group()'' to its specified containing group ### {#vt-group-reparent}
<div algorithm="additional pseudo-element setup steps (group)">
When [[css-view-transitions-1#setup-transition-pseudo-elements-algorithm|setting up the transition pseudo-element]] for a [=captured element=] |capturedElement|, given a |transitionName| and a |transition|:

	1. Let |containingGroupName| be |capturedElement|'s [=containing group name=].
	1. If |containingGroupName| is not null, then:

		1. Let |groupContainerElement| be |transition|'s [=ViewTransition/named elements=][|containingGroupName|].

		1. Let |group| be the ''::view-transition-group()'',
			whose [=view transition name=] is set to |transitionName|.

		1. Let |parentGroup| be the ''::view-transition-group()'',
			whose [=view transition name=] is set to |containingGroupName|.

		1. Append |group| to |parentGroup|.

		1. When setting the animation keyframes given |transform|, [=multiply=] |transform| by the inverse matrix of |groupContainerElement|'s [=old transform=].

	Note: It is TBD how this is resolved when the old and new groups mismatch. See <a href="https://github.com/w3c/csswg-drafts/issues/10631">Issue 10631</a>.
</div>

### Adjust the group's 'transform' to be relative to its containing ''::view-transition-group()'' ### {#vt-group-transform-adjust}
<div algorithm="additional pseudo-element style update steps (group)">
When [[css-view-transitions-1#style-transition-pseudo-elements-algorithm|updating the style of the transition pseudo-element]], perform the following steps before setting the [=captured element/group styles rule=], given a [=captured element=] |capturedElement|, given a |transform| and a {{ViewTransition}} |transition|:

	1. Set |capturedElement|'s [=transform from snapshot containing block=] to |transform|.

	1. If |capturedElement|'s [=containing group name=] is not null, then:

		1. Let |groupContainerElement| be |transition|'s [=ViewTransition/named elements=][|capturedElement|'s [=containing group name=]].

		1. [=Multiply=] |transform| by the inverse matrix of |groupContainerElement|'s [=transform from snapshot containing block=].
</div>



<h2 id="priv" class="no-num">Privacy Considerations</h2>

This specification introduces no new privacy considerations.

<h2 id="sec" class="no-num">Security Considerations</h2>

To prevent cross-origin issues, at this point cross-document view transitions can only be enabled for
same-origin navigations. As discussed in <a href="https://github.com/WICG/view-transitions/issues/200">WICG/view-transitions#200</a>,
this still presents two potential threats:

1. The [=environment settings object/cross-origin isolated capability=] in both documents might be different.
	This can cause a situation where a {{Document}} that is [=environment settings object/cross-origin isolated capability|cross-origin isolated=]
	can read image data from a document that is not cross-origin isolated. This is already mitigated in [[css-view-transitions-1#sec],
	as the same restriction applies for captured cross-origin iframes.

1. A same-origin navigation might still occur via a cross-origin redirect, e.g. <code>https://example.com</code>
	links to <code>https://auth-provider.com/</code> which redirects back to <code>https://example.com/loggedin</code>.

	This can cause a (minor) situation where the cross-origin party would redirect the user to an
	unexpected first-party URL, causing an unexpected transition and obfuscating that fact that there was a redirect.
	To mitigate this, currently view transitions are disabled for navigations if the {{Document}} [=was created via cross-origin redirects=].
	Note that this check doesn't apply when the {{Document}} is being [=Document/reactivated=], as in that case
	the cross-origin redirect has already taken place.

	Note: this only applies to server-side redirects. A client-side redirect, e.g. using
	[^meta/http-equiv/refresh^], is equivalent to a new navigation.

1. This feature exposes more information to CSS, as so far CSS was not aware of anything navigation-related.
	This can raise concerns around safety 3rd-party CSS. However, as a general rule, 3rd-party stylesheets should come
	from trusted sources to begin with, as CSS can learn about the document or change it in many ways.


See <a href="https://github.com/w3c/csswg-drafts/issues/8684">Issue #8684</a> and
<a href="https://github.com/WICG/view-transitions/issues/200">WICG/view-transitions#200</a> for
detailed discussion.
