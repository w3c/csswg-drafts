<h1>CSS Generated Content Module Level 3</h1>
<pre class='metadata'>
Status: ED
Work Status: Exploring
Shortname: css-content
Level: 3
Group: csswg
TR: https://www.w3.org/TR/css3-content/
ED: https://drafts.csswg.org/css-content/
Previous Version: https://www.w3.org/TR/2003/WD-css3-content-20030514/
Editor: Fantasai, W3C Invited Expert, http://fantasai.inkedblade.net/contact
Editor: Dave Cramer, Hachette Livre, dauwhe@gmail.com
Former Editor: Håkon Wium Lie, Opera Software, howcome@opera.com
Former Editor: Ian Hickson, Google, ian@hixie.ch
Ignored Terms: <datetime>, leader(), string(), target-counter(), target-counters(), target-text()
Abstract: This CSS3 Module describes how to insert content in a document.
Link Defaults: css21 (type) <uri>, css-display-3 (value) inline
Warning: Not Ready
</pre>


<!-- TODO:
 ! * Sync with CSS2.1 and GCPM
 ! * Clean up descriptions and organize into something coherent
 ! * place 'property' into marked up property elements
 ! * similarly with '::pseudo' and examples
 ! * http://lists.w3.org/Archives/Member/w3c-css-wg/2003JanMar/0170.html
 ! * string-set and co
 ! * need to increment the footnote, endnote and section-note counters
 ! * cross references, as in http://www.w3.org/Style/Group/2001/MO-css3-page-20010205
 ! * date() and time()
 ! * drop nesting
 !
 !-->

<h2 class="no-num" id="introduction">
	Introduction
</h2>


Authors sometimes want user agents to render content that does not come from the document tree. One familiar example of this is numbered headings; the author does not want to mark the numbers up explicitly, she or he wants the user agent to generate them automatically. Counters and markers are used to achieve these effects.
<div class="example">
<pre>
h1::before { content: counter(section) ": "; }
</pre>
</div>


Similarly, authors may want the user agent to insert the word "Figure" before the caption of a figure, or "Chapter 7" on a line before the seventh chapter title.


<div class="example">
<pre>
chapter { counter-increment: chapter; }
chapter > title::before { content: "Chapter " counter(chapter) "\A"; }
</pre>
</div>


Another common effect is replacing elements with images or other multimedia content. Since not all user agents support all multimedia formats, fallbacks may have to be provided.

<div class="example">
<pre>
/* Replace &lt;logo&gt; elements with the site's logo, using a format
 * supported by the UA */
logo { content: url(logo.mov), url(logo.mng), url(logo.png), none; }

/* Replace &lt;figure&gt; elements with the referenced document, or,
 * failing that, with either the contents of the alt attribute or the
 * contents of the element itself if there is no alt attribute */
figure[alt] { content: attr(href, url), attr(alt); }
figure:not([alt]) { content: attr(href, url), contents; }
</pre>
</div>




<h2 id="inserting-replacing-content">Inserting and replacing content with the 'content' property</h2>

<pre class='propdef'>
    Name: content
    Value: [ [ <<uri>> ] ',' ]* [ normal | none | inhibit | <<content-list>> ]
    Initial: normal
    Applies To: elements, pseudo-elements, and page margin boxes.
    Inherited: no
    Percentages: n/a
    Computed Value: As specified below.
    Media: all
</pre>

<p class="issue">We should be clear about which pseudo-elements can use the content property.

The 'content' property dictates what is rendered inside the element or pseudo-element. It takes a comma separated list of URIs, followed by a space separated list of tokens. If there are multiple URIs provided, then each is tried in turn until a value which is both available and supported is found. The last value is used as a fallback if the others fail.


<dl>

<dt><dfn>normal</dfn>
<dd>For an element, this computes to ''content/contents''.

	For ''::before'' and ''::after'', this computes to ''inhibit''.

<dt><dfn>none</dfn>
<dd>On elements, this inhibits the children of the element from being rendered as children of this element, as if the element was empty.

	On pseudo-elements it causes the pseudo-element to have no content.

	In neither case does it prevent any pseudo-elements which have this element or pseudo-element as a superior from being generated.

<dt><dfn>inhibit</dfn>
<dd>On elements, this inhibits the children of the element from being rendered as children of this element, as if the element was empty.

	On pseudo-elements, this inhibits the creation of the pseudo-element, as if 'display' computed to ''display/none''.

	In both cases, this further inhibits the creation of any pseudo-elements which have this pseudo-element as a superior.

	<p class="issue">Is ''inhibit'' still necessary, in the absence of multiple pseudo-elements?

<dt><dfn type><<content-list>></dfn>
<dd>
	[ <<string>> | contents |  <<uri>> | open-quote | close-quote | no-open-quote | no-close-quote | document-url | leader() ]+

See sections below for details on each of these.

</dl>

<!-- string was here-->









<h2 id="content-functions">
Content Values and Functions</h2>


<h3 id="content-string">
String</h3>

	<dl dfn-for="content, <content-list>" dfn-type=value>
		<dt><dfn><<string>></dfn>
		<dd>
			The element or pseudo-element contains the specified string. Occurrences of line-feed or space characters in the string are handled according to the properties given in the [[CSS3TEXT]] module.

			If the value is the empty string, and the element or pseudo-element's 'display' property computes to anything but ''inline'', then the element or pseude-element contains an empty anonymous inline box, otherwise the element contains an empty string.

			(This is a formal way of saying that an empty string is different from ''content/none'' in that it forces the creation of a line box, even if the line box would be empty.)

	</dl>

<h3 id="content-uri">
URI</h3>

	<dl dfn-type=value dfn-for=content>
		<dt><<uri>></dt>
		<dd>For URIs other than URIs in the last comma separated section of the value, if the URI is available and the format is supported, then the element or pseudo-element becomes a replaced element, otherwise, the next item in the comma separated list is used, if any.
	</dl>

	<div class="example">
		<pre>
		h1 { content: url(header/mng), url(header/png), none; }
		</pre>
	</div>

	In the example above, if <code>header/mng</code> wasn't in a supported format, then <code>header/png</code> would have been used instead. In the example above, if <code>header/png</code> wasn't available either, then the <code>&lt;h1&gt;</code> element would be empty, as the last alternative is ''content/none''.

	To make an element fallback on its contents, you have to explicitly give ''content/contents'' as a fallback:

	<div class="example">
		<pre>content: url(1), url(2), url(3), contents;</pre>
	</div>

	<p class="issue">What happens when no formats are supported, and the author does not explicitly indicate a fallback?

	<p class="issue">Why doesn't an element fallback to ''content/contents'' unless an author explicitly says so?

	If the URI is part of the last comma separated value in the list, as the second URI in the following example:

	<div class="example">
		<pre>h1 { content: url(welcome), "Welcome to: " url(logo); }</pre>
	</div>

	...then if the file is available and the format is supported, then an anonymous replaced inline element is inserted, otherwise the image is ignored (as if it hadn't been given at all).

	<p class="issue">There appears to be some change from [[CSS21]] which says, "If the user agent cannot display the resource it must either leave it out as if it were not specified or display some indication that the resource cannot be displayed." Are we now saying that a user agent cannot display a missing image graphic in this situation?

	When a URI is used as replaced content, it <a href="#replacedContent">affects the generation</a> of ''::before'' and ''::after'' pseudo-elements.







<h3 id="content-contents">
contents</h3>

<dl dfn-for="content, <content-list>" dfn-type=value>

		<dt><dfn>contents</dfn>
		<dd>The element's descendents. Since this can only be used once per element (you can't duplicate the children if, e.g., one is a plugin or form control), it is handled as follows:

			<p class="issue">Note that the Prince PDF Formatter does allow the contents of an element to also be used in a pseudo-element.

			: If set on the element:
			:: Always honoured. Note that this is the default, since the initial value of 'content' is ''content/normal'' and ''content/normal'' computes to ''content/contents'' on an element.
			: If set on one of the element's other pseudo-elements:
			:: Check to see that it is not set on a "previous" pseudo-element, in the following order, depth first:
				1. the element itself
				2. ::before
				3. ::after

			If it is already used, then it evaluates to nothing (like ''content/none''). Only pseudo-elements that are actually generated are checked.


</dl>


			<div class="example">
				In the following case:

				<pre>
				foo { content: normal; }   /* this is the initial value */
				foo::after { content: contents; }
				</pre>

				...the element's 'content' property would compute to ''content/contents'' and the after pseudo element would have no contents (equivalent to ''content/none'') and thus would not appear.

				<pre>
				foo { content: none; }
				foo::after { content: contents; }
				</pre>

				But in this example, the ::after pseudo-element will contain the contents of the foo element.
			</div>

			<p class="issue">Use cases for suppressing the content on the element and using it in a pseudo-element would be welcome.

			Note that while it is useless to include ''content/contents'' twice in a single 'content' property, that is not a parse error. The second occurrence simply has no effect, as it has already been used. It is also not a parse error to use it on a marker pseudo-element, it is only during the rendering stage that it gets treated like ''content/none''.

 <p class="issue">Do we need the statement about marker pseudo-elements here? Or is this legacy from the old version of the spec?




<h3 id="inserting-quotes">
Inserting quotes with the 'content' property
</h3>



	<dl dfn-for="content, <content-list>" dfn-type=value>

		<dt><dfn>open-quote</dfn> and <dfn>close-quote</dfn>
		<dd>These values are replaced by the appropriate string from the 'quotes' property. See [[#specifying-quotes]] for more information.
		<dt><dfn>no-open-quote</dfn> and <dfn>no-close-quote</dfn>
		<dd>Inserts nothing (as in ''content/none''), but increments (decrements) the level of nesting for quotes. See [[#specifying-quotes]] for more information.

	</dl>



<h3 id=content-datetime>
datetime
</h3>

	<dl dfn-for="content, <content-list>" dfn-type=value>
		<dt><dfn><<datetime>></dfn>
		<dd>Dates and times can be specified with two functions, 'date()' and 'time()'. See the section on dates and times for more information.
	</dl>

<h3>
document-url
</h3>

	<dl dfn-for="content, <content-list>" dfn-type=value>
		<dt><dfn>document-url</dfn>
		<dd>The URI of the current document. For local files, this may simply be the local file name.
	</dl>




<h3>
leader()
</h3>

	<dl dfn-for="content, <content-list>" dfn-type=value>
		<dt><dfn>leader()</dfn>
		<dd>Inserts a leader. See the section on <a href="#leaders">leaders</a> for more information.
	</dl>

<h3 id="cross-references">
Cross-references
</h3>


Many documents contain internal references:
<ul>
<li> See chapter 7
<li> in section 4.1
<li> on page 23
</ul>
Three new values for the content property are used to automatically create these types of cross-references: ''target-counter()'', ''target-counters()'', and ''target-text()''. Each of these displays information obtained from the target end of a link.
<h3 id="target-counter">
The ''target-counter()'' function
</h3>
The ''target-counter()'' function retrieves the value of the innermost counter with a given name. The required arguments are the url of the target and the name of the counter. An optional counter-style argument can be used to format the result.


<p class="note">These functions only take a fragment URL which points to a location in the current document. If there’s no fragment, if the ID referenced isn't there, or if the URL points to an outside document, the user agent must treat that as an error.

<pre class="prod">
	<dfn>target-counter()</dfn> = target-counter( <<url>> , <<custom-ident>> [ , <<counter-style>> ]? )
</pre>
<div class="example">
HTML:

<pre>
…which will be discussed on page &lt;a href="#chapter4_sec2">&lt;/a>.
</pre>
CSS:

<pre>
a::after { content: target-counter(attr(href url), page) }
</pre>
Result:
<pre>
…which will be discussed on page 137.
</pre>
</div>

<div class="example">
Page numbers in tables of contents can be generated automatically:

HTML:

<pre>
&lt;nav>
  &lt;ol>
    &lt;li class="frontmatter">&lt;a href="#pref_01">Preface&lt;/a>&lt;/li>
    &lt;li class="frontmatter">&lt;a href="#intr_01">Introduction&lt;/a>&lt;/li>
    &lt;li class="bodymatter">&lt;a href="#chap_01">Chapter One&lt;/a>&lt;/li>
  &lt;/ol>
&lt;/nav>
</pre>

CSS:

<pre>
.frontmatter a::after { content: leader('.') target-counter(attr(href url), page, lower-roman) }
.bodymatter a::after { content: leader('.') target-counter(attr(href url), page, decimal) }
</pre>

Result:

<pre>
Preface.............vii
Introduction.........xi
Chapter One...........1
</pre>

</div>



<h4 id="target-counters">
The ''target-counters()'' function
</h4>
This functions fetches the value of all counters of a given name from the end of a link, and formats them by inserting a given string between the value of each nested counter.

<pre class="prod">
	<dfn>target-counters()</dfn> = target-counter( <<url>> , <<custom-ident>> , <<string>> [ , <<counter-style>> ]? )
</pre>

<div class="example">

<pre>
I have not found a compelling example for target-counters() yet.
</pre>

</div>

<h4 id="target-text">
target-text
</h4>
The ''target-text()'' function retrieves the text value of the element referred to by the URL. An optional second argument specifies what content is retrieved, using the same values as the 'string-set' property above.

<pre class="prod">
	<dfn id="target-text-function">target-text()</dfn> = target-counter( <<url>> [ , [ content | before | after | first-letter] ]? )
</pre>


<p class="issue">A simpler syntax has been proposed by fantasai: http://lists.w3.org/Archives/Public/www-style/2012Feb/0745.html
<div class="example">
<pre>
…which will be discussed &lt;a href="#chapter_h1_1">later&lt;/a>.

a::after { content: ", in the chapter entitled " target-text(attr(href url)) }

</pre> Result: …which will be discussed later, in the chapter entitled Loomings.
</div>



<h3 id="named-strings">
Named strings</h3>

CSS3 introduces 'named strings', which are the textual equivalent of counters and which have a distinct namespace from counters. Named strings follow the same nesting rules as counters. The 'string-set' property accepts values similar to the 'content' property, including the extraction of the current value of counters.

Named strings are a convenient way to pull metadata out of the document for insertion into headers and footers. In HTML, for example, META elements contained in the document HEAD can set the value of named strings. In conjunction with attribute selectors, this can be a powerful mechanism:

<pre>
meta[author] { string-set: author attr(author); }
head &gt; title { string-set: title contents; }
@page:left {
  @top {
    text-align: left;
    vertical-align: middle;
    content: string(title);
  }
}
@page:right {
  @top {
    text-align: right;
    vertical-align: middle;
    content: string(author);
  }
}
</pre>


<!--Begin insert from GCPM3 -->


The 'string-set' property copies the text content of an element into a ''named string'', which functions as a variable. The text content of this named string can be retrieved using the ''string()'' function. Since these variables may change on a given page, an optional second value for the ''string()'' function allows authors to choose which value on a page is used.

<h4 id="setting-named-strings-the-string-set-pro">The string-set property</h4>

<pre class="propdef">
Name: string-set
Value: [ <<custom-ident>> <<string>>+ ]# | none
Initial: none
Applies to: all elements, but not pseudo-elements
Inherited: no
Percentages: N/A
Media: all
Computed value: specified value
</pre>

<dl dfn-type=value dfn-for=string-set>
	<dt><dfn>none</dfn>
	<dd>
		The element does not set any named strings.

	<dt><code>[ <<custom-ident>> <<string>>+ ]#</code>
	<dd>
		The element establishes one or more named strings,
		corresponding to each comma-separated entry in the list.

		For each entry, the <<custom-ident>> gives the name of the named string.
		It's followed by one or more <<string>> values,
		which are concatenated together to form the value of the named string.
</dl>


<h4 id="content-function-header">The ''content()'' function</h4>

<pre class="prod">
	<dfn>content()</dfn> = content( [text | before | after | first-letter ]? )
</pre>


<dl dfn-type="value" dfn-for="content()">
	<dt><dfn>text</dfn>
	<dd>The string value of the element, determined as if ''white-space: normal'' had been set.
		If no value is specified in ''content()'',
		it acts as if ''content()/text'' were specified.
	<dt><dfn>before</dfn>
	<dd>The string value of the ''::before'' pseudo-element, determined as if ''white-space: normal'' had been set.
	<dt><dfn>after</dfn>
	<dd>The string value of the ''::after'' pseudo-element, determined as if ''white-space: normal'' had been set.
	<dt><dfn>first-letter</dfn>
	<dd>The first letter of the element, as defined for the ''::first-letter'' pseudo-element
</dl>

The content values of named strings are assigned at the point when the content box of the element is first created (or would have been created if the element’s display value is none). The <dfn>entry value</dfn> for a page is the assignment in effect at the end of the previous page. The <dfn>exit value</dfn> for a page is the assignment in effect at the end of the current page.

Whenever the value of the element changes, the value of the named string(s) is updated. User agents must be able to recall many values of the named string, as the ''string()'' function can return past, current, or future values of the assignment.

<div class="example">
	HTML:

	<pre>
	&lt;h1>Loomings&lt;/h1>
	</pre>

	CSS:

	<pre>
	h1::before { content: 'Chapter ' counter(chapter); }
	h1 { string-set: header content(before) ':' content(text); }
	h1::after { content: '.'; }
	</pre>

	The value of the named string “header” will be “Chapter 1: Loomings”.
</div>

<div class="example">
	HTML:

	<pre>
	&lt;section title="Loomings">
	</pre>

	CSS:

	<pre>
	section { string-set: header attr(title) }
	</pre>

	The value of the “header” string will be “Loomings”.
</div>


<h4 id="using-named-strings">The ''string()'' function</h4>

The ''string()'' function is used to copy the value of a named string to the document, via the 'content' property. This function requires one argument, the name of the named string. Since the value of a named string may change several times on a page (as new instances of the element defining the string appear) an optional second argument indicates which value of the named string should be used.

<pre class="prod">
	<dfn>string()</dfn> = string( <<custom-ident>> , [ first | start | last | first-except ]? )
</pre>


The second argument of the ''string()'' function is one of the following keywords:
<dl dfn-type="value" dfn-for="string()">
	<dt><dfn>first</dfn>
	<dd>The value of the first assignment on the page is used. If there is no assignment on the page, the <a>entry value</a> is used. If no second argument is provided, this is the default value.
	<dt><dfn>start</dfn>
	<dd>If the element is the first element on the page, the value of the first assignment is used. Otherwise the <a>entry value</a> is used. The <a>entry value</a> may be empty if the element hasn’t yet appeared.
	<dt><dfn>last</dfn>
	<dd>The <a>exit value</a> of the named string is used.
	<dt><dfn>first-except</dfn>
	<dd>This is identical to ''string()/first'', except that the empty string is used on the page where the value is assigned.
</dl>



<div class="example">
	CSS:

	<pre>
	@page {
	   size: 15cm 10cm;
	   margin: 1.5cm;

	   @top-left {
	   content: "first: " string(heading, first);
	   }
	   @top-center {
	   content: "start: " string(heading, start);
	   }
	    @top-right {
	    content: "last: " string(heading, last);
	   }
	  }

	h2 { string-set: heading content() }
	</pre>

	The following figures show the first, start, and last assignments of the “heading” string on various pages.

	<figure>
		<img src="images/using-strings-1.jpg" width="480" alt=""/>
		<figcaption>The ''string-set/start'' value is empty, as the string had not yet been set at the start of the page.</figcaption>
	</figure>
	<figure>
		<img src="images/using-strings-2.jpg" width="480" alt=""/>
		<figcaption>Since the page starts with an h2, the ''string-set/start'' value is the value of that head.</figcaption>
	</figure>
	<figure>
		<img src="images/using-strings-3.jpg" width="480" alt=""/>
		<figcaption>Since there’s not an h2 at the top of this page, the ''string-set/start'' value is the <a>exit value</a> of the previous page.</figcaption>
	</figure>
</div>

<!--end of insert from GCPM3 -->





<div class="example">
	The following example captures the contents of H1 elements, which represent chapter names in this hypothetical document.

	<pre>H1 { string-set: chapter contents; }</pre>

	When an H1 element is encountered, the ''chapter'' string is set to the element's textual contents, and the previous value of ''chapter'', if any, is overwritten.
</div>







<h3 id="leaders">
Leaders</h2>

A leader, sometimes known as a tab leader or a dot leader, is a repeating pattern used to visually connect content across horizontal spaces. They are most commonly used in tables of contents, between titles and page numbers. The ''leader()'' function, as a value for the content property, is used to create leaders in CSS. This function takes a string (the leader string), which describes the repeating pattern for the leader.


<pre class="propdef partial">
	Name: content
	New values: leader()
	Media: paged
</pre>

<pre class="prod">
		<dfn>leader()</dfn> = leader( dotted | solid | space | <<string>>);
</pre>

Three keywords are shorthand values for common strings:

<dl dfn-type=value dfn-for="leader()">
	<dt><dfn>dotted</dfn>
	<dd>Equivalent to ''leader(".")''
	<dt><dfn>solid</dfn>
	<dd>Equivalent to ''leader("_")''
	<dt><dfn>space</dfn>
	<dd>Equivalent to ''leader(" ")''
	<dt><dfn><<string>></dfn>
	<dd>
		Issue: Define this.
</dl>

<div class="example">
	<pre>
	ol.toc a::after {
	  content: leader('.') target-counter(attr(href), page);
	}

	&lt;h1>Table of Contents&lt;/h1>
	&lt;ol class="toc">
	&lt;li>&lt;a href="#chapter1">Loomings&lt;/a>&lt;/li>
	&lt;li>&lt;a href="#chapter2">The Carpet-Bag&lt;/a>&lt;/li>
	&lt;li>&lt;a href="#chapter3">The Spouter-Inn&lt;/a>&lt;/li>
	&lt;/ol>

	</pre>

	This might result in:

	<pre>
	Table of Contents

	1. Loomings.....................1
	2. The Carpet-Bag...............9
	3. The Spouter-Inn.............13
	</pre>
</div>

<p class="issue">
Do leaders depend on the assumption that the content after the leader is right-aligned (end-aligned)?

<h4 id="rendering-leaders">
Rendering leaders
</h4>
Consider a line which contains the content before the leader (the “before content”), the leader, and the content after the leader (the “after content”). Leaders obey the following rules:
<ol>
<li>The leader string must appear in full at least once.
<li>The leader should be as long as possible
<li>Visible characters in leaders should vertically align with each other when possible.
<li>Line break characters in the leader string must be ignored.
<li>White space in the leader string follows normal CSS rules.
<li>A leader only appears between the start content and the end content.
<li>A leader only appears on a single line, even if the before content and after content are on different lines.
<li>A leader can’t be the only thing on a line.
</ol>
<h4 id="procedure-leader">
Procedure for rendering leaders
</h4>
<ol>
<li> Lay out the before content, until reaching the line where the before content ends. <pre>
BBBBBBBBBB
BBB
</pre>
<li> The leader string consists of one or more glyphs, and is thus an inline box. A leader is a row of these boxes, drawn from the end edge to the start edge, where only those boxes not overlaid by the before or after content. On this line, draw the leader string, starting from the end edge, repeating as many times as possible until reaching the start edge. <pre>
BBBBBBBBBB
..........
</pre>
<li> Draw the before and after content on top of the leader. If any part of the before or after content overlaps a glyph in a leader string box, that glyph is not displayed.<pre>
BBBBBBBBBB
BBB....AAA
</pre>
<li> If one full copy of the leader string is not visible: <pre>
BBBBBBB
BBBBBBA
</pre> Insert a line break before the after content, draw the leader on the next line, and draw the end content on top <pre>
BBBBBBB
BBBBBB
......A
</pre>
</ol>

<figure>
<img src="images/leader.001.jpg" width="480" alt="drawing leaders"/>
<figcaption>Procedure for drawing leaders</figcaption>
</figure>



<figure>
<img src="images/leader.002.jpg" width="480" alt="drawing leaders"/>
<figcaption>Procedure for drawing leaders when the content doesn’t fit on a single line</figcaption>
</figure>




<h3 id="counters">
Automatic counters and numbering: the 'counter-increment' and 'counter-reset' properties (moved)</h3>

<p class="issue">Now described in [[CSS3LIST]]

<p class="issue">Should this move back to CSS Content?


<h2 id="quotes">
Quotes</h2>



	Quotation marks are inserted in appropriate places in a document with the ''open-quote'' and ''close-quote'' values of the 'content' property. Each occurrence of ''open-quote'' or ''close-quote'' is replaced by one of the strings from the value of 'quotes', based on the depth of nesting.

	''open-quote'' refers to the first of a pair of quotes, ''close-quote'' refers to the second. Which pair of quotes is used depends on the nesting level of quotes: the number of occurrences of ''open-quote'' in all generated text before the current occurrence, minus the number of occurrences of ''close-quote''. If the depth is 0, the first pair is used, if the depth is 1, the second pair is used, etc. If the depth is greater than the number of pairs, the last pair is repeated.

	Note that this quoting depth is independent of the nesting of the source document or the formatting structure.

	Some typographic styles require open quotation marks to be repeated before every paragraph of a quote spanning several paragraphs, but only the last paragraph ends with a closing quotation mark. In CSS, this can be achieved by inserting "phantom" closing quotes. The keyword ''no-close-quote'' decrements the quoting level, but does not insert a quotation mark.


	<div class="example">
	The following style sheet puts opening quotation marks on every paragraph in a <code>blockquote</code>, and inserts a single closing quote at the end:

	<pre>
		blockquote p:before { content: open-quote }
		blockquote p:after { content: no-close-quote }
		blockquote p:last-child::after { content: close-quote }
	</pre>

	</div>

	For symmetry, there is also a ''no-open-quote'' keyword, which inserts nothing, but increments the quotation depth by one.

	<div class="note">If a quotation is in a different language than the surrounding text, it is customary to quote the text with the quote marks of the language of the surrounding text, not the language of the quotation itself.
	</div>

	<div class="example">
	For example, French inside English:

	<blockquote>
	The device of the order of the garter is “Honi soit qui mal y pense.”
	</blockquote>

	English inside French:

	<blockquote>
	Il disait: «&#8197;Il faut mettre l’action en ‹&#8197;fast
	forward&#8197;›.&#8197;»
	</blockquote>

	A style sheet like the following will set the 'quotes' property so that ''open-quote'' and ''close-quote'' will work correctly on all elements. These rules are for documents that contain only English, French, or both. One rule is needed for every additional language. Note the use of the child combinator (">") to set quotes on elements based on the language of the surrounding text:

	<pre>
	:lang(fr) > * { quotes: "\00AB\2005" "\2005\00BB" "\2039\2005" "\2005\203A" }
	:lang(en) > * { quotes: "\201C" "\201D" "\2018" "\2019" }
	</pre>



	The quotation marks are shown here in a form that most people will be able to type. If you can type them directly, they will look like this:

	<pre>
	:lang(fr) > * { quotes: "« " " »" "‹ " " ›" }
	:lang(en) > * { quotes: "&#8220;" "&#8221;" "&#8216;" "&#8217;" }

	</pre>
	</div>

<h4 id="specifying-quotes">
Specifying quotes with the 'quotes' property</h4>

HTML has long had the <code>q</code> element, used to delimit quotations. The ''quotes'' property, in conjunction with the various quote values of the content property, can be used to properly style such quotations.


<pre class='propdef'>
    Name: quotes
    Value: [ <<string>> <<string>> ]+ | none
    Initial: depends on user agent
    Applies To: all elements
    Inherited: yes
    Percentages: n/a
    Computed Value: specified value
    Media: all
</pre>

<p class="issue">The previous ED had an initial value of ''text'', which was an error. [[CSS21]] has initial value of "depends on user agent". Do we use <code>auto</code> for things like this, or is it just a UA stylesheet issue?


This property specifies quotation marks for any number of embedded quotations. Values have the following meanings:

<dl dfn-type=value dfn-for=quotes>
	<dt><dfn>none</dfn>
	<dd>The ''open-quote'' and ''close-quote'' values of the 'content' property produce no quotations marks, as if they were ''no-open-quote'' and ''no-close-quote'' respectively.

	<!--
	<dt><dfn>auto</dfn>
	<dd>TK
	 -->

	<dt>[ <<string>> <<string>> ]+
	<dd>Values for the ''open-quote'' and ''close-quote'' values of the 'content' property are taken from this list of pairs of quotation marks (opening and closing). The first (leftmost) pair represents the outermost level of quotation, the second pair the first level of embedding, etc. The user agent must apply the appropriate pair of quotation marks according to the level of embedding.
</dl>


<div class="example">

For example, applying the following style sheet:

<pre>
/* Specify pairs of quotes for two levels in two languages */
:lang(en) > q { quotes: '"' '"' "'" "'" }
:lang(no) > q { quotes: "«" "»" "’" "’" }

/* Insert quotes before and after Q element content */
q::before { content: open-quote }
q::after  { content: close-quote }
</pre>

to the following HTML fragment:

<pre class="html-example">
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;Quotes&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;q&gt;Quote me!&lt;/q&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

would allow a user agent to produce:

<pre>
"Quote me!"
</pre>

while this HTML fragment:

<pre class="html-example">
&lt;html lang="no"&gt;
  &lt;head&gt;
    &lt;title&gt;Quotes&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;q&gt;Tr&oslash;ndere gr&aring;ter n&aring;r &lt;q&gt;Vinsjan p&aring; kaia&lt;/q&gt; blir deklamert.&lt;/q&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

would produce:

<pre>
«Tr&oslash;ndere gr&aring;ter n&aring;r ’Vinsjan p&aring; kaia’ blir deklamert.»
</pre>
</div>








<h2 id="alt-property">
Alternative text for Generated Content: The 'alt' property</h2>

  The generated content of a ::before or ::after element is not always appropriate for assistive technology. In these cases, alternative text can be provided using the 'alt' property. The 'alt' property applies only to the same elements the 'content' property applies to.

  <pre class=propdef>
  Name: alt
  Value: none | <<string>>
  Initial: none
  Applies to: ::before and ::after pseudo-elements
  Inherited: no
  Computed Value: as specified
  </pre>

  <dl dfn-type="value" dfn-for="alt">
    <dt><dfn>none</dfn>
    <dd>No alternative text

    <dt><dfn><<string>></dfn>
    <dd>The alternative text is the <<string>>. This can be the empty string.
  </dl>

  When the alt property computes to anything other than none, the alternative <<string>> should be used instead of the value of the contents property by assistive technology.

  <div class="example">
	  Here the content property is an image, so the alt property is required to provide alternative text.

	  <pre>
	  .new::before {
	    content: url(./img/star.png);
	    alt: "New!"; /* or a localized attribute from the DOM: attr("data-alt") */
	  }
	  </pre>
  </div>

  <div class="example">
	  If the pseudo-element is purely decorative and its function is covered elsewhere, setting alt to the empty string can avoid reading out the decorative element. Here the ARIA attribute will be spoken as "collapsed". Without the empty string alt value, the content would also be spoken as "Black right-pointing pointer".

	  <pre>
	  .expandable::before {
	    content: "\25BA"; /* a.k.a. ► */
	    alt: "";
	    /* aria-expanded="false" already in DOM,
	       so this pseudo-element is decorative */
	  }
	  </pre>
  </div>

  <!--end copy from CSS-PSEUDO-->


<h2 id="replacedContent">Replaced content</h2>

If the computed value of the part of the 'content' property that ends up being used is a single URI, then the element or pseudo-element is a replaced element. The box model defines different rules for the layout of replaced elements than normal elements. Replaced elements do not have '::before' and '::after' pseudo-elements; the 'content' property in the case of replaced content replaces the entire contents of the element's box.








<h2 id="css-bookmarks">
Bookmarks
</h2>
Some document formats, most notably PDF, allow the use of <dfn>bookmarks</dfn> as an aid to navigation. Bookmarks provide a hierarchy of links to document elements, as well as text to label the links. A bookmark has three properties: 'bookmark-level', 'bookmark-label', and 'bookmark-state'.

A bookmark references a point in the document, which we define to the be  the intersection of the before edge and the start edge of the first box or box fragment generated by the element. When a user activates a bookmark, the user agent must bring that reference point to the user's attention, by moving to that page, scrolling (as defined in CSSOM View), or some other mechanism.

<h3 id="bookmark-level">
bookmark-level
</h3>

The 'bookmark-level' property determines if a bookmark is created, and at what level. If this property is absent, or has value ''bookmark-level/none'', no bookmark should be generated, regardless of the values of 'bookmark-label' or 'bookmark-state'.

<pre class="propdef">
Name: bookmark-level
Value: none | &lt;integer>
Initial: none
Applies to: all elements
Inherited: no
Percentages: N/A
Media: visual
Computed value: specified value
</pre>
<dl dfn-type="value" dfn-for="bookmark-level">
<dt>&lt;integer>
<dd>defines the level of the bookmark, with the highest level being 1 (negative and zero values are invalid).
<dt>none
<dd>no bookmark is generated.
</dl>

<div class="example">
<pre>
section h1 { bookmark-level: 1; }
section section h1 { bookmark-level: 2; }
section section section h1 { bookmark-level: 3; }
</pre>

</div>


<h3 id="bookmark-label">
bookmark-label
</h3>
<pre class="propdef">
Name: bookmark-label
Value: &lt;content-list>
Initial: content(text)
Applies to: all elements
Inherited: no
Percentages: N/A
Media: visual
Computed value: specified value
</pre>
<dl dfn-type="value" dfn-for="bookmark-label">
<dt>&lt;content-list>
<dd><<content-list>> is defined above, in the section on the 'string-set' property. The value of <<content-list>> becomes the text content of the bookmark label.
<!--
<dt>none
<dd>no bookmark is generated.
 -->
</dl>

<div class="example">
HTML:

<pre>
&lt;h1>Loomings&lt;/h1>
</pre>
CSS:

<pre>
h1 {
bookmark-label: content(text);
bookmark-level: 1;
}
</pre>
The bookmark label will be “Loomings”.
</div>

<h3 id="bookmark-state">
bookmark-state
</h3>
Bookmarks typically toggle open and closed, with the open state displaying the next level of bookmarks.

<pre class="propdef">
Name: bookmark-state
Value: open | closed
Initial: open
Applies to: block-level elements
Inherited: no
Percentages: N/A
Media: visual
Computed value: specified value
</pre>
<dl dfn-type="value" dfn-for="bookmark-state">
<dt>open
<dd>The bookmarks of the nearest descendants of an element with a bookmark-state of open will be displayed.
<dt>closed
<dd>any bookmarks of descendant elements are not initially displayed.
</dl>



<!-- hehe. I expect at least one person to complain about this and suggest that ::before and ::after on replaced content becomes sibling content. Well, they will need to explain:

  * how this works with floats and abs pos content (is it moving both, does it leave the gen con in-flow...)

  * how this works with rel pos content (what moves?)

  * what ::outside::before matches in this case

-->

<h2 id="changes">Changes since the 14 May 2003 Working Draft</h2>

* Terminology section deleted, as that information is now in [[CSS-PSEUDO-4]]

* Pseudo-elements section replaced by [[CSS-PSEUDO-4]]

* Automatic counters and numbering section replaced by [[CSS3LIST]]

* Section on Named strings replaced by content moved from [[CSS3GCPM]]

* Removed ''icon'' value of content property.

* Removed ''&lt;glyph>'' values of content property.

* Bookmarks, Cross References, and Leaders section moved from [[CSS3GCPM]] to this specification

* Removed mechanisms for moving document content around, including the <code>::alternate</code> pseudo-element and the <code>pending</code> value of the 'content' property.

* Examples of Norwegian and French quotation marks no longer use plus signs and semicolons as delimiters.

* Dave Cramer added as co-editor. Ian Hickson and Håkon Wium Lie are now former editors.

<h2 class="no-num" id="acknowledgments">Acknowledgments</h2>

Stuart Ballard, David Baron, Bert Bos, and <span lang="tr">Tantek Çelik</span> provided invaluable suggestions used in this
specification.


