<pre class='metadata'>
Title: CSS Transforms Module Level 1
Status: ED
Work Status: Refining
ED: https://drafts.csswg.org/css-transforms/
TR: https://www.w3.org/TR/css-transforms-1/
Previous Version: https://www.w3.org/TR/2019/CR-css-transforms-1-20190214/
Previous Version: https://www.w3.org/TR/2018/WD-css-transforms-1-20181130/
Previous Version: https://www.w3.org/TR/2017/WD-css-transforms-1-20171130/
Previous Version: https://www.w3.org/TR/2013/WD-css-transforms-1-20131126/
Previous Version: https://www.w3.org/TR/2012/WD-css3-transforms-20120911/
Previous Version: https://www.w3.org/TR/2012/WD-css3-transforms-20120403/
Shortname: css-transforms
Level: 1
Group: csswg
Editor: Simon Fraser, Apple Inc http://www.apple.com/, simon.fraser@apple.com, w3cid 44066
Editor: Dean Jackson, Apple Inc http://www.apple.com/, dino@apple.com, w3cid 42080
Editor: Theresa O'Connor, Apple Inc http://www.apple.com/, eoconnor@apple.com, w3cid 40614
Editor: Dirk Schulze, Adobe Inc http://www.adobe.com/, dschulze@adobe.com, w3cid 51803
Former Editor: David Hyatt, Apple Inc http://www.apple.com/, hyatt@apple.com
Former Editor: Chris Marrin, Apple Inc http://www.apple.com/, cmarrin@apple.com
Former Editor: Aryeh Gregor, Mozilla http://www.mozilla.org/, ayg@aryeh.name
Abstract: CSS transforms allows elements styled with CSS to be transformed in two-dimensional space. This specification is the convergence of the <a href="https://www.w3.org/TR/2009/WD-css3-2d-transforms-20090320/">CSS 2D Transforms</a> and <a href="https://www.w3.org/TR/2009/WD-SVG-Transforms-20090320/">SVG transforms</a> specifications.
Ignored terms: calcMode, viewBox, baseVal, animVal
</pre>

<pre class=anchors>
text: transform; type: element-attr; for: ; spec: svg1.1; url: https://www.w3.org/TR/SVG11/coords.html#TransformAttribute
text: patternTransform; type: element-attr; for: pattern; spec: svg1.1; url: https://www.w3.org/TR/SVG11/pservers.html#PatternElementPatternTransformAttribute
text: patternUnits; type: element-attr; for: pattern; spec: svg1.1; url: https://www.w3.org/TR/SVG/pservers.html#PatternElementPatternUnitsAttribute
text: gradientTransform; type: element-attr; for: linearGradient; spec: svg1.1; url: https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementGradientTransformAttribute
text: gradientUnits; type: element-attr; for: linearGradient; spec: svg1.1; url: https://www.w3.org/TR/SVG/pservers.html#LinearGradientElementGradientUnitsAttribute
</pre>

<pre class='link-defaults'>
spec: svg; type: property
    text: stroke
    text: fill

spec: css-masking-1; type: property
    text: clip
    text: clip-path

spec: filters-1; type: property
    text: filter

spec: css-text-3; type: property
    text: text-align
    text: letter-spacing
    text: word-spacing

spec:css-display-3; type:property
    text: display

spec:css-display-3; type:value; for:display
    text: table-row
    text: table-row-group
    text: table-header-group
    text: table-footer-group
    text: table-cell
    text: table-caption

spec:css-backgrounds-3; type:property
    text: background-attachment

spec:css-backgrounds-3; type:value
    text: fixed

spec:html; type:element
    text: a
</pre>

<style type="text/css">
.example {
  clear:both
}

th {
  text-align:left
}

.pseudo-code {
  font-family:monospace
}
.pseudo-code > ol {
  list-style-type:decimal
}
.pseudo-code > ol > li > ol {
  list-style-type:lower-latin
}
.pseudo-code > ol > li > ol > li > ol {
  list-style-type:lower-roman
}
.pseudo-code ul {
  list-style-type:disc
}

dd > p:nth-child(1) {
  margin-top:0
}
</style>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

The CSS <a href="https://www.w3.org/TR/CSS2/visuren.html">visual formatting model</a> describes a coordinate system within each element is positioned. Positions and sizes in this coordinate space can be thought of as being expressed in pixels, starting in the origin of point with positive values proceeding to the right and down.

This coordinate space can be modified with the 'transform' property. Using transform, elements can be translated, rotated and scaled.

Module Interactions {#module-interactions}
------------------------------------------

This module defines a set of CSS properties that affect the visual rendering of elements to which those properties are applied; these effects are applied after elements have been sized and positioned according to the <a href="https://www.w3.org/TR/CSS2/visuren.html">visual formatting model</a> from [[!CSS2]]. Some values of these properties result in the creation of a <a href="https://www.w3.org/TR/CSS2/visuren.html#containing-block">containing block</a>, and/or the creation of a <a>stacking context</a>.

Transforms affect the rendering of backgrounds on elements with a value of ''fixed'' for the 'background-attachment' property, which is specified in [[!CSS3BG]].

Transforms affect the client rectangles returned by the Element Interface Extensions <a href="https://www.w3.org/TR/cssom-view/#dom-element-getclientrects">getClientRects()</a> and <a href="https://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect">getBoundingClientRect()</a>, which are specified in [[CSSOM-VIEW]].

Transforms affect the computation of the <a href="https://www.w3.org/TR/css-overflow-3/#scrollable-overflow-region">scrollable overflow region</a> as described by [[CSS-OVERFLOW-3]].

CSS Values {#css-values}
------------------------

This specification follows the <a href="https://www.w3.org/TR/CSS2/about.html#property-defs">CSS property definition conventions</a> from [[!CSS2]]
using the <a href="https://www.w3.org/TR/css-values-3/#value-defs">value definition syntax</a> from [[!CSS-VALUES-3]].
Value types not defined in this specification are defined in CSS Values &amp; Units [[!CSS-VALUES-3]].
Combination with other CSS modules may expand the definitions of these value types.

In addition to the property-specific values listed in their definitions,
all properties defined in this specification
also accept the <a>CSS-wide keywords</a> as their property value.
For readability they have not been repeated explicitly.
Terminology {#terminology}
==========================

When used in this specification, terms have the meanings assigned in this section.

<div data-export>
    : <dfn>transformable element</dfn>
    :: A transformable element is an element in one of these categories:
        * all elements whose layout is governed by the CSS box model except for non-replaced inline boxes, table-column boxes, and table-column-group boxes [[!CSS2]],

        * all SVG <a>paint server elements</a>, the <a element>clipPath</a> element and SVG <a>renderable elements</a> with the exception of any descendant element of <a>text content elements</a> [[!SVG2]].

    : <dfn>transformed element</dfn>
    :: An element with a computed value other than ''transform/none'' for the 'transform' property.

    : <dfn export>user coordinate system</dfn>
    : <dfn export>local coordinate system</dfn>
    :: In general, a coordinate system defines locations and distances on the current canvas. The current local coordinate system (also user coordinate system) is the coordinate system that is currently active and which is used to define how coordinates and lengths are located and computed, respectively, on the current canvas.
        The current user coordinate system has its origin at the top-left of a [=reference box=] specified by the 'transform-box' property. Percentage values are relative to the dimension of this reference box. One unit equals one CSS pixel.

    : <dfn>transformation matrix</dfn>
    :: A matrix that defines the mathematical mapping from one coordinate system into another. It is computed from the values of the 'transform' and 'transform-origin' properties as described <a href="#transformation-matrix-computation">below</a>.

    : <dfn>current transformation matrix</dfn> (CTM)
    :: A matrix that defines the mapping from the [=local coordinate system=] into the [=viewport coordinate system=].

    : <dfn>2D matrix</dfn>
    ::  A 3x2 transformation matrix, or a 4x4 matrix where the items m<sub>31</sub>, m<sub>32</sub>, m<sub>13</sub>, m<sub>23</sub>, m<sub>43</sub>, m<sub>14</sub>, m<sub>24</sub>, m<sub>34</sub> are equal to ''0'' and m<sub>33</sub>, m<sub>44</sub> are equal to ''1''.

    : <dfn>identity transform function</dfn>
    :: A <a href="#transform-functions">transform function</a> that is equivalent to a identity 4x4 matrix (see <a href="#mathematical-description">Mathematical Description of Transform Functions</a>). Examples for identity transform functions are ''translate(0)'', ''translateX(0)'', ''translateY(0)'', ''scale(1)'', ''scaleX(1)'', ''scaleY(1)'', ''rotate(0)'', ''skew(0, 0)'', ''skewX(0)'', ''skewY(0)'' and ''matrix(1, 0, 0, 1, 0, 0)''.

    : <dfn>post-multiply</dfn>
    : <dfn>post-multiplied</dfn>
    :: Term <var>A</var> post-multiplied by term <var>B</var> is equal to <var>A</var> &middot; <var>B</var>.

    : <dfn>pre-multiply</dfn>
    : <dfn>pre-multiplied</dfn>
    :: Term <var>A</var> pre-multiplied by term <var>B</var> is equal to <var>B</var> &middot; <var>A</var>.

    : <dfn>multiply</dfn>
    :: Multiply term <var>A</var> by term <var>B</var> is equal to <var>A</var> &middot; <var>B</var>.
</div>

The Transform Rendering Model {#transform-rendering}
====================================================

<em>This section is normative.</em>

Specifying a value other than ''transform/none'' for the 'transform' property establishes a new [=local coordinate system=] at the element that it is applied to. The mapping from where the element would have rendered into that local coordinate system is given by the element's [=transformation matrix=].

<p id="transformation-matrix-computation">
The [=transformation matrix=] is computed from the 'transform' and 'transform-origin' properties as follows:

1. Start with the identity matrix.
2. Translate by the computed X and Y of 'transform-origin'
3. Multiply by each of the transform functions in 'transform' property from left to right
4. Translate by the negated computed X and Y values of 'transform-origin'

<div class=example>

  An element has a 'transform' property that is not ''transform/none''.

<pre><code highlight=css>
div {
  transform-origin: 0 0;
  transform: translate(-10px, -20px) scale(2) rotate(45deg);
}
</code></pre>

  The 'transform-origin' property is set to ''0 0'' and can be omitted. The [=transformation matrix=] <i>TM</i> gets computed by post-multying the <<translate()>>, <<scale()>> and <<rotate()>> <<transform-function>>s.

  <img src="images/tm.png" alt="TM = \begin{bmatrix} 1 & 0 & 0 & -10 \\ 0 & 1 & 0 & -20 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{bmatrix} 2 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{bmatrix} cos(45) & -sin(45) & 0 & 0 \\ sin(45) & cos(45) & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="627">
</div>

Transforms apply to [=transformable elements=].

The coordinate space is a coordinate system with two axes: the X axis increases horizontally to the right; the Y axis increases vertically downwards.

Transformations are cumulative. That is, elements establish their local coordinate system within the coordinate system of their parent.

To map a point <i>p<sub>local</sub></i> with the coordinate pair <i>x<sub>local</sub></i> and <i>y<sub>local</sub></i> from the [=local coordinate system=] of an element into the parent's coordinate system, post-multiply the [=transformation matrix=] <i>TM</i> of the element by <i>p<sub>local</sub></i>. The result is the mapped point <i>p<sub>parent</sub></i> with the coordinate pair <i>x<sub>parent</sub></i> and <i>y<sub>parent</sub></i> in the parent's [=local coordinate system=].

<img src="images/tm-map.png" alt="\begin{bmatrix} x_{parent} \\ y_{parent} \\ 0 \\ 1 \end{bmatrix} = TM \cdot \begin{bmatrix} x_{local} \\ y_{local} \\ 0 \\ 1 \end{bmatrix}" width="276">

From the perspective of the user, an element effectively accumulates all the 'transform' properties of its ancestors as well as any local transform applied to it. The accumulation of these transforms defines a [=current transformation matrix=] (CTM) for the element.

<p id="current-transformation-matrix-computation">
The [=current transformation matrix=] is computed by post-multiplying all transformation matrices starting from the [=viewport coordinate system=] and ending with the [=transformation matrix=] of an element.

<div class=example>
This example has multiple, nested elements in an SVG document. Some elements get transformed by a [=transformation matrix=].

<pre><code highlight=html>
&lt;svg xmlns="http://www.w3.org/2000/svg">
  &lt;g transform="translate(-10, 20)">
    &lt;g transform="scale(2)">
      &lt;rect width="200" height="200" transform="rotate(45)"/>
    &lt;/g>
  &lt;/g>
&lt;/svg>
</code></pre>

* ''translate(-10, 20)'' computes to the transformation matrix <i>T1</i>
* ''scale(2)'' computes to the transformation matrix <i>T2</i>
* ''rotate(45)'' computes to the transformation matrix <i>T3</i>

The CTM for the SVG <a element>rect</a> element is the result of multiplying <i>T1</i>, <i>T2</i> and <i>T3</i> in order.

<img src="images/ctm.png" alt="CTM = \begin{bmatrix} 1 & 0 & 0 & -10 \\ 0 & 1 & 0 & -20 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{bmatrix} 2 & 0 & 0 & 0 \\ 0 & 2 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \cdot \begin{bmatrix} cos(45) & -sin(45) & 0 & 0 \\ sin(45) & cos(45) & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="627">

To map a point <i>p<sub>local</sub></i> with the coordinate pair <i>x<sub>local</sub></i> and <i>y<sub>local</sub></i> from the [=local coordinate system=] of the SVG <a element>rect</a> element into the [=viewport coordinate system=], post-multiply the [=current transformation matrix=] <i>CTM</i> of the element by <i>p<sub>local</sub></i>. The result is the mapped point <i>p<sub>viewport</sub></i> with the coordinate pair <i>x<sub>viewport</sub></i> and <i>y<sub>viewport</sub></i> in the [=viewport coordinate system=].

<img src="images/ctm-map.png" alt="\begin{bmatrix} x_{viewport} \\ y_{viewport} \\ 0 \\ 1 \end{bmatrix} = CTM \cdot \begin{bmatrix} x_{local} \\ y_{local} \\ 0 \\ 1 \end{bmatrix}" width="276">
</div>

Note: Transformations do affect the visual rendering, but have no effect on the CSS layout other than affecting overflow. Transforms are also taken into account when computing client rectangles exposed via the Element Interface Extensions, namely <a href="https://www.w3.org/TR/cssom-view/#dom-element-getclientrects">getClientRects()</a> and <a href="https://www.w3.org/TR/cssom-view/#dom-element-getboundingclientrect">getBoundingClientRect()</a>, which are specified in [[CSSOM-VIEW]].

<div class="example">
  <pre><code highlight=css>
  div {
      transform: translate(100px, 100px);
  }
  </code></pre>

    This transform moves the element by 100 pixels in both the X and Y directions.

  <div class="figure">
    <img src="examples/translate1.svg" alt="The 100px translation in X and Y"
    width="470" height="250">
  </div>
</div>

<div class="example">
  <pre><code highlight=css>
  div {
    height: 100px; width: 100px;
    transform-origin: 50px 50px;
    transform: rotate(45deg);
  }
  </code></pre>

The 'transform-origin' property moves the point of origin by 50 pixels in both the X and Y directions. The transform rotates the element clockwise by 45&deg; about the point of origin. After all transform functions were applied, the translation of the origin gets translated back by -50 pixels in both the X and Y directions.

  <div class="figure">
    <img alt="The point of origin gets translated temporary" src="examples/origin1.svg" width="735" height="250">
  </div>
</div>

<div class="example">
  <pre><code highlight=css>
  div {
    height: 100px; width: 100px;
    transform: translate(80px, 80px) scale(1.5, 1.5) rotate(45deg);
  }
  </code></pre>

The visual appearance is as if the <a element>div</a> element gets translated by 80px to the bottom left direction, then scaled up by 150% and finally rotated by 45&deg;.

Each <<transform-function>> can get represented by a corresponding 4x4 matrix. To map a point from the coordinate space of the <a element>div</a> box to the coordinate space of the parent element, these transforms get multiplied in the reverse order:
1. The rotation matrix gets <a>post-multiplied</a> by the scale matrix.
2. The result of the previous multiplication is then <a>post-multiplied</a> by the translation matrix to create the accumulated transformation matrix.
3. Finally, the point to map gets <a>pre-multiplied</a> with the accumulated transformation matrix.

For more details see <a href="#transform-function-lists">The Transform Function Lists</a>.

<div class="figure">
  <img src="examples/compound_transform.svg" alt="The transform specified above" width="270" height="270">
</div>

Note: The identical rendering can be obtained by nesting elements with the equivalent transforms:

  <pre><code highlight=html>
  &lt;div style="transform: translate(80px, 80px)">
      &lt;div style="transform: scale(1.5, 1.5)">
          &lt;div style="transform: rotate(45deg)">&lt;/div>
      &lt;/div>
  &lt;/div>
  </code></pre>
</div>

For elements whose layout is governed by the CSS box model, the transform property does not affect the flow of the content surrounding the transformed element. However, the extent of the overflow area takes into account transformed elements. This behavior is similar to what happens when elements are offset via relative positioning. Therefore, if the value of the 'overflow' property is ''overflow/scroll'' or ''overflow/auto'', scrollbars will appear as needed to see content that is transformed outside the visible area. Specifically, transforms can extend (but do not shrink) the size of the overflow area, which is computed as the union of the bounds of the elements before and after the application of transforms.

For elements whose layout is governed by the CSS box model, any value other than ''transform/none'' for the 'transform' property results in the creation of a stacking context. Implementations must paint the layer it creates, within its parent stacking context, at the same stacking order that would be used if it were a positioned element with ''z-index: 0''. If an element with a transform is positioned, the 'z-index' property applies as described in [[!CSS2]], except that ''z-index/auto'' is treated as ''0'' since a new stacking context is always created.

For elements whose layout is governed by the CSS box model, any value other than ''transform/none'' for the 'transform' property also causes the element to establish a <dfn export>containing block for all descendants</dfn>. Its padding box will be used to layout for all of its absolute-position descendants, fixed-position descendants, and descendant fixed background attachments.

<div class="example">
To demonstrate the effect of [=containing block for all descendants=] on fixed-position descendants, the following code snippets should behave identically:
<pre><code highlight=html>
&lt;style>
#container {
  width: 300px;
  height: 200px;
  border: 5px dashed black;
  padding: 5px;
  overflow: scroll;
}

#bloat {
  height: 1000px;
}

#child {
  right: 0;
  bottom: 0;
  width: 10%;
  height: 10%;
  background: green;
}
&lt;/style>

&lt;div id="container" style="transform:translateX(5px);">
  &lt;div id="bloat">&lt;/div>
  &lt;div id="child" style="position:fixed;">&lt;/div>
&lt;/div>
</code></pre>
versus
<pre><code highlight=html>
&lt;div id="container" style="position:relative; z-index:0; left:5px;">
  &lt;div id="bloat">&lt;/div>
  &lt;div id="child" style="position:absolute;">&lt;/div>
&lt;/div>
</code></pre>
</div>

<a href="https://www.w3.org/TR/css-backgrounds-3/#valdef-background-attachment-fixed">Fixed backgrounds</a> on the root element are affected by any transform specified for that element. For all other elements that are effected by a transform (i.e. have a transform applied to them, or to any of their ancestor elements), a value of ''fixed'' for the 'background-attachment' property is treated as if it had a value of ''background-attachment/scroll''. The computed value of 'background-attachment' is not affected.

Note: If the root element is transformed, the transformation applies to the entire canvas, including any background specified for the root element.  Since <a href="https://www.w3.org/TR/css-backgrounds-3/#special-backgrounds">the background painting area for the root element</a> is the entire canvas, which is infinite, the transformation might cause parts of the background that were originally off-screen to appear. For example, if the root element's background were repeating dots, and a transformation of ''scale(0.5)'' were specified on the root element, the dots would shrink to half their size, but there will be four times as many, so they still cover the whole viewport.


The 'transform' Property {#transform-property}
==============================================

A transformation is applied to the coordinate system an element renders into through the 'transform' property. This property contains a list of <a href="#transform-functions">transform functions</a>. The final transformation value for a coordinate system is obtained by converting each function in the list to its corresponding matrix like defined in <a href="#mathematical-description">Mathematical Description of Transform Functions</a>, then multiplying the matrices.

<pre class='propdef'>
Name: transform
Value: none | <<transform-list>>
Initial: none
Applies to: [=transformable elements=]
Inherited: no
Percentages: refer to the size of [=reference box=]
Computed value: as specified, but with lengths made absolute
Animation type: transform list, see <a href="#interpolation-of-transforms">interpolation rules</a>
</pre>

Any computed value other than ''transform/none'' for the transform affects containing block and stacking context, as described in [[#transform-rendering]].

<pre class=prod><dfn>&lt;transform-list></dfn> = <<transform-function>>+</pre>


Serialization of <<transform-function>>s {#serialization-of-transform-functions}
----------------------------------------

To serialize the <<transform-function>>s, serialize as per their individual grammars, in the order the grammars are written in, avoiding <<calc()>> expressions where possible, avoiding <<calc()>> transformations, omitting components when possible without changing the meaning, joining space-separated tokens with a single space, and following each serialized comma with a single space.

Serialization of the computed value of <<transform-list>> {#serialization-of-the-computed-value}
----------------------------------------------------------------

A <<transform-list>> for the computed value is serialized to one <<matrix()>> function by the following algorithm:

<ol class="algorithm">
	1. Let <var>transform</var> be a 4x4 matrix initialized to the identity matrix. The elements <var ignore> m11</var>, <var ignore>m22</var>, <var ignore>m33</var> and <var ignore>m44</var> of <var>transform</var> must be set to ''1'' all other elements of <var>transform</var> must be set to ''0''.
	2. Post-multiply all <<transform-function>>s in <<transform-list>> to <var>transform</var>.
	3. Serialize <var>transform</var> to a <<matrix()>> function.
</ol>

The 'transform-origin' Property {#transform-origin-property}
============================================================

<pre class='propdef'>
Name: transform-origin
Value: &nbsp;&nbsp;[ left | center | right | top | bottom | <<length-percentage>> ]<br> | <br>&nbsp;&nbsp;[ left | center | right | <<length-percentage>> ]<br>&nbsp;&nbsp;[ top | center | bottom | <<length-percentage>> ] <<length>>?<br> |<br>&nbsp;&nbsp;[[ center | left | right ] && [ center | top | bottom ]] <<length>>?
Initial: 50% 50%
Applies to: [=transformable elements=]
Inherited: no
Percentages: refer to the size of [=reference box=]
Computed value: see 'background-position'
Animation type: by computed value
</pre>

The values of the 'transform' and 'transform-origin' properties are used to compute the [=transformation matrix=], as described above.

If only one value is specified, the second value is assumed to be <a value for=transform-origin>center</a>. If one or two values are specified, the third value is assumed to be ''0px''.

If two or more values are defined and either no value is a keyword, or the only used keyword is <a value for=transform-origin>center</a>, then the first value represents the horizontal position (or offset) and the second represents the vertical position (or offset). A third value always represents the Z position (or offset) and must be of type <<length>>.

<dl dfn-for="transform-origin" dfn-type="value">
	: <<length-percentage>>
	:: A percentage for the horizontal offset is relative to the width of the [=reference box=]. A percentage for the vertical offset is relative to the height of the [=reference box=]. The value for the horizontal and vertical offset represent an offset from the top left corner of the [=reference box=].
	: <<length>>
	:: A length value gives a fixed length as the offset. The value for the horizontal and vertical offset represent an offset from the top left corner of the [=reference box=].
	: <dfn>top</dfn>
	:: Computes to ''0%'' for the vertical position.
	: <dfn>right</dfn>
	:: Computes to ''100%'' for the horizontal position.
	: <dfn>bottom</dfn>
	:: Computes to ''100%'' for the vertical position.
	: <dfn>left</dfn>
	:: Computes to ''0%'' for the horizontal position.
	: <dfn>center</dfn>
	::  Computes to ''50%'' (''left 50%'') for the horizontal position if the horizontal position is not otherwise specified, or ''50%'' (''top 50%'') for the vertical position if it is.
</dl>

For SVG elements without associated CSS layout box the initial [=used value=] is ''0 0'' as if the user agent style sheet contained:
<pre><code highlight=css>
*:not(svg), *:not(foreignObject) &gt; svg {
    transform-origin: 0 0;
}
</code></pre>

The 'transform-origin' property is a <a>resolved value special case property</a> like 'height'. [[!CSSOM]]


Transform reference box: the 'transform-box' property {#transform-box}
======================================================================

<pre class='propdef'>
Name: transform-box
Value: content-box | border-box | fill-box | stroke-box | view-box
Initial: view-box
Applies to: [=transformable elements=]
Inherited: no
Percentages: N/A
Computed value: specified keyword
Animation type: discrete
</pre>

All transformations defined by the 'transform' and 'transform-origin' property are relative to the position and dimensions of the <dfn>reference box</dfn> of the element. The [=reference box=] is specified by one of the following:

<dl dfn-for=transform-box>
	: <dfn dfn-type=value>content-box</dfn>
	:: Uses the content box as reference box. The reference box of a table is the border box of its <a href="https://www.w3.org/TR/CSS21/tables.html#model">table wrapper box</a>, not its table box.

	: <dfn dfn-type=value>border-box</dfn>
	:: Uses the border box as reference box. The reference box of a table is the border box of its <a href="https://www.w3.org/TR/CSS21/tables.html#model">table wrapper box</a>, not its table box.

	: <dfn dfn-type=value>fill-box</dfn>
	:: Uses the <a>object bounding box</a> as reference box.

	: <dfn dfn-type=value>stroke-box</dfn>
	:: Uses the <a>stroke bounding box</a> as reference box.

	: <dfn dfn-type=value>view-box</dfn>
	::  Uses the nearest <a href="https://www.w3.org/TR/SVG11/intro.html#TermSVGViewport">SVG viewport</a> as reference box.

		If a {{viewBox}} attribute is specified for the <a href="https://www.w3.org/TR/SVG11/intro.html#TermSVGViewport">SVG viewport</a> creating element:
		* The reference box is positioned at the origin of the coordinate system established by the {{viewBox}} attribute.
		* The dimension of the reference box is set to the <em>width</em> and <em>height</em> values of the {{viewBox}} attribute.
</dl>

For the SVG <{pattern}> element, the reference box gets defined by the <{pattern/patternUnits}> attribute [[!SVG2]].

For the SVG <a element>linearGradient</a> and <a element>radialGradient</a> elements, the reference box gets defined by the <{linearGradient/gradientUnits}> attribute [[!SVG2]].

For the SVG <a element>clipPath</a> element, the reference box gets defined by the <{clipPath/clipPathUnits}> attribute [[!CSS-MASKING]].

A reference box adds an additional offset to the origin specified by the 'transform-origin' property.

For SVG elements without associated CSS layout box, the [=used value=] for ''transform-box/content-box'' is ''transform-box/fill-box'' and for ''transform-box/border-box'' is ''transform-box/stroke-box''.

For elements with associated CSS layout box, the [=used value=] for ''transform-box/fill-box'' is ''transform-box/content-box'' and for ''transform-box/stroke-box'' and ''transform-box/view-box'' is ''transform-box/border-box''.

The SVG <a element-attr for>transform</a> Attribute {#svg-transform}
====================================================================

SVG presentation attributes {#transform-attribute-specificity}
--------------------------------------------------------------

The 'transform-origin' CSS property is also a <a>presentation attribute</a> and extends the list of existing <a>presentation attributes</a> [[!SVG2]].

SVG 2 defines the <a element-attr for>transform</a>, <{pattern/patternTransform}>, <{linearGradient/gradientTransform}> attributes as <a>presentation attributes</a>, represented by the CSS 'transform' property [[!SVG2]].

The participation in the CSS cascade is determined by the specificity of <a>presentation attributes</a> in the SVG specification. According to SVG, user agents conceptually insert a <a href="https://www.w3.org/TR/SVG/styling.html#PresentationAttributes">new author style sheet</a> for presentation attributes, which is the first in the author style sheet collection [[!SVG2]].

<div class="example">
This example shows the combination of the 'transform' style property and the <a element-attr for>transform</a> attribute.

  <pre><code highlight=xml>
  &lt;svg xmlns="http://www.w3.org/2000/svg">
    &lt;style>
    .container {
      transform: translate(100px, 100px);
    }
    &lt;/style>

    &lt;g class="container" transform="translate(200 200)">
      &lt;rect width="100" height="100" fill="blue" />
    &lt;/g>
  &lt;/svg>
  </code></pre>

  <div class="figure">
    <img src="examples/svg-translate1.svg" width="470" height="240" alt="Translated SVG container element.">
  </div>

Because of the participation to the CSS cascade, the 'transform' style property overrides the <a element-attr for>transform</a> attribute. Therefore the container gets translated by ''100px'' in both the horizontal and the vertical directions, instead of ''200px''.
</div>

Syntax of the SVG <a element-attr for>transform</a> attribute {#svg-syntax}
---------------------------------------------------------------------------

For backwards compatibility reasons, the syntax of the <a element-attr for>transform</a>, <{pattern/patternTransform}>, <{linearGradient/gradientTransform}> attributes differ from the syntax of the 'transform' CSS property. For the attributes, there is no support for additional <<transform-function>>s defined for the CSS 'transform' property. Specifically, <<translateX()>>, <<translateY()>>, <<scaleX()>>, <<scaleY()>> and <<skew()>> are not supported by the <a element-attr for>transform</a>, <{pattern/patternTransform}>, <{linearGradient/gradientTransform}> attributes.

The following list uses the Backus-Naur Form (BNF) to define values for the <a element-attr for>transform</a>, <a element-attr for>patternTransform</a> and <a element-attr for>gradientTransform</a> attributes followed by an informative rail road diagram. The following notation is used:
* *: 0 or more
* +: 1 or more
* ?: 0 or 1
* (): grouping
* |: separates alternatives
* double quotes surround literals. Literals consists of <a>letter</a>s [[!CSS-SYNTAX-3]], left parenthesis and right parenthesis.
* <<number-token>> defined by the CSS Syntax module [[!CSS-SYNTAX-3]].

Note: The syntax reflects implemented behavior in user agents and differs from the syntax defined by SVG 1.1.

<dl>
  <dt>left parenthesis (</dt>
  <dd>U+0028 LEFT PARENTHESIS</dd>
  <dt>right parenthesis )</dt>
  <dd>U+0029 RIGHT PARENTHESIS</dd>
  <dt id="svg-comma">comma</dt>
  <dd>U+002C COMMA.
  <dt id="svg-wsp">wsp</dt>
  <dd>Either a U+000A LINE FEED, U+000D CARRIAGE RETURN, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
  <dd>
    <pre class='railroad'>
    Choice:
      T: space
      T: \t
      T: \r
      T: \f
    </pre>
  </dd>
  <dt id="svg-comma-wsp">comma-wsp</dt>
  <dd><pre>(wsp+ comma? wsp*) | (comma wsp*)</pre></dd>
  <dd>
    <pre class='railroad'>
    Choice:
      Seq:
        Plus:
          N: wsp
        Optional:
          N: comma
        Star:
          N: wsp
      Seq:
        N: comma
        Star:
          N: wsp
    </pre>
  </dd>
  <dt id="svg-translate">translate</dt>
  <dd><pre>"translate" wsp* "(" wsp* number ( comma-wsp? number )? wsp* ")"</pre></dd>
  <dd>
    <pre class='railroad'>
    Stack:
      Seq:
        T: translate
        Star:
          N: wsp
        T: (
        Star:
          N: wsp
      Seq:
        N: <number-token>
        Optional:
          Seq:
            Optional:
              N: comma-wsp
            N: <number-token>
      Seq:
        Star:
          N: wsp
        T: )
    </pre>
  </dd>
  <dt id="svg-scale">scale</dt>
  <dd><pre>"scale" wsp* "(" wsp* number ( comma-wsp? number )? wsp* ")"</pre></dd>
  <dd>
    <pre class='railroad'>
    Stack:
      Seq:
        T: scale
        Star:
          N: wsp
        T: (
        Star:
          N: wsp
      Seq:
        N: <number-token>
        Optional:
          Seq:
            Optional:
              N: comma-wsp
            N: <number-token>
      Seq:
        Star:
          N: wsp
        T: )
    </pre>
  </dd>
  <dt id="svg-rotate">rotate</dt>
  <dd><pre>"rotate" wsp* "(" wsp* number ( comma-wsp? number comma-wsp? number )? wsp* ")"</pre></dd>
  <dd>
    <pre class='railroad'>
    Stack:
      Seq:
        T: rotate
        Star:
          N: wsp
        T: (
        Star:
          N: wsp
      Seq:
        N: <number-token>
        Optional:
          Plus:
            Seq:
              Optional:
                N: comma-wsp
              N: <number-token>
            C: 1
      Seq:
        Star:
          N: wsp
        T: )
    </pre>
  </dd>
  <dt id="svg-skewX">skewX</dt>
  <dd><pre>"skewX" wsp* "(" wsp* number wsp* ")"</pre></dd>
  <dd>
    <pre class='railroad'>
    Stack:
      Seq:
        T: skewX
        Star:
          N: wsp
        T: (
        Star:
          N: wsp
      Seq:
        N: <number-token>
      Seq:
        Star:
          N: wsp
        T: )
    </pre>
  </dd>
  <dt  id="svg-skewY">skewY</dt>
  <dd><pre>"skewY" wsp* "(" wsp* number wsp* ")"</pre></dd>
  <dd>
    <pre class='railroad'>
    Stack:
      Seq:
        T: skewY
        Star:
          N: wsp
        T: (
        Star:
          N: wsp
      Seq:
        N: <number-token>
      Seq:
        Star:
          N: wsp
        T: )
    </pre>
  </dd>
  <dt id="svg-matrix">matrix</dt>
  <dd><pre>
"matrix" wsp* "(" wsp*
    number comma-wsp?
    number comma-wsp?
    number comma-wsp?
    number comma-wsp?
    number comma-wsp?
    number wsp* ")"
  </pre></dd>
  <dd>
    <pre class='railroad'>
    Stack:
      Seq:
        T: matrix
        Star:
          N: wsp
        T: (
        Star:
          N: wsp
      Seq:
        N: <number-token>
        Optional:
          Plus:
            Seq:
              Optional:
                N: comma-wsp
              N: <number-token>
            C: 4
      Seq:
        Star:
          N: wsp
        T: )
    </pre>
  </dd>
  <dt id="svg-transform-function">transform</dt>
  <dd><pre>
matrix
| translate
| scale
| rotate
| skewX
| skewY
  </pre></dd>
  <dd>
    <pre class='railroad'>
    Choice:
      N: translate
      N: scale
      N: rotate
      N: skewX
      N: skewY
      N: matrix
    </pre>
  </dd>
  <dt id="svg-transforms">transforms</dt>
  <dd><pre>
transform
| transform comma-wsp? transforms
  </dd></pre>
  <dd>
    <pre class='railroad'>
    Choice:
      N: transform
      Seq:
        N: transform
        Optional:
          N: comma-wsp
        N: transforms
    </pre>
  </dd>
  <dt id="svg-transform-list">transform-list</dt>
  <dd><pre>wsp* transforms? wsp*</pre></dd>
  <dd>
    <pre class='railroad'>
    Star:
      N: wsp
    Optional:
      N: transforms
    Star:
      N: wsp
    </pre>
  </dd>
</dl>

SVG transform functions {#svg-transform-functions}
--------------------------------------------------

SVG transform functions of the <a element-attr for>transform</a>, <{pattern/patternTransform}>, <{linearGradient/gradientTransform}> attributes defined by the syntax above are mapped to CSS <<transform-function>>s as follows:

<table class="data" id="term-matching">
  <thead>
    <tr>
      <th>SVG transform function
      <th>CSS <<transform-function>>
      <th>Additional notes
    </tr>
  </thead>
  <tbody>
    <tr>
      <th><a href="#svg-translate">translate</a>
      <td><<translate()>>
      <td>Number values interpreted as CSS <<length>> types with ''px'' units.
    </tr>
    <tr>
      <th><a href="#svg-scale">scale</a>
      <td><<scale()>>
      <td>
    </tr>
    <tr>
      <th><a href="#svg-rotate">rotate</a>
      <td><<rotate()>>
      <td>Only single value version. Number value interpreted as CSS <<angle>> type with ''deg'' unit.
    </tr>
    <tr>
      <th><a href="#svg-skewX">skewX</a>
      <td><<skewX()>>
      <td>Number value interpreted as CSS <<angle>> type with ''deg'' unit.
    </tr>
    <tr>
      <th><a href="#svg-skewY">skewY</a>
      <td><<skewY()>>
      <td>Number value interpreted as CSS <<angle>> type with ''deg'' unit.
    </tr>
    <tr>
      <th><a href="#svg-matrix">matrix</a>
      <td><<matrix()>>
      <td>
    </tr>
  </tbody>
</table>

The SVG transform function <a href="#svg-rotate">rotate</a> with 3 values can not be mapped to a corresponding CSS <<transform-function>>. The 2 optional number values represent a horizontal translation value ''cx'' followed by a vertical translation value ''cy''. Both number values get interpreted as CSS <<length>> types with ''px'' units and define the origin for rotation. The behavior is equivalent to an initial translation by ''cx'', ''cy'', a rotation defined by the first number value interpreted as <<angle>> type with ''deg'' unit followed by a translation by ''-cx'', ''-cy''.

A <a element-attr for>transform</a> attribute can be the start or end value of a CSS Transition. If the value of a <a element-attr for>transform</a> attribute is the start or end value of a CSS Transition and the SVG <a href="#svg-transform-list">transform list</a> contains at least one <a href="#svg-rotate">rotate</a> transform function with 3 values, the individual SVG transform functions must get <a>post-multiplied</a> and the resulting matrix must get mapped to a <<matrix()>> CSS <<transform-function>> and used as start/end value of the CSS Transition.

User coordinate space {#svg-user-coordinate-space}
--------------------------------------------------

For the <{pattern}> element, the <{pattern/patternTransform}> attribute and 'transform' property define an additional transformation in the pattern coordinate system. See <{pattern/patternUnits}> attribute for details [[!SVG2]].

For the <{linearGradient}> and <{radialGradient}> elements, the <{linearGradient/gradientTransform}> attribute and 'transform' property define an additional transformation in the gradient coordinate system. See <{linearGradient/gradientUnits}> attribute for details [[!SVG2]].

For the <{clipPath}> element, the <a element-attr for>transform</a> attribute and 'transform' property define an additional transformation in the clipping path coordinate space. See <{clipPath/clipPathUnits}> attribute for details [[!CSS-MASKING]].

For all other [=transformable elements=] the <a element-attr for>transform</a> attribute and 'transform' property define a transformation in the current user coordinate system of the parent. All percentage values of the <a element-attr for>transform</a> attribute are relative to the element's [=reference box=].

<div class="example">

The 'transform-origin' property on the pattern in the following example specifies a ''50%'' translation of the origin in the horizontal and vertical dimension. The 'transform' property specifies a translation as well, but in absolute lengths.

  <pre><code highlight=xml>
  &lt;svg xmlns="http://www.w3.org/2000/svg">
    &lt;style>
    pattern {
      transform: rotate(45deg);
      transform-origin: 50% 50%;
    }
    &lt;/style>

    &lt;defs>
    &lt;pattern id="pattern-1">
      &lt;rect id="rect1" width="100" height="100" fill="blue" />
    &lt;/pattern>
    &lt;/defs>

    &lt;rect width="200" height="200" fill="url(#pattern-1)" />
  &lt;/svg>
  </code></pre>

An SVG <{pattern}> element doesn't have a bounding box. The [=reference box=] of the referencing <{rect}> element is used instead to solve the relative values of the 'transform-origin' property. Therefore the point of origin will get translated  by 100 pixels temporarily to rotate the user space of the <{pattern}> elements content.

</div>

SVG DOM interface for the <a element-attr for>transform</a> attribute {#transform-attribute-dom}
------------------------------------------------------------------------------------------------

The SVG specification defines the "<a href="https://www.w3.org/TR/2011/REC-SVG11-20110816/coords.html#InterfaceSVGAnimatedTransformList">SVGAnimatedTransformList</a>" interface in the SVG DOM to provide access to the animated and the base value of the SVG <a element-attr for>transform</a>, <{linearGradient/gradientTransform}> and <{pattern/patternTransform}> attributes. To ensure backwards compatibility, this API must still be supported by user agents.

{{baseVal}} gives the author the possibility to access and modify the values of the SVG <a element-attr for>transform</a>, <{pattern/patternTransform}>, <{linearGradient/gradientTransform}> attributes. To provide the necessary backwards compatibility to the SVG DOM, {{baseVal}} must reflect the values of this author style sheet. All modifications to SVG DOM objects of {{baseVal}} must affect this author style sheet immediately.

{{animVal}} represents the computed style of the 'transform' property. Therefore it includes all applied <a href="https://www.w3.org/TR/css3-transitions/">CSS3 Transitions</a>, <a href="https://www.w3.org/TR/css3-animations/">CSS3 Animations</a> or SVG Animations if any of those are underway. The computed style and SVG DOM objects of {{animVal}} can not be modified.

The Transform Functions {#transform-functions}
==============================================

The value of the 'transform' property is a list of <dfn>&lt;transform-function></dfn>.
The set of allowed transform functions is given below.
In the following functions,
a <<zero>> behaves the same as ''0deg''
("unitless 0" angles are preserved for legacy compat).
A percentage for horizontal translations is relative to the width of the [=reference box=].
A percentage for vertical translations is relative to the height of the [=reference box=].

2D Transform Functions {#two-d-transform-functions}
----------------------

<dl dfn-for=transform>
	: <span class='prod'><dfn>matrix()</dfn> = matrix( <<number>>#{6} )</span>
	:: specifies a 2D transformation in the form of a <a href="#MatrixDefined">transformation matrix</a> of the six values a, b, c, d, e, f.

	: <span class='prod'><dfn>translate()</dfn> = translate( <<length-percentage>> , <<length-percentage>>? )</span>
	:: specifies a <a href="#TranslateDefined">2D translation</a> by the vector [tx, ty], where tx is the first translation-value parameter and ty is the optional second translation-value parameter. If <em>&lt;ty></em> is not provided, ty has zero as a value.

	: <span class='prod'><dfn>translateX()</dfn> = translateX( <<length-percentage>> )</span>
	:: specifies a <a href="#TranslateDefined">translation</a> by the given amount in the X direction.

	: <span class='prod'><dfn>translateY()</dfn> = translateY( <<length-percentage>> )</span>
	:: specifies a <a href="#TranslateDefined">translation</a> by the given amount in the Y direction.

	: <span class='prod'><dfn>scale()</dfn> = scale( <<number>> , <<number>>? )</span>
	:: specifies a <a href="#ScaleDefined">2D scale</a> operation by the [sx,sy] scaling vector described by the 2 parameters. If the second parameter is not provided, it takes a value equal to the first. For example, scale(1, 1) would leave an element unchanged, while scale(2, 2) would cause it to appear twice as long in both the X and Y axes, or four times its typical geometric size.

	: <span class='prod'><dfn>scaleX()</dfn> = scaleX( <<number>> )</span>
	:: specifies a <a href="#ScaleDefined">2D scale</a> operation using the [sx,1] scaling vector, where sx is given as the parameter.

	: <span class='prod'><dfn>scaleY()</dfn> = scaleY( <<number>> )</span>
	:: specifies a <a href="#ScaleDefined">2D scale</a> operation using the [1,sy] scaling vector, where sy is given as the parameter.

	: <span class='prod'><dfn>rotate()</dfn> = rotate( [ <<angle>> | <<zero>> ] )</span>
	:: specifies a <a href="#RotateDefined">2D rotation</a> by the angle specified in the parameter about the origin of the element, as defined by the 'transform-origin' property. For example, ''rotate(90deg)'' would cause elements to appear rotated one-quarter of a turn in the clockwise direction.

	: <span class='prod'><dfn>skew()</dfn> = skew( [ <<angle>> | <<zero>> ] , [ <<angle>> | <<zero>> ]? )</span>
	:: specifies a <a href="#SkewDefined">2D skew</a> by [ax,ay] for X and Y. If the second parameter is not provided, it has a zero value.

    	Advisement: ''skew()'' exists for compatibility reasons, and should not be used in new content. Use ''skewX()'' or ''skewY()'' instead, noting that the behavior of ''skew()'' is different from multiplying ''skewX()'' with ''skewY()''.

	: <span class='prod'><dfn>skewX()</dfn> = skewX( [ <<angle>> | <<zero>> ] )</span>
	:: specifies a <a href="#SkewXDefined">2D skew transformation along the X axis</a> by the given angle.

	: <span class='prod'><dfn>skewY()</dfn> = skewY( [ <<angle>> | <<zero>> ] )</span>
	:: specifies a <a href="#SkewYDefined">2D skew transformation along the Y axis</a> by the given angle.

</dl>


Transform function primitives and derivatives {#transform-primitives}
---------------------------------------------

Some transform functions can be represented by more generic transform functions. These transform functions are called derived transform functions, and the generic transform functions are called primitive transform functions. Two-dimensional primitives and their derived transform functions are:

<dl>
	<dt id="translate-primitive">''translate()''
	<dd>for <<translateX()>>, <<translateY()>> and <<translate()>>.

	<dt id="scale-primitive">''scale()''
	<dd>for <<scaleX()>>, <<scaleY()>> and <<scale()>>.

</dl>


The Transform Function Lists {#transform-function-lists}
========================================================

If a list of <<transform-function>>s is provided, then the net effect is as if each transform function had been specified separately in the order provided.

That is, in the absence of other styling that affects position and dimensions, a nested set of transforms is equivalent to a single list of transform functions, applied from the coordinate system of the ancestor to the [=local coordinate system=] of a given element. The resulting transform is the matrix multiplication of the list of transforms.

<div class=example>
For example,

<pre><code highlight=html>
&lt;div style="transform: translate(-10px, -20px) scale(2) rotate(45deg)"/>
</code></pre>

is functionally equivalent to:

<pre><code highlight=html>
&lt;div style="transform: translate(-10px, -20px)" id="root">
  &lt;div style="transform: scale(2)">
    &lt;div style="transform: rotate(45deg)">
    &lt;/div>
  &lt;/div>
&lt;/div>
</code></pre>
</div>

If a transform function causes the [=current transformation matrix=] of an object to be non-invertible, the object and its content do not get displayed.

<div class="example">

The object in the following example gets scaled by 0.

  <pre><code highlight=html>
  &lt;style>
  .box {
    transform: scale(0);
  }
  &lt;/style>

  &lt;div class="box">
    Not visible
  &lt;/div>
  </code></pre>

The scaling causes a non-invertible CTM for the coordinate space of the div box. Therefore neither the div box, nor the text in it get displayed.

</div>

Interpolation of Transforms {#interpolation-of-transforms}
==========================================================

[=Interpolation=] of transform function lists is performed as follows:

<ul>
  <li id=none-none-interpolation>
    If both <var>V<sub>a</sub></var> and <var>V<sub>b</sub></var>
    are ''transform/none'':
      * <var>V<sub>result</sub></var> is ''transform/none''.

  <li id=transform-interpolation-length-fixup>
    Treating ''transform/none'' as a list of zero length,
    if <var>V<sub>a</sub></var> or <var>V<sub>b</sub></var> differ in length:
      * extend the shorter list to the length of the longer list,
        setting the function at each additional position
        to the [=identity transform function=] matching
        the function at the corresponding position in the longer list.
        Both transform function lists are then interpolated
        following the next rule.

    <div class=example>
        For example, if <var>V<sub>a</sub></var> is ''scale(2)''
        and <var>V<sub>b</sub></var> is ''transform/none''
        then the value ''scale(1)'' will be used for <var>V<sub>b</sub></var>
        and interpolation will proceed using the next rule.
        Similarly, if <var>V<sub>a</sub></var> is ''scale(1)''
        and <var>V<sub>b</sub></var> is ''scale(2) rotate(50deg)''
        then the interpolation will be performed as if
        <var>V<sub>a</sub></var> were ''scale(1) rotate(0)''.
    </div>

  <li>
    Let <var>V<sub>result</sub></var> be an empty list.
    Beginning at the start of
    <var>V<sub>a</sub></var> and <var>V<sub>b</sub></var>,
    compare the corresponding functions at each position:
      * While the functions have either the same name,
        or are derivatives of the same
        [[#transform-primitives|primitive transform function]],
        interpolate the corresponding pair of functions as described in
        [[#interpolation-of-transform-functions]]
        and append the result to <var>V<sub>result</sub></var>.
      * If the pair do not have a common name
        or [[#transform-primitives|primitive transform function]],
        post-multiply the remaining transform functions in each of
        <var>V<sub>a</sub></var> and <var>V<sub>b</sub></var> respectively
        to produce two 4x4 matrices.
        [=Interpolate=] these two matrices as described in
        [[#matrix-interpolation]],
        append the result to <var>V<sub>result</sub></var>,
        and cease iterating over
        <var>V<sub>a</sub></var> and <var>V<sub>b</sub></var>.

    <div class=example>
        For example,
        if <var>V<sub>a</sub></var> is ''rotate(0deg) scale(1) translate(20px)''
        and <var>V<sub>b</sub></var> is ''rotate(270deg) translate(10px) scale(2)'',
        the ''rotate(0deg)'' and ''rotate(360deg)'' functions will be interpolated
        according to [[#interpolation-of-transform-functions]]
        while the remainder of each list--
        ''scale(1) translate(20px)'' and ''translate(10px) scale(2)''--
        will first be converted to equivalent 4x4 matrices
        and then interpolated as described in [[#matrix-interpolation]].

        A previous version of this specification
        did not attempt to interpolate matching pairs of transform functions
        unless all functions in the list matched.
        As a result, the two lists in this example would be interpolated
        using matrix interpolation only
        and the ''rotate(360deg)'' component of the second list would be lost.
    </div>

</ul>

In some cases, an animation might cause a transformation matrix to be singular or non-invertible. For example, an animation in which scale moves from 1 to -1. At the time when the matrix is in such a state, the transformed element is not rendered.


Interpolation of primitives and derived transform functions {#interpolation-of-transform-functions}
===================================================================================================

Two transform functions with the same name and the same number of arguments are interpolated numerically without a former conversion. The calculated value will be of the same transform function type with the same number of arguments. Special rules apply to <<matrix()>>.

<div class="example">

The two transform functions ''translate(0)'' and ''translate(100px)'' are of the same type, have the same number of arguments and therefore can get interpolated numerically. ''translateX(100px)'' is not of the same type and ''translate(100px, 0)'' does not have the same number of arguments, therefore these transform functions can not get interpolated without a former conversion step.

</div>

Two different types of transform functions that share the same primitive, or transform functions of the same type with different number of arguments can be interpolated. Both transform functions need a former conversion to the common primitive first and get interpolated numerically afterwards. The computed value will be the primitive with the resulting interpolated arguments.

<div class="example">

The following example describes a transition from ''translateX(100px)'' to ''translateY(100px)'' in 3 seconds on hovering over the div box. Both transform functions derive from the same primitive ''translate()''
and therefore can be interpolated.

  <pre><code highlight=css>
  div {
    transform: translateX(100px);
  }

  div:hover {
    transform: translateY(100px);
    transition: transform 3s;
  }
  </code></pre>

For the time of the transition both transform functions get transformed to the common primitive. ''translateX(100px)'' gets converted to ''translate(100px, 0)'' and ''translateY(100px)'' gets converted to ''translate(0, 100px)''. Both transform functions can then get interpolated numerically.
</div>

If both transform functions share a primitive in the two-dimensional space, both transform functions get converted to the two-dimensional primitive. If one or both transform functions are three-dimensional transform functions, the common three-dimensional primitive is used.

<div class="example">

In this example a two-dimensional transform function gets animated to a three-dimensional transform function. The common primitive is ''translate3d()''.

  <pre><code highlight=css>
  div {
    transform: translateX(100px);
  }

  div:hover {
    transform: translateZ(100px);
    transition: transform 3s;
  }
  </code></pre>

First ''translateX(100px)'' gets converted to ''translate3d(100px, 0, 0)'' and ''translateZ(100px)'' to ''translate3d(0, 0, 100px)'' respectively. Then both converted transform functions get interpolated numerically.

</div>


Interpolation of Matrices {#matrix-interpolation}
=================================================

When interpolating between two matrices, each matrix is decomposed into the corresponding translation, rotation, scale, skew. Each corresponding component of the decomposed matrices gets interpolated numerically and recomposed back to a matrix in a final step.

<div class="example">
In the following example the element gets translated by 100 pixel in both the X and Y directions and rotated by 1170&deg; on hovering. The initial transformation is 45&deg;. With the usage of transition, an author might expect a animated, clockwise rotation by three and a quarter turns (1170&deg;).

<pre><code highlight=html>
&lt;style>
div {
  transform: rotate(45deg);
}
div:hover {
  transform: translate(100px, 100px) rotate(1215deg);
  transition: transform 3s;
}
&lt;/style>

&lt;div>&lt;/div>
</code></pre>

The number of transform functions on the source transform ''rotate(45deg)'' differs from the number of transform functions on the destination transform ''translate(100px, 100px) rotate(1125deg)''. According to the last rule of <a href="#interpolation-of-transforms">Interpolation of Transforms</a>, both transforms must be interpolated by matrix interpolation. With converting the transformation functions to matrices, the information about the three turns gets lost and the element gets rotated by just a quarter turn (90&deg;).

To achieve the three and a quarter turns for the example above, source and destination transforms must fulfill the third rule of <a href="#interpolation-of-transforms">Interpolation of Transforms</a>. Source transform could look like ''translate(0, 0) rotate(45deg)'' for a linear interpolation of the transform functions.
</div>

In the following we differ between the <a href="#interpolation-of-2d-matrices">interpolation of two 2D matrices</a> and the interpolation of two matrices where at least one matrix is not a [=2D matrix=].

If one of the matrices for interpolation is non-invertible, the used animation function must fall-back to a discrete animation according to the rules of the respective animation specification.

<h3 id="supporting-functions">Supporting functions</h3>

The pseudo code in the next subsections make use of the following supporting functions:

<pre>
Supporting functions (point is a 3 component vector, matrix is a 4x4 matrix, vector is a 4 component vector):
  double  determinant(matrix)          returns the 4x4 determinant of the matrix
  matrix  inverse(matrix)              returns the inverse of the passed matrix
  matrix  transpose(matrix)            returns the transpose of the passed matrix
  point   multVecMatrix(point, matrix) multiplies the passed point by the passed matrix
                                       and returns the transformed point
  double  length(point)                returns the length of the passed vector
  point   normalize(point)             normalizes the length of the passed point to 1
  double  dot(point, point)            returns the dot product of the passed points
  double  sqrt(double)                 returns the root square of passed value
  double  max(double y, double x)      returns the bigger value of the two passed values
  double  dot(vector, vector)         returns the dot product of the passed vectors
  vector  multVector(vector, vector)  multiplies the passed vectors
  double  sqrt(double)                returns the root square of passed value
  double  max(double y, double x)     returns the bigger value of the two passed values
  double  min(double y, double x)     returns the smaller value of the two passed values
  double  cos(double)                 returns the cosines of passed value
  double  sin(double)                 returns the sine of passed value
  double  acos(double)                returns the inverse cosine of passed value
  double  abs(double)                  returns the absolute value of the passed value
  double  rad2deg(double)              transforms a value in radian to degree and returns it
  double  deg2rad(double)              transforms a value in degree to radian and returns it

Decomposition also makes use of the following function:
  point combine(point a, point b, double ascl, double bscl)
      result[0] = (ascl * a[0]) + (bscl * b[0])
      result[1] = (ascl * a[1]) + (bscl * b[1])
      result[2] = (ascl * a[2]) + (bscl * b[2])
      return result
</pre>

<h3 id="interpolation-of-2d-matrices">Interpolation of 2D matrices</h3>

<h4 id="decomposing-a-2d-matrix">Decomposing a 2D matrix</h4>

The pseudo code below is based upon the "unmatrix" method in "Graphics Gems II, edited by Jim Arvo".

Matrices in the pseudo code use the column-major order. The first index on a matrix entry represents the column and the second index represents the row.

<pre>
Input:  matrix      ; a 4x4 matrix
Output: translation ; a 2 component vector
        scale       ; a 2 component vector
        angle       ; rotation
        m11         ; 1,1 coordinate of 2x2 matrix
        m12         ; 1,2 coordinate of 2x2 matrix
        m21         ; 2,1 coordinate of 2x2 matrix
        m22         ; 2,2 coordinate of 2x2 matrix
Returns false if the matrix cannot be decomposed, true if it can


double row0x = matrix[0][0]
double row0y = matrix[0][1]
double row1x = matrix[1][0]
double row1y = matrix[1][1]

translate[0] = matrix[3][0]
translate[1] = matrix[3][1]

scale[0] = sqrt(row0x * row0x + row0y * row0y)
scale[1] = sqrt(row1x * row1x + row1y * row1y)

// If determinant is negative, one axis was flipped.
double determinant = row0x * row1y - row0y * row1x
if (determinant < 0)
    // Flip axis with minimum unit vector dot product.
    if (row0x < row1y)
        scale[0] = -scale[0]
    else
        scale[1] = -scale[1]

// Renormalize matrix to remove scale.
if (scale[0])
    row0x *= 1 / scale[0]
    row0y *= 1 / scale[0]
if (scale[1])
    row1x *= 1 / scale[1]
    row1y *= 1 / scale[1]

// Compute rotation and renormalize matrix.
angle = atan2(row0y, row0x);

if (angle)
    // Rotate(-angle) = [cos(angle), sin(angle), -sin(angle), cos(angle)]
    //                = [row0x, -row0y, row0y, row0x]
    // Thanks to the normalization above.
    double sn = -row0y
    double cs = row0x
    double m11 = row0x
    double m12 = row0y
    double m21 = row1x
    double m22 = row1y
    row0x = cs * m11 + sn * m21
    row0y = cs * m12 + sn * m22
    row1x = -sn * m11 + cs * m21
    row1y = -sn * m12 + cs * m22

m11 = row0x
m12 = row0y
m21 = row1x
m22 = row1y

// Convert into degrees because our rotation functions expect it.
angle = rad2deg(angle)

return true
</pre>

<h4 id="interpolation-of-decomposed-2d-matrix-values">
  Interpolation of decomposed 2D matrix values
</h4>

Before two decomposed 2D matrix values can be interpolated, the following

<pre>
Input: translationA ; a 2 component vector
       scaleA       ; a 2 component vector
       angleA       ; rotation
       m11A         ; 1,1 coordinate of 2x2 matrix
       m12A         ; 1,2 coordinate of 2x2 matrix
       m21A         ; 2,1 coordinate of 2x2 matrix
       m22A         ; 2,2 coordinate of 2x2 matrix
       translationB ; a 2 component vector
       scaleB       ; a 2 component vector
       angleB       ; rotation
       m11B         ; 1,1 coordinate of 2x2 matrix
       m12B         ; 1,2 coordinate of 2x2 matrix
       m21B         ; 2,1 coordinate of 2x2 matrix
       m22B         ; 2,2 coordinate of 2x2 matrix


// If x-axis of one is flipped, and y-axis of the other,
// convert to an unflipped rotation.
if ((scaleA[0] < 0 && scaleB[1] < 0) || (scaleA[1] < 0 && scaleB[0] < 0))
    scaleA[0] = -scaleA[0]
    scaleA[1] = -scaleA[1]
    angleA += angleA < 0 ? 180 : -180

// Don't rotate the long way around.
if (!angleA)
    angleA = 360
if (!angleB)
    angleB = 360

if (abs(angleA - angleB) > 180)
    if (angleA > angleB)
        angleA -= 360
    else
        angleB -= 360
</pre>

Afterwards, each component of the decomposed values translation, scale, angle, m11 to m22 of the source matrix get linearly interpolated with each corresponding component of the destination matrix.

<h4 id="recomposing-to-a-2d-matrix">Recomposing to a 2D matrix</h4>

After interpolation, the resulting values are used to transform the elements user space. One way to use these values is to recompose them into a 4x4 matrix. This can be done following the pseudo code below.

Matrices in the pseudo code use the column-major order. The first index on a matrix entry represents the column and the second index represents the row.

<pre>
Input:  translation ; a 2 component vector
        scale       ; a 2 component vector
        angle       ; rotation
        m11         ; 1,1 coordinate of 2x2 matrix
        m12         ; 1,2 coordinate of 2x2 matrix
        m21         ; 2,1 coordinate of 2x2 matrix
        m22         ; 2,2 coordinate of 2x2 matrix
Output: matrix      ; a 4x4 matrix initialized to identity matrix


matrix[0][0] = m11
matrix[0][1] = m12
matrix[1][0] = m21
matrix[1][1] = m22

// Translate matrix.
matrix[3][0] = translate[0] * m11 + translate[1] * m21
matrix[3][1] = translate[0] * m12 + translate[1] * m22

// Rotate matrix.
angle = deg2rad(angle);
double cosAngle = cos(angle);
double sinAngle = sin(angle);

// New temporary, identity initialized, 4x4 matrix rotateMatrix
rotateMatrix[0][0] = cosAngle
rotateMatrix[0][1] = sinAngle
rotateMatrix[1][0] = -sinAngle
rotateMatrix[1][1] = cosAngle

matrix = post-multiply(rotateMatrix, matrix)

// Scale matrix.
matrix[0][0] *= scale[0]
matrix[0][1] *= scale[0]
matrix[1][0] *= scale[1]
matrix[1][1] *= scale[1]
</pre>


Mathematical Description of Transform Functions {#mathematical-description}
===========================================================================

Mathematically, all transform functions can be represented as 4x4 transformation matrices of the following form:

<img src="images/4x4matrix.png" alt="\begin{bmatrix} m11 & m21 & m31 & m41 \\ m12 & m22 & m32 & m42 \\ m13 & m23 & m33 & m43 \\ m14 & m24 & m34 & m44 \end{bmatrix}" width="222" height="106">

One translation unit on a matrix is equivalent to 1 pixel in the local coordinate system of the element.

<ul>
  <li id="MatrixDefined">
    <p>
      A 2D 3x2 matrix with six parameters <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em> and <em>f</em> is equivalent to the matrix:

    <img src="images/matrix.png" alt="\begin{bmatrix} a & c & 0 & e \\ b & d & 0 & f \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="108" height="106">

  <li id="TranslateDefined">
    <p>
      A 2D translation with the parameters <em>tx</em> and <em>ty</em> is equivalent to a 3D translation where <em>tz</em> has zero as a value.

      <img src="images/translate3d.png" alt="\begin{bmatrix} 1 & 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & tz \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="114" height="106">

  <li id="ScaleDefined">
    <p>
      A 2D scaling with the parameters <em>sx</em> and <em>sy</em> is equivalent to a 3D scale where <em>sz</em> has one as a value.

      <img src="images/scale3d.png" alt="\begin{bmatrix} sx & 0 & 0 & 0 \\ 0 & sy & 0 & 0 \\ 0 & 0 & sz & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="137" height="106">

  <li id="RotateDefined">
    <p>
      A 2D rotation with the parameter <em>alpha</em> is
      equivalent to a 3D rotation with the vector [x,y,z] where <em>x</em> has zero as a value, <em>y</em> has zero as a value, <em>z</em> has one as a value, and the parameter <em>alpha</em>.

      <img src="images/rotate3dmatrix.png" alt="\begin{bmatrix} 1 - 2 \cdot (y^2 + z^2) \cdot sq & 2 \cdot (x \cdot y \cdot sq - z \cdot sc) & 2 \cdot (x \cdot z \cdot sq + y \cdot sc) & 0 \\ 2 \cdot (x \cdot y \cdot sq + z \cdot sc) & 1 - 2 \cdot (x^2 + z^2) \cdot sq & 2 \cdot (y \cdot z \cdot sq - x \cdot sc) & 0 \\ 2 \cdot (x \cdot z \cdot sq - y \cdot sc) & 2 \cdot (y \cdot z \cdot sq + x \cdot sc) & 1 - 2 \cdot (x^2 + y^2) \cdot sq & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="647" height="106">

			where:

      <img src="images/rotate3dvariables.png" alt="\newline sc = \sin (\alpha/2) \cdot \cos (\alpha/2) \newline sq = \sin^2 (\alpha/2)" width="221" height="50">

  <li id="SkewDefined">
    <p>
      A 2D skew like transformation with the parameters <em>alpha</em> and <em>beta</em> is equivalent to the matrix:

    <img src="images/skew.png" alt="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="205" height="106">

  <li id="SkewXDefined">
    <p>
      A 2D skew transformation along the X axis with the parameter <em>alpha</em> is equivalent to the matrix:

    <img src="images/skewX.png" alt="\begin{bmatrix} 1 & \tan(\alpha) & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="155" height="106">

  <li id="SkewYDefined">
    <p>
      A 2D skew transformation along the Y axis with the parameter <em>beta</em> is equivalent to the matrix:

    <img src="images/skewY.png" alt="\begin{bmatrix} 1 & 0 & 0 & 0 \\ \tan(\beta) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}" width="155" height="106">

</ul>

# Privacy and Security Considerations # {#priv-sec}
UAs must implement transform operations in a way attackers can not infer information and mount a timing attack.

A timing attack is a method of obtaining information about content that is otherwise protected, based on studying the amount of time it takes for an operation to occur.

At this point there are no information about potential privacy or security concerns specific to this specification.

<h2 class="no-num" id="changes">Changes</h2>

<h3 class="no-num" id="CR20190214">Since the <a href="https://www.w3.org/TR/2019/CR-css-transforms-1-20190214/">14 February 2019 Candidate Recommendation</a></h3>

* Relax syntax of <a element-attr for>transform</a> attribute: Do not require commas between <<transform-list>> items.
* Simplified grammar of transform functions. (No normative impact.)
* Remove animation support of 'transform' from <a element>animate</a> and <a element>set</a> elements.
* Editorial changes.

<h3 class="no-num" id="WD20181130">Since the <a href="https://www.w3.org/TR/2018/WD-css-transforms-1-20181130/">30 November 2018 Working Draft</a></h3>

* No substantive changes
* Boilerplate, styling updates for CR


<h3 class="no-num" id="WD20171130">Since the <a href="https://www.w3.org/TR/2017/WD-css-transforms-1-20171130/">30 November 2017 Working Draft</a>
</h3>

* Remove specification text that makes <a element-attr for=pattern>patternTransform</a>, <a element-attr for=linearGradient>gradientTransform</a> presentation attributes representing the 'transform' property. That is going to get specified by SVG 2 [[SVG2]].
* Added <a href="#priv-sec">privacy and security</a> section.
* Use [[SVG2]] definitions for <a>transformable elements</a>.
* Added special syntax for <a element-attr for>transform</a>, <{linearGradient/gradientTransform}> and <{pattern/patternTransform}> attributes.
* Clarify multiplication order by using terms <a>post-multiply</a> and <a>pre-multiply</a>.
* Clarify index order of matrix entries in pseudo-code.
* Clarify multiplication order in recomposition pseudo-code.
* Clarify behavior of 'transform' on overflow area.
* Remove ''translateX(0)'', ''translateY(0)'', ''scaleX(0)'', ''scaleY(0)'' from the list of neutral elements.
* Remove any reference of 3D transformations of transform function definitions.
* Specify interpolation between <<transform-list>>s to match lengths and
    avoid matrix interpolation for the common prefix of the two lists.
* No 'transform' on non-replaced inline boxes, table-column boxes, and table-column-group boxes.
* Define target coordinate space for transformations on <{pattern}>, <{linearGradient}>, <{radialGradient}> and <{clipPath}> elements.
* Remove 3-value <<rotate()>> from transform function primitives.
* Be more specific about computation of [=transformation matrix=] and [=current transformation matrix=].
* Define reference box for paint servers and <{clipPath}> element.
* Specify behavior of transform presentation attribute with 3-value-rotate as start or end value of a transition.
* Add ''transform-box/stroke-box'' and ''transform-box/content-box'' to 'transform-box'. Align box mapping behavior across all specifications.
* Editorial changes.

<h2 class=no-num id='acknowledgments'>Acknowledgments</h2>

The editors would like to thank Robert OCallahan, Cameron McCormack, Tab Atkins, Grard Talbot, L. David Baron, Rik Cabanier, Brian Birtles, Benoit Jacob, Ken Shoemake, Alan Gresley, Maciej Stochowiak, Sylvain Galineau, Rafal Pietrak, Shane Stephens, Matt Rakow, XiangHongAi, Fabio M. Costa, Nivesh Rajbhandari, Rebecca Hauck, Gregg Tavares, Graham Clift, Erik Dahlstrm, Alexander Zolotov, Amelia Bellamy-Royds and Boris Zbarsky for their careful reviews, comments, and corrections.
