<h1>CSS Table Module Level 3</h1>
<pre class='metadata'>
Shortname: css-tables-3
Level: 3
Status: ED
Work Status: Exploring
Group: csswg
ED: https://drafts.csswg.org/css-tables-3/
TR: https://www.w3.org/TR/CSS2/tables.html
Editor: Francois Remy, Microsoft
Editor: Greg Whitworth, Microsoft
Former editor: Bert Bos, W3C
Former editor: David Baron, Mozilla
Former editor: Markus Mielke, Microsoft
Former editor: Saloni Mira Rai, Microsoft
!Issue Tracking: <a href="https://github.com/gregwhitworth/css-table-3/issues">Github</a>
Abstract: This CSS module defines a two-dimensional grid-based layout system, optimized for tabular data rendering. In the table layout model, each display node is assigned to an intersection between a set of consecutive rows and a set of consecutive columns, themselves generated from the table structure and sized according to their content.
Ignored Terms: block-level box
</pre>

<!--------------------------------------------------------------------------------->
<h2 id="intro">Introduction</h2>

	<p><em>This section is not normative</em></p>
	<p>
		Many types of information (ex: weather readings collected over the past year)
			are best visually represented in a two-axis grid
			where rows represent one item of the list
				(ex: a date, and the various weather properties measured during that day),
			and where columns represent the successive values of an items property
				(ex: the temperatures measured over the past year).
	<p>
		Sometimes, to make the representation easier to understand,
			some cells of the grid are used to represent a description or summary of their parent row/column,
			instead of actual data.
		This happens more frequently for
			the cells found on the first row and/or column (called headers)
			or the cells found on the last row and/or column (called footers).

	<p>
		This kind of tabular data representation is usually known as tables.
		Tables layout can be abused to render other grid-like representations like calendars or timelines,
			though authors should prefer other layout modes
			when the information being represented does not make sense as a data table.
	<p>
		The rendering of tables in HTML has been defined for a long time in the HTML specification.
		However, its interactions with features defined in CSS remained for a long time undefined.
		The goal of this specification is to define
			the expected behavior of user agents supporting both HTML tables and CSS.
	<p>
		Please be aware that some behaviors defined in this document
			will not be the most logical or useful way of solving the problem they aim to solve,
			but such behaviors are often the result of compatibility requirements and not a deliberate choice
			of the editors of this specification.
		Authors wishing to use more complex layouts 
			are encouraged to rely on more modern CSS modules such as CSS Grids.

<!--------------------------------------------------------------------------------->
<h2 id="content-model">Content Model</h2>

	<!--------------------------------------------------------------------------------->
	<h3 id="table-structure">Table Structure</h3>

		<p>
			The CSS table model is based on the HTML4 table model,
				in which the structure of a table closely parallels the visual layout of the table.
			In this model, a table consists of an optional caption and any number of rows of cells.

		<p>
			In addition, adjacent rows and columns may be grouped structurally and
			this grouping can be reflected in presentation (e.g., a border may be drawn around a group of rows).

		<p>
			The table model is said to be "row primary" since 
				authors specify rows, not columns, explicitly in the document language.
			Columns are derived once all the rows have been specified:
				the first cell of the first row belongs to the first column
					and as many other columns as spanning requires (and it creates them if needed),
				and the following cells of that row each belong to the next available column
					and as many other columns as spanning requires (creating those if needed);
				the cells of the following rows each belong to the next available column for that row (taking rowspan into account)
					and as many other columns as spanning requires (creating those if needed).
				<span class="hint">(see [[#spanning]] and [[#dimensioning-the-row-column-grid]])</span>.

		<p>
			To summarize, an instance of the table model consists of:
			<ul class="compact">
				<li>Its <a href="#table-root-element">table-root element</a> containing:
				<ul>
					<li>One or more <a href="#table-row">table rows</a>, optionally in <a href="#table-row-grouping-element">row groups</a>,
						<ul><li>Each of them contaning one or more <a href="#table-cell">table cells</a></li></ul>
					<li>Optionally: one or more <a href="#table-column">table columns</a>,
						optionally in <a href="#table-column-group">column groups</a>
					<li>Optionally: a <a href="#table-caption">table caption</a>.
				</ul>
			</ul>
			<style>
				ul.compact { margin-top: -1em !important; list-style-type: disc; }
				ul.compact li { margin-top: 0 !important; margin-bottom: 0 !important; list-style-type: disc; }
			</style>

		<figure>
			<img src="images/table-structure.png" width=493 />
			<figcaption>Two representations of the structure of a table (tree vs layout)</figcaption>
		</figure>

		<p>
			The CSS model does not require that the document language include elements that correspond to each of these components.
			For document languages (such as XML applications) that do not have pre-defined table elements,
				authors must map document language elements to table elements.
			This is done with the 'display' property.

		<p>
			The following 'display' values assign table formatting rules to an arbitrary element:

		<dl id="display-types">
			<dt><dfn>table</dfn> (In HTML: TABLE)
			<dd>Specifies that an element defines a block-level table:
				it is a rectangular block that participates in a block formatting context.

			<dt><dfn>inline-table</dfn> (In HTML: TABLE)
			<dd>Specifies that an element defines an inline-level table:
				it is a rectangular block that participates in an inline formatting context).

			<dt><dfn>table-row</dfn> (In HTML: TR)
			<dd>Specifies that an element is a row of cells.

			<dt><dfn>table-row-group</dfn> (In HTML: TBODY)
			<dd>Specifies that an element groups one or more rows.

			<dt><dfn>table-header-group</dfn> (In HTML: THEAD)
			<dd>Like table-row-group, but for visual formatting, 
				the first such row group is always displayed before all other rows and row groups.
				
				If a table contains multiple elements with <code>display: table-header-group</code>,
					only the first is rendered as a header; 
					the others are treated as if they had <code>display: table-row-group</code>.

			<dt><dfn>table-footer-group</dfn> (In HTML: TFOOT)
			<dd>Like table-row-group, but for visual formatting, 
				the fist such row group is always displayed after all other rows and row groups.
				
				If a table contains multiple elements with <code>display: table-footer-group</code>, 
					only the first is rendered as a footer;
					the others are treated as if they had <code>display: table-row-group</code>.

			<dt><dfn>table-column</dfn> (In HTML: COL)
			<dd>Specifies that an element describes a column of cells.

			<dt><dfn>table-column-group</dfn> (In HTML: COLGROUP)
			<dd>Specifies that an element groups one or more columns.

			<dt><dfn>table-cell</dfn> (In HTML: TD, TH)
			<dd>Specifies that an element represents a table cell.

			<dt><dfn>table-caption</dfn> (In HTML: CAPTION)
			<dd>Specifies a caption for the table.
		</dl>

		<h4 id="terminology">Terminology</h2>

			<p>
				In addition to the table structure display types,
				the following wording is also being used in this spec:

			<dl>
				<dt><dfn id="table-root-element">table-root</dfn> box or element
				<dd>
					A <a>table</a> or <a>inline-table</a> box.

				<dt><dfn id="table-non-root-element">table-non-root</dfn> box or element
				<dd>
					A <a>proper table child</a>, or a <a>table-cell</a> box.

				<dt><dfn id="table-row-grouping-element">table-row-grouping</dfn> box or element
				<dd>
					A
					<a>table-row-group</a>,
					<a>table-header-group</a>, or
					<a>table-footer-group</a> box.

				<dt><dfn id="table-track">table-track</dfn> box or element
				<dd>
					A
					<a>table-row</a>, or
					<a>table-column</a> box.

				<dt><dfn id="table-track-grouping-element">table-track-grouping</dfn> box or element
				<dd>
					A
					<a>table-row-grouping</a>, or
					<a>table-column-group</a> box.

				<dt><dfn id="proper-table-child-element">proper table child</dfn> box or element
				<dd>
					A
					<a>table-track-grouping</a>,
					<a>table-track</a>, or
					<a>table-caption</a> box.

				<dt><dfn id="proper-table-row-parent-element">proper table-row parent</dfn> box or element
				<dd>
					A <a>table-root</a> or a <a>table-row-grouping</a> box.

				<dt><dfn id="table-internal-element">table-internal</dfn> box or element
				<dd>
					A <a>table-cell</a>, <a>table-track</a> or <a>table-track-grouping</a> box.

				<dt><dfn id="tabular-container">tabular container</dfn>
				<dd>
					A <a>table-row</a> or <a>proper table-row parent</a> box.

				<dt><dfn id="consecutive-boxes">consecutive</dfn> boxes
				<dd>
					Two sibling boxes are consecutive
						if they have no intervening siblings
						other than, optionally, an anonymous inline containing only white spaces.
					A sequence of sibling boxes is consecutive
						if each box in the sequence is consecutive to the one before it in the sequence.
				</dl>

	<!--------------------------------------------------------------------------------->
	<h3 id="fixup">Fixup</h3>

		<p>
			Document languages other than HTML may not contain all the elements in the CSS 2.1 table model.
			In these cases, the "missing" elements must be assumed in order for the table model to work.

		<p>
			Any <a>table-internal</a> element will automatically generate necessary anonymous table objects around itself, if necessary.
			Any non-table descendant of a <a>table-root</a> must have a ancestors consisting of
				at least three nested objects corresponding to
				a <a>table</a>/<a>inline-table</a> element,
				a <a>table-row</a> element, and
				a <a>table-cell</a> element.
			Missing elements cause the generation of anonymous boxes according to the following rules:

		<!--------------------------------------------------------------------------------->
		<h4 id="fixupAlgo">Fixup Algorithm</h4>

			<p>
				For the purposes of these rules, out-of-flow elements are represented as inline elements of zero width and height.
				Their containing blocks are chosen accordingly.

			<p>
				The following steps are performed in three stages:

			<ol>
				<li><b>Remove irrelevant boxes:</b>
					<ol>
						<li>Children of a <a>table-column</a> are treated as if they had <code>display: none</code>.

						<li>Children of a <a>table-column-group</a> which are not a <a>table-column</a> are treated
							as if they had <code>display: none</code>.

						<li>Anonymous inline boxes which contains only white space,
							are the first or last child of a <a>tabular container</a>,
							and whose immediately preceding or following sibling (if any) is a <a>table-non-root</a> element,
							are treated as if they had <code>display: none</code>.

						<li>Anonymous inline boxes which contains only white space and
							are between two immediate siblings each of which is a <a>table-non-root</a> element,
							are treated as if they had <code>display: none</code>.

					</ol>
				</li>
				<li><b>Generate missing child wrappers:</b>
					<ol>
						<li>An anonymous <a>table-row</a> box must be generated
							around each sequence of consecutive children of a <a>table-root</a> box
							which are not <a>proper table child</a> boxes.
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/2/">!!Testcase</a>

						<li>An anonymous <a>table-row</a> box must be generated
							around each sequence of consecutive children of a <a>table-row-grouping</a> box
							which are not <a>table-row</a> boxes.
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/3/">!Testcase</a>

						<li>An anonymous <a>table-cell</a> box must be generated
							around each sequence of consecutive children of a <a>table-row</a> box
							which are not <a>table-cell</a> boxes.
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/4/">!Testcase</a>

					</ol>
				</li>
				<li><b>Generate missing parents:</b>
					<ol>
						<li>An anonymous <a>table-row</a> box must be generated
							around each sequence of consecutive <a>table-cell</a> box
							whose parent is not a <a>table-row</a>.
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/5/">Testcase</a>

						<li>An anonymous <a>table</a> or <a>inline-table</a> box must be generated
							around each sequence of consecutive <a>proper table child</a> box
							which are misparented.
							If the box's parent is an inline box, 
								then an <a>inline-table</a> box must be generated;
								otherwise it must be a <a>table</a> box.
							<ul>
								<li>A <a>table-row</a> is misparented
									if its parent is neither a <a>table-row-grouping</a> nor a <a>table-root</a> box.
								<li>A <a>table-column</a> box is misparented
									if its parent is neither a <a>table-column-group</a> box nor a <a>table-root</a> box.
								<li>A <a>table-row-grouping</a>, <a>table-column-group</a>, or <a>table-caption</a> box is misparented
									if its parent is not a <a>table-root</a> box.
							</ul>
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/7/">Testcase</a>
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/8/">Testcase</a>
							<a class="hint" href="https://jsfiddle.net/hj2w7wwa/9/">!Testcase</a>
					</ol>
				</li>
			</ol>

		<!--------------------------------------------------------------------------------->
		<h4 id="fixup-examples">Examples</h4>

			<div class="example">
				<pre class="lang-markup">
					&lt;div class="row">
						&lt;div class="cell">George&lt;/div>
						&lt;div class="cell">4287&lt;/div>
						&lt;div class="cell">1998&lt;/div>
					&lt;/div>
				</pre>

				<p>Here is the associated styles:</p>
				<pre class="lang-css">
					.row { display: table-row }
					.cell { display: table-cell }
				</pre>

				<p>After fixup, this will produce layout boxes as though this was the initial HTML:</p>
				<pre class="lang-markup">
					&lt;table>
						&lt;tr>
							&lt;td>George&lt;/td>
							&lt;td>4287&lt;/td>
							&lt;td>1998&lt;/td>
						&lt;/tr>
					&lt;/table>
				</pre>
			</div>

			<div class="example">
				<p>In this example, three <a>table-cell</a> elements are assumed to contain the text in the ROWs. The text inside
				of the divs with a <code>display: table-row</code> are encapsulated in anonymous inline boxes, as explained in
				<a href="https://www.w3.org/TR/CSS21/visuren.html#anonymous" target="_blank">visual formatting model</a>:</p>

				<pre class="lang-markup">
					&lt;div class="inline-table">
						&lt;div class="row">This is the top row.&lt;/div>
						&lt;div class="row">This is the middle row.&lt;/div>
						&lt;div class="row">This is the bottom row.&lt;/div>
					&lt;/div>
				</pre>

				<pre class="lang-css">
					.inline-table { display: inline-table; }
					.row { display: table-row; }
				</pre>

				<p>This will produce layout boxes as though this was the initial HTML:</p>
				<pre class="lang-markup">
					&lt;table>
						&lt;tr>
							&lt;td>This is the top row.&lt;/td>
						&lt;/tr>
						&lt;tr>
							&lt;td>This is the middle row.&lt;/td>
						&lt;/tr>
						&lt;tr>
							&lt;td>This is the bottom row.&lt;/td>
						&lt;/tr>
					&lt;/table>
				</pre>
			</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="mapping">Mapping between CSS &amp; HTML attributes</h3>

		<p>
			The default style sheet for HTML4 illustrates how its model maps to css properties and values:

		<div class="note">
			Some extensions to CSS have been used where contraints not mappable to current CSS apply
			</div>

		<pre class="lang-css">

	table    { display: table }
	thead    { display: table-header-group }
	tbody    { display: table-row-group }
	tfoot    { display: table-footer-group }
	tr       { display: table-row }
	td, th   { display: table-cell }
	colgroup { display: table-column-group }
	col      { display: table-column }
	caption  { display: table-caption }
	table, thead, tbody, tfoot, tr, td, th, colgroup, col, caption { box-sizing: border-box; }

<!--
	Non-border built-ins
-->
	table {
		box-sizing: border-box;
		border-spacing: 2px;
		border-collapse: separate;
		text-indent: initial;
	}

	thead, tbody, tfoot, table > tr { vertical-align: middle; }
	tr, td, th { vertical-align: inherit; }

	td, th { padding: 1px; }
	th { font-weight: bold;	}

	table, td, th { border-color: gray; }
	thead, tbody, tfoot, tr { border-color: inherit; }

<!--
	Border built-ins
-->


<!--
	FRAME (part 1/2)
	http://www.w3schools.com/tags/tryit.asp?filename=tryhtml_table_frame
-->
	table[frame=box], table[frame=border], table[frame=hsides], table[frame=above], table[frame=below], table[frame=vsides], table[frame=lhs], table[frame=rhs] {
		border: 1px solid inset;
	}


<!--
	RULES (part 1/3)
	http://codepen.io/FremyCompany/pen/GopJMp
-->
	table:matches([rules=all], [rules=rows], [rules=cols], [rules=groups], [rules=none]) {
		border-collapse: collapse;
		border-style: hidden;
	}

	table:matches([rules=all], [rules=rows], [rules=cols], [rules=groups], [rules=none]),
	table:matches([rules=all], [rules=rows], [rules=cols], [rules=groups], [rules=none]) > :matches(thead,tbody,tfoot) > tr > :matches(th,td) {
		border-color: black;
	}

<!--
	BORDER
	http://codepen.io/FremyCompany/pen/EPVjNp
-->
	table[border=$border] /* if(parseInt($border) > 0) */ {
		border: /*(parseInt($border) * 1px)*/ outset rgb(128, 128, 128);
	}
	table[border=$border] > :matches(thead,tbody,tfoot) > tr > :matches(th,td) /* if(parseInt($border) > 0) */ {
		border: 1px inset rgb(128, 128, 128);
	}

<!--
	RULES (part 2/3)
	http://codepen.io/FremyCompany/pen/GopJMp
-->
	table[rules=all] > :matches(thead,tbody,tfoot) > tr > :matches(th,td) {
		border: 1px solid grey;
	}
	table[rules=rows] > :matches(thead,tbody,tfoot) > tr > :matches(th,td) {
		border: 1px solid grey;
		border-left: none;
		border-right: none;
	}
	table[rules=cols] > :matches(thead,tbody,tfoot) > tr > :matches(th,td) {
		border: 1px solid grey;
		border-top: none;
		border-bottom: none;
	}
	table[rules=none] > :matches(thead,tbody,tfoot) > tr > :matches(th,td) {
		border: none;
	}

<!--
	RULES (part 3/3)
	http://codepen.io/FremyCompany/pen/jWbPXY
	https://jsfiddle.net/ewv08n0r/
-->
	table[rules=groups] > :matches(thead,tbody,tfoot) {
		border-top-width: 1px; border-top-style: solid;
		border-bottom-width: 1px; border-bottom-style: solid;
	}
	table[rules=groups] > colgroup {
		border-left-width: 1px; border-left-style: solid;
		border-right-width: 1px; border-right-style: solid;
	}

<!--
	FRAME (part 2/2)
	http://www.w3schools.com/tags/tryit.asp?filename=tryhtml_table_frame
-->
	table[frame=box], table[frame=border], table[frame=hsides], table[frame=above], table[frame=below], table[frame=vsides], table[frame=lhs], table[frame=rhs] {
		border-style: inset;
	}
	table[frame=below], table[frame=vsides], table[frame=lhs], table[frame=rhs] {
		border-top-style: hidden;
	}
	table[frame=above], table[frame=vsides], table[frame=lhs], table[frame=rhs] {
		border-bottom-style: hidden;
	}
	table[frame=hsides], table[frame=above], table[frame=below], table[frame=rhs] {
		border-left-style: hidden;
	}
	table[frame=hsides], table[frame=above], table[frame=below], table[frame=rhs] {
		border-right-style: hidden;
	}

<!--
	Others:
-->
	table[cellpadding=$x] > :matches(thead,tbody,tfoot) > tr > :matches(th,td) /* if(parseInt($x)>0) */ {
		padding: /*(parseInt($x) * 1px)*/;
	}
	table[cellspacing=$x] /* if(parseInt($x)>0) */ {
		border-spacing: /*(parseInt($x) * 1px)*/;
	}


	table[width=$w] /* if(parseInt($w) > 0) */ {
		width: /*(parseInt($w) * 1px)*/;
	}
	table[width=$w] /* if($w matches /(+|-|)(&#91;0-9&#93;+(&#91;.&#93;&#91;0-9&#93;+|)|(&#91;.&#93;&#91;0-9&#93;+))&#91;%&#93;/) */ {
		width: /*(parseInt($w) * 1px)*/;
	}
	table[height=$h] /* if(parseInt($h) > 0) {
		height: /*(parseInt($h) * 1px)*/;
	}
	table[height=$h] /* if($h matches /(+|-|)(&#91;0-9&#93;+(&#91;.&#93;&#91;0-9&#93;+|)|(&#91;.&#93;&#91;0-9&#93;+))&#91;%&#93;/) */ {
		height: /*(parseInt($h) * 1px)*/;
	}


	table[bgcolor=$color] {
		background-color: /*parseHTMLColor($color)*/;
	}
	table[align=left] {
		float: left;
	}
	table[align=right] {
		float: right;
	}
	table[align=center] {
		margin-left: auto;
		margin-right: auto;
	}

<!--
	NON-TABLE ATTRIBUTES:
-->
	caption[align=bottom i] { caption-side: bottom; }
	:matches(thead,tbody,tfoot,tr,td,th)[valign=top i] {
		vertical-align: top;
	}
	:matches(thead,tbody,tfoot,tr,td,th)[valign=middle i] {
		vertical-align: middle;
	}
	:matches(thead,tbody,tfoot,tr,td,th)[valign=bottom i] {
		vertical-align: bottom;
	}
	:matches(thead,tbody,tfoot,tr,td,th)[valign=bottom i] {
		vertical-align: baseline;
	}

	:matches(thead,tbody,tfoot,tr,td,th)[align=absmiddle i] {
		text-align: center;
	}

	:matches(colgroup,col,thead,tbody,tfoot,tr,td,th)[hidden] {
		visibility: collapse;
	}

	:matches(td,th)[nowrap] { white-space: nowrap; }
	:matches(td,th)[nowrap][width=$w] /* if(quirksMode && parseInt($w) > 0) */ {
		white-space: normal;
	}


</pre>

	<div class="issue">
		We should merge/review the WHATWG spec on
		<a href="https://html.spec.whatwg.org/#tables-2">HTML to CSS mapping of tables</a>.
		They cover a few attributes I didnt't test including nowrap (which has interesting issues).
		They also include <a href="https://jsfiddle.net/8t78exf1/">things which are not true</a> in most browsers.
		Investigations are therefore required for each and any merge being made!
	</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="spanning">Spanning</h3>

		<p style="font-size: italic">
			This section will explain what is spanning
			and how it will affect algorithms later in this spec.

		<p class="issue">
			We should define how spanning works, and define css properties for it.


<!--------------------------------------------------------------------------------->
<h2 id="layout">Layout</h2>

	<!--------------------------------------------------------------------------------->
	<h3 id="layout-principles">Core principles</h3>

		<p>
			Unlike other block elements, tables do not fill their containing block by default.
			By default, the width of a table depends on the width required to fit its columns prefered width.
			The minimum width of a table is the width required to fit all its columns min-width and its undistributable spaces.

		<p>
			If the width assigned to a table is larger than its minimum width,
				the <a href="#width-distribution">Available Width Distribution</a> algorithm
				will adjust column widths in consequence.

		<p>
			This section overrides the general-purpose rules that apply to calculating widths described in other specifications.
			In particular, if the margins of a table are set to <code>0</code> and the width to <code>auto</code>,
				the table will not automatically size to fill its containing block.
			However, once the used value of <code>width</code> for the table is found (using the algorithms given below)
				then the other parts of those rules do apply.
			Therefore, a table can be centered using left and right <code>auto</code> margins, for instance.


	<!--------------------------------------------------------------------------------->
	<h3 id="dimensioning-the-row-column-grid">Dimensioning the row/column grid</h3>

		<p style="font-size: italic">
			This section explains how to decide how many rows and columns a table has.

		<p>
			Like mentioned in the <a href="#table-structure">Table structure</a> section,
			the amount of rows and columns defined in a table can be determined from the
			table structure.

		<div class="note">
			In the following algorithm, "Map $box to a HTML element if needed" means:
			<li>Let $elm be the HTML equivalent tag name of the display type of $box,
				as defined in <a href="#display-types">the display types list</a>:
				<ul class="compact" style="margin:0 !important">
					<li>If $box originates from an HTML $elm element,
						<ul><li>Clone that element and its attributes (but not its descendants) and return it;</ul>
					<li>Else,
						<ul><li>Create a new HTML $elm element with no attribute and return it</ul>
				</ul>
			In both cases, save the relationship between the newly created element and $box.
		</div>

		<p>
			To find out how many columns and rows the row/column grid of a table contains,
			and where each cell element takes place in that grid, the user agent must
			convert the css table to its equivalent html markup, using the following algorithm:

		<ol>
			<li>Map the <a>table-root</a> to a HTML element if needed

			<li>While there is one, and in DOM order, 
				map to a HTML element if needed 
					every child box of the <a>table-root</a>,
				and append those to the &lt;table&gt; element.

			<li>While there is one, and in DOM order, 
				map to a HTML element if needed 
					every non-mapped <a>table-internal</a> box of the <a>table-root</a>
					that is also a child of any already mapped box
				and append those to the element that was mapped to their parent box.
		</ol>

		<a href="https://jsfiddle.net/eqrwaLyc/">Testcase</a>.
		<a href="https://jsfiddle.net/eqrwaLyc/1/">!!Testcase</a>.

		<p class="issue">
			Add new css properties to control rowspan/colspan? Reuse grid ones?

		<p>
			Once this is done, apply the <a href="https://www.w3.org/TR/html5/tabular-data.html#forming-a-table">HTML5 Table Formatting algorithm</a>,
				assign to the <a>table-root</a> element its correct amount of rows and columns (from its mapped element),
				and to each <a>table-cell</a> element its accurate table-row-start/table-column-start/table-row-span/table-column-span (from its mapped element).

		<div class="issue">
			<p>
				To improve our compatibility with actual rendering,
				we may need to specify something along those lines:

			<p>
				"Modify the row/column grid such that
				consecutive tracks spanned by the same set of cells
				are merged into one single track
				for the purpose of computing the layout of the table.
				Change the spanning of the cells contained in those tracks
				accordingly so that no difference is shown." <br/>
				(see <a href="#spanning-ghost-rows">spanning-ghost-rows test cases</a>)

		</div>

		<div class="issue">
			The HTML specification mentions that in some cases, two cells may occupy the same row/column location.
			We need to make sure this specification explains what happens in this case for layout/rendering.
		</div>

		<div class="issue">
			Add simple example
		</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="missing-cells-fixup">Missing cells fixup</h3>

		<p class=note>
			The following section clarifies and extends the CSS 2.1 statement saying that
				missing cells are rendered as if an anonymous table-cell box occupied their position in the grid
				(a "missing cell" is a cell in the row/column grid that is not occupied by an element or pseudo-element).

		<p>
			Once the amount of columns in a table is known, any table-row-group element must be modified such that
				each of its rows contains enough cells to fill all the columns of the table, when taking spanning into account.
			New table-cell pseudo-elements must be appended to its rows content until this condition is met.

		<p>
			Beside their display type, those pseudo-elements do not receive any specific or default styling,
				except where otherwise mentioned by this specification
				(meaning 
					their background is “transparent”, 
					their padding is “0px” and 
					their border is “none” by default).

	<!--------------------------------------------------------------------------------->
	<h3 id="layout-modes">Table layout modes</h3>

		<p>
			This section covers the flags which modify the way tables are being laid out.
			There are three major flags for table layout: 'table-layout', 'border-collapse', and 'caption-side'.

		<!--------------------------------------------------------------------------------->
		<h4 id="table-layout-property">The Table-Layout property</h4>

			<pre class='propdef'>
				Name: table-layout
				Value: normal | fixed
				Initial: separate
				Applies To: table-root elements.
				Inherited: yes
			</pre>

			<p>
				When the 'table-layout' property has <code>fixed</code> as its value,
				the aggregation algorithm for column sizing is not applied,
				and the values determined for the first row of the table are used instead
				(see [[#computing-column-measures]]).

		<!--------------------------------------------------------------------------------->
		<h4 id="border-collapse-property">The Border-Collapse property</h4>

			<pre class='propdef'>
				Name: border-collapse
				Value: separate | collapse
				Initial: normal
				Applies To: table-root elements.
				Inherited: yes
			</pre>

			<p>
				When the 'border-collapse' property has <code>collapse</code> as its value,
				other properties like 'border-spacing' are not applied (see [[#collapsed-style-overrides]]),
				and borders of adjacent cells are merged together such that each cell draws only half of the shared border
				(see [[#border-collapsing]]).

			<p>
				A <a>table-root</a> element is said to be <dfn>rendered <dfn>in collapsed mode</dfn></dfn> in this case.
				Otherwhise, the <a>table-root</a> element is said to be <dfn>rendered <dfn>in separated mode</dfn></dfn>.

		<!--------------------------------------------------------------------------------->
		<h4 id="caption-side-property">The Caption-Side property</h4>

			<pre class='propdef'>
				Name: caption-side
				Value: top | bottom
				Initial: top
				Applies to: <code>table-caption</code> elements
				Inherited: yes
				Media: visual
			</pre>

			<p>
				This property specifies the position of the caption box with respect to the table box.
				Values have the following meanings:

			<dl>
				<dt><dfn id="caption-side-top">top</dfn>
				<dd>
					Positions the caption box above the table box.

				<dt><dfn id="caption-side-bottom">bottom</dfn>
				<dd>
					Positions the caption box below the table box.
			</dl>

			<div class="issue">
				CSS2 described a different width and horizontal alignment behavior.
				That behavior was supposed to be introduced in CSS3 
					using the values <code>top-outside</code> and <code>bottom-outside</code>.
				<a href="http://fantasai.inkedblade.net/style/discuss/captions/">#REF</a>
			</div>

			<div class="issue">
				Gecko also supports the "left" and "right" values. It was never well defined though.
				<a href="http://codepen.io/FremyCompany/pen/YwGPWw">#REF</a>
			</div>

			<div classs="issue">
				Browsers react differently to multiple captions.
				<a href="http://codepen.io/FremyCompany/pen/WrJxwP">!Testcase</a>
			</div>

			<div class="example">
				<p>
					To align caption content horizontally within the caption box, use the 'text-align' property.
				<p>
					In this example, the 'caption-side' property places captions below tables.
					The caption will be as wide as the parent of the table, and caption text will be left-justified.
				<pre>
					caption {
						caption-side: bottom;
		  				width: auto;
		  				text-align: left
					}
				</pre>
			</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="style-overrides">Style overrides</h3>

		<p>
			Some css properties behave differently inside css tables.
			The following sections list the exceptions and their effects.

		<!--------------------------------------------------------------------------------->
		<h4 id="global-style-overrides">Overrides applying in all modes</h4>

			<p>
				The following rules apply to all table elements, irrespective of the layout mode in use:

			<ul>
			<li>The used value of 'display' for <a>table-track</a> and <a>table-track-grouping</a> elements is forced to contents.
				This has the effect of not generating a box for these elements, 
					and making their table-cell children direct layout children of their parent <a>table-root</a> element.

				<li>The used value of 'margin' for <a>table-cell</a> elements is forced to 0px.

				<li>The used value of 'background' longhands for <a>table-cell</a> elements
					is computed using a special background painting algorithm described in [[#drawing-cell-backgrounds]].
			</ul>


		<!--------------------------------------------------------------------------------->
		<h4 id="collapsed-style-overrides">Overrides applying in collapsed-borders mode</h4>

			<p>
				When borders of a table are <a>rendered in collapsed mode</a>, the following rules apply:

			<ul>
				<li>The used value of 'padding' for the <a>table-root</a> element is forced to 0px.

				<li>The used value of 'border-spacing' for the <a>table-root</a> element is forced to 0px.

				<li>The used value of 'border-radius' for <a>table-cell</a> elements
					is forced to 0px for all corners which are not shared with the <a>table-root</a> element.
					For corners shared with the <a>table-root</a> element,
						the used value of the corresponding border-…-radius property is set to
						the used value of the corresponding property on the parent <a>table-root</a> element
						if that value is bigger than the value which would be used otherwise.
					Next, set the used values of the table-root element border radiuses
						to the ones of their corresponding table-cell
						(this will prevent the table radius to grow bigger than the corresponding cell).

				<div class="issue">
					This does not seem to be correct in either case, the cell border radius wins based on
					this <a href="http://codepen.io/gregwhitworth/pen/LGWWZB" target="_blank">test</a>.
					Border-radius only works in IE/Edge and does not work in FF/Chrome.
					<span class="highlight">
						Actually, this isn't even totally true, as box-shadow shows:
						https://jsfiddle.net/wazhrfe3/1/
					</span>
				</div>

				<li>The used value of 'border' longhands for <a>table-root</a> element
						and the <a>table-cell</a> elements it contains are
						computed using a special conflict resolution algorithm described in [[#border-collapsing]].
			</ul>

		<!--------------------------------------------------------------------------------->
		<h4 id="separated-style-overrides">Overrides applying in separated-borders mode</h4>

			<p>
				When borders of a table are <a>rendered in separated mode</a>, the following rules apply:

			<ul>
				<li>(none, for now)
			</ul>

			<div class="note">
				The following special CSS2.1 rules have now been incorporated in others, more general rules.
				<details>
					<summary>...</summary>
					<ul>
						<li>Each cell has an individual border. <br/>
							<br/>
							<span class="advisement">This is a css default</span><br/>
							<br/>
						<li>The 'border-spacing' property specifies the distance between the borders of adjoining cells.<br/>
							<br/>
							<span class="advisement">See [[#layout-algorithm]].</span><br/>
							<br/>
						<li>In this space, the row, column, row group, and column group backgrounds are invisible,
								allowing the table background to show through.<br/>
							<br/>
							<span class="advisement">They don't have any box at all now;</span><br/>
							<span class="advisement">See [[#global-style-overrides]].</span><br/>
							<br/>
							<span class="advisement">Their backgrounds are propagated to the cells;</span><br/>
							<span class="advisement">See [[#rendering]]</span><br/>
							<br/>
						<li>Rows, columns, row groups, and column groups cannot have borders
								(i.e., user agents must ignore the border properties for those elements).<br/>
							<br/>
							<span class="advisement">They don't have any box at all now;</span><br/>
							<span class="advisement">See [[#global-style-overrides]].</span><br/>
							<br/>
					</ul>
				</details>
				<style>
					details {
						display: block;
					}
					details:not([open]):not(:hover) > ul {
						display: none;
					}
					details[open]:not(:hover) > ul {
						display: block;
					}
				</style>
			</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="border-collapsing">Border-collapsing</h3>

		<p>
			This section explains what is border-collapsing,
			and how to apply it on a table.

		<div class="issue">
			<p>
				This entire section is a proposal to make the rendering of collapsed borders sane.
				As implementations diverge very visibly, it is expected to require more discussion than some other parts.
				Since browsers handle this so differently, convergence cannot happen without reimplementation.
				A major concern for this proposal was to support as many cases as possible, and yet
					keep the effort required for a new implementation of tables as low as possible.

			<p>
				<b>Background:</b>
				CSS+HTML allow unprecedented combinations of border modes for table junctions,
					and it makes it difficult to support all cases properly;
					in fact some combinations are not <a href="https://en.wikipedia.org/wiki/Well-posed_problem">well-posed problems</a>,
					so no rendering algorithm could be optimal.
			<p>
				Because they grew from something simple (HTML) to something very complex (HTML+CSS),
					the current table rendering models (backgrounds and borders) used by web browsers are insane
					(in the sense they are buggy, not interoperable and not CSSish at all).
				Many usual CSS assumptions are broken, and renderings diverge widely.

			<p>
				This proposal aims at fixing this situation.

		</div>

		<div class="issue">
			<strong>This proposal does not respect these stated requirements:</strong><br/>
			UAs must compute an initial left and right border width for the table
				by examining the first and last cells in the first row of the table.
			The left border width of the table is half of the first cell's collapsed left border,
				and the right border width of the table is half of the last cell's collapsed right border.
			If subsequent rows have larger collapsed left and right borders,
				then any excess spills into the margin area of the table.
		</div>

		<div class="issue">
			This proposal is doing worse than Edge and Firefox (but better than Chrome) when
				row- or colspanned cells have border styles which conflict with their neighbors,
				and those neighbors have different styles which conflict with each other.
			This is a necessary trade-of to make the model sane.
		</div>

		<!--------------------------------------------------------------------------------->
		<h4 id="conflict-resolution-for-collapsed-borders">Conflict Resolution for Collapsed Borders</h4>

		<p>
			When they are rendered <a>in collapsed mode</a>,
				<a>table-root</a> and <a>table-cell</a> elements sharing a border attempt to unify their borders
				so that they render using the same style, width, and color (whenever this is possible).
			This is accomplished by running the following algorithm.

		<!--------------------------------------------------------------------------------->
		<h5 id="border-conflict-resolution-algorithm">Conflict Resolution Algorithm for Collapsed Borders</h5>
		<div class="note">
			For the purpose of this algorithm, &#8220;harmonizing&#8221; a set of borders means
				applying the <a href="#border-style-harmonization-algorithm">&#8220;Harmonization Algorithm for Collapsed Borders&#8221;</a> on the given set of borders, and 
				set those borders' used values to the value resulting from the algorithm,
				except for cells having a 'border-image-source' different from none:
				those keep their initial values.
		</div>

		<p><b>For any <a>table-cell</a> element C° of a <a>table-root</a> element:</b>

		<ul>
			<li>Resolve conflicts with border-right:
			<ul>
				<li>Let C be an ordered set of <a>table-cell</a> element borders, sorted in Row/Column order of their parent cell;
					initially, let C contain only C°&#8217;s border-right

				<li>Add to the set C the border-left of all cells located after C°
					sharing a section of their border-left with C°&#8217;s border-right

				<li>Repeat the following two instructions, until no new cell is added to C:
				<ul>
					<li>For all newly-added cells C<sub>i</sub> having a rowspan greater than one,
						add to the set C the border-right of all cells located before C<sub>i</sub>
						sharing a section of their border-right with C<sub>i</sub>&#8217;s border-left

					<li>For all newly-added cells C<sub>i</sub> having a rowspan greater than one,
						add to the set C the border-left of all cells located after C<sub>i</sub>
						sharing a section of their border-left with C<sub>i</sub>&#8217;s border-right
				</ul>

				<li>Harmonize the conflicting borders of C
			</ul>

			<li>Resolve conflicts with border-bottom:
			<ul>
				<li>Let C be an ordered set of <a>table-cell</a> element borders, sorted in Row/Column order of their parent cell;
					initially, let C contain only C°&#8217;s border-bottom

				<li>Add to the set C the border-top of all cells located after C°
					sharing a section of their border-top with C°&#8217;s border-bottom

				<li>Repeat the following two instructions, until no new cell is added to C:
				<ul>
					<li>For all newly-added cells C<sub>i</sub> having a colspan greater than one,
						add to the set C the border-bottom of all cells located before C<sub>i</sub>
						sharing a section of their border-bottom with C<sub>i</sub>&#8217;s border-top

					<li>For all newly-added cells C<sub>i</sub> having a colspan greater than one,
						add to the set C the border-top of all cells located after C<sub>i</sub>
						sharing a section of their border-top with C<sub>i</sub>&#8217;s border-bottom
				</ul>

				<li>Harmonize the conflicting borders of C
			</ul>

			<li>Divide the used width of all borders by two.<br>
				<div class="note">
					This effect will be compensated at rendering time wherever needed,
					but is required for layout correctness.
					<span class="hint">(see [[#drawing-collapsed-borders]])</span>
				</div>
		</ul>
		
		<p>
			<b>Then, for that <a>table-root</a> element:</b>
		</p>

		<ul>
			<li>Harmonize the <a>table-root</a> element border-{top,bottom,left,right}
					with the corresponding border of all cells forming the border of the table (indenpendently),
					without actually modifying the border properties of the <a>table-root</a> element.<br>
				<br>
				If the table and the cell border styles have the same specificity, 
					keep the cell border style.
				<br>
				Once this is done, set the <a>table-root</a> element border-{&#8230;}-width
					to half the maximum width found during the harmonization processes for that border,
					then set border-{&#8230;}-style to solid, and border-{&#8230;}-color to transparent.
		</ul>

		<!--------------------------------------------------------------------------------->
		<div class="note">
			Implementations may of course choose to skip some of the steps of the previous algorithm,
			provided they can prove those have no visible impact on the final results;
			certain borders are harmonized more than once using the previous steps which is completely unnecessary,
			but preventing this would make the spec harder to read.
		</div>

		<div class="example">
			To help the reader get a better idea of what this algorithm is doing,
			the main steps of applying the previous algorithm over a sample table have been outlined here:
			<br/>
			<br/>
			<a href="https://jsfiddle.net/bn3d1sm4/">https://jsfiddle.net/bn3d1sm4/</a><br/>
			<a href="https://jsfiddle.net/bn3d1sm4/1/">https://jsfiddle.net/bn3d1sm4/1/</a><br/>
			<a href="https://jsfiddle.net/bn3d1sm4/2/">https://jsfiddle.net/bn3d1sm4/2/</a><br/>
			&#8230;<br/>
			<a href="https://jsfiddle.net/bn3d1sm4/15/">https://jsfiddle.net/bn3d1sm4/15/</a><br/>
		</div>

		<!--------------------------------------------------------------------------------->
		<h5 id="border-style-harmonization-algorithm">Harmonization Algorithm for Collapsed Borders</h5>
		<div class="note">
			For the purpose of this algorithm, &#8220;considering&#8221; a border&#8217;s properties means
			that &#8220;if its properties are <a href="border-specificity">more specific</a> than CurrentlyWinningBorderProperties,
			set CurrentlyWinningBorderProperties to its properties&#8221;.
		</div>
		
		<div class="issue">
			There is an outstanding proposal from Fantasai to 
				change the "more specific than" part of these rules 
				to "as specific or more than". 
			This would change the priority order 
				from
					cell, track, track-group, table
				to
					table, track-group, track, cell.
			
		</div>

		<p>
			Given an ordered set of borders (BC<sub>1,</sub> BC<sub>2</sub>, &#8230; located in cells C<sub>1,</sub> C<sub>2</sub>, &#8230;)
			execute the following algorithm to determine the used value of the border properties for those conflicting borders.

		<ul>
			<li>
				Set CurrentlyWinningBorderProperties to &#8220;border: 0px none transparent&#8221;

			<li>
				For each border BC<sub>i</sub>:
				<ul>
					<li>Consider the BC<sub>i</sub> border&#8217;s properties
				</ul>

			<li>
				If the border separates two columns:
				<ul>
					<li>For each border BC<sub>i</sub>:
						Find the table-column element in which the C<sub>i</sub> cell is located, if any.
						If the BC<sub>i</sub> border is such that 
							there is a border of the table-column element that would be drawn contiguously to it, 
							consider its border&#8217;s properties.

					<li>For each border BC<sub>i</sub>:
						Find the table-column-group element in which the C<sub>i</sub> cell is located, if any.
						If the BC<sub>i</sub> border is such that 
							there is a border of the table-column-group element that would be drawn contiguously to it, 
							consider its border&#8217;s properties.
				</ul>

			<li>
				If the border separates two rows:
				<ul>
					<li>For each border BC<sub>i</sub>:
						Find the table-row element in which the C<sub>i</sub> cell is located, if any.
						If the BC<sub>i</sub> border is such that 
							there is a border of the table-row element that would be drawn contiguously to it,
							consider its border&#8217;s properties.

					<li>For each border BC<sub>i</sub>:
						Find the table-row-group element in which the C<sub>i</sub> cell is located, if any.
						If the BC<sub>i</sub> border is such that 
							there is a border of the table-row-group element that would be drawn contiguously to it,
							consider its border&#8217;s properties.
				</ul>

			<li>
				Return CurrentlyWinningBorderProperties
		</ul>

		<!--------------------------------------------------------------------------------->
		<h5 id="border-specificity">Specificity of a border style</h5>

		<p>
			Given two borders styles, the border style having the most specificity is the border style which&#8230;

		<ol>
			<li>&#8230; has hidden as 'border-style', if only one does
			<li>&#8230; has the biggest 'border-width', once converted into css pixels
			<li>&#8230; has the 'border-style' who comes first in the following list:
				<span>double, solid, dashed, dotted, ridge, outset, groove, inset, none</span>
			</ol>

		<p>
			If none of these criterion matches, then both borders share the same specificity.

	<!--------------------------------------------------------------------------------->
	<h3 id="content-measure">Computing table measures</h3>

		<!--------------------------------------------------------------------------------->
		<h4 id="computing-undistributable-space">Computing Undistributable Space</h3>

			<p>
				This section will deal with the border spacings of the separated border mode.

			<pre class='propdef'>
				Name: border-spacing
				Value: <​length​> <​length​>?
				Initial: 0px 0px
				Applies To: table-root elements when 'border-collapse' is <code>separate</code>.
				Inherited: yes
				Computed Value: two absolute lengths
				Media: visual
				Animatable: yes
			</pre>

			<p>
				The lengths specify the distance that separates adjoining cell borders.

			<p>
				If one length is specified, it gives both the horizontal and vertical spacing.
				If two are specified, the first gives the horizontal spacing and the second the vertical spacing.

			<p>
				Lengths may not be negative.

			<p>
				The distance between 
					the table border and 
					the borders of the cells on the edge of the table
				is 
					the table's padding for that side, 
					plus the relevant border spacing distance.

			<div class="example">
				For example, on the right hand side, the distance is padding-right + horizontal border-spacing.
			</div>

			<div class="issue">
				The width of the table is the distance 
					from the left inner padding edge
					to the right inner padding edge (including the border spacing but excluding padding and border).
				However, in HTML and XHTML1, the width of the &lt;table&gt; element is the distance
					from the left border edge to the right border edge.
				<b>
					Note: In CSS3 this peculiar requirement will be defined in terms of UA style sheet rules and the 'box-sizing' property.
				</b>
			</div>

		<!--------------------------------------------------------------------------------->
		<h4 id="computing-cell-measures">Computing Cell Measures</h3>

			<p style="font-style: italic">
				This section will deal with the measurement of a cell.

			<p>
				The following terms are parameters of tables or table cells.
				These parameters encapsulate the differences
					between tables with different values of 'border-collapse' (separate or collapse)
					so that the remaining subsections of this section do not need to refer to them differently.

			<dl>
				<!--------------------------------------------------------------------------------->
				<dt><dfn>cell intrinsic offsets</dfn></dt>
				<dd>The cell intrinsic offsets is a term to capture the parts of padding and border of a table cell
						that are relevant to intrinsic width calculation.
					It is a set of computed values for border-left-width, padding-left, padding-right, and border-right-width
						(along with zero values for margin-left and margin-right)
						defined as follows:
					<ul>
						<li><a>In separated mode</a>: the computed horizontal padding and border of the table-cell
						<li><a>In collapsed mode</a>: the computed horizontal padding of the cell and, for border values,
							the used border-width values of the cell (half the winning border-width)
					</ul>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>table intrinsic offsets</dfn></dt>
				<dd>The table intrinsic offsets is a term to capture the parts of the padding and border of a table
						that are relevant to intrinsic width calculation.
					It is a set of computed values for border-left-width, padding-left, padding-right, and border-right-width
						(along with zero values for margin-left and margin-right)
						defined as follows:
					<ul>
						<li><a>In separated mode</a>: the computed horizontal padding and border of the table-root
						<li><a>In collapsed mode</a>: the used border-width values of the cell (half the winning border-width)
							<div class="issue">
								Is this the correct way to account for the various changes 
								that have gone into CSS2.1 
								regarding which border sticks out into the margin?
							</div>
					</ul>

					<p class="note">
						The margins are not included in the table intrinsic offsets
							because handling of margins depends on the 'caption-side' property.
					<div class="issue">But doesn't that break handling of percentage padding?
						<a class="hint" href="https://jsfiddle.net/j5dbco4m/">
							I don't think so because they are resolved based on parent anyway
						</a>
					</div>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>total horizontal border spacing</dfn></dt>
				<dd>The total horizontal border spacing is defined for each table:
					<ul>
						<li>For tables <a>rendered in separated mode</a> containing at least one column,
							the horizontal component of the computed value of the border-spacing property times one plus
							the number of columns in the table <span class="highligth">in which cells originate</span>
							<div class="issue">
								Isn't <span class="highligth">that</span> better solved by the proposal
								to fix the row-grid in [[#dimensioning-the-row-column-grid]]?
							</div>
						<li>Otherwise, 0
					</ul>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>outer min-content</dfn> and <dfn>outer max-content</dfn> widths</dt>
				<dd>The outer min-content and max-content widths are defined for table cells, columns, and column groups.
					The 'width', 'min-width', and 'max-width' values used in these definitions are those defined <a href="#TODO">above</a>:
					<ul>
						<li>The <b>outer min-content width</b> of a table cell is
								<code>max('min-width', min('max-width', min-content width))</code>
								adjusted by the cell intrinsic offsets.
							<div class="issue">
								Should 'max-width' really be able to override the min-content width?
								An alternative expression is <code>max('min-width', min-content width)</code>
								@ FR: I think we should choose this option.
							</div>
							<div class="issue">
								Should 'min-width' affect outer min-content widths at all?
								@ FR: I think it should, yes. That's interoperable.
							</div>

						<li>The <b>outer min-content width</b> of a table column or column group is
							<code>'min-width'</code>.
							<div class="issue">
								Should 'min-width' affect outer min-content widths at all?
							</div>

						<li>The <b>outer max-content width</b> of a table cell in a non-constrained column is
								<code>max('min-width', min('max-width', max-content width))</code>
								adjusted by the cell intrinsic offsets.
							<div class="issue">
								Should 'max-width' be able to override the intrinsic min-content width?
								An alternative expression is <code>max('min-width', min-content width, min('max-width', max-content width)</code>.
							</div>

						<li>The <b>outer max-content width</b> of a table cell in a constrained column is
								<code>max('min-width', min('max-width', max('width', min-content width)))</code>
								adjusted by the cell intrinsic offsets.
							<div class="issue">
								Should 'max-width' be able to override the min-content width?
								An alternative expression is <code>max('min-width', min-content width, min('max-width', 'width'))</code>.
							</div>

						<li>The <b>outer max-content width</b> of a table column or column group is
								<code>max('min-width', min('max-width', 'width'))</code>.
					</ul>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>percentage contribution</dfn>s</dt>
				<dd>The percentage contribution of a table cell, column, or column group
						is defined in terms of the computed values of 'width', 'max-width', and 'min-width'
						that have computed values that are percentages:<br/>
					<br/>
					<code>max(percentage 'min-width', min(percentage 'width', percentage 'max-width'))</code>.<br/>
					<br/>
					If the computed values are not percentages, 
						then <code>0%</code> is used for 'width' or 'min-width',and 
						an <code>infinite</code> percentage is used for 'max-width'.

			</dl>

			<div class="issue">
				These definitions need to account for the 'box-sizing' property.
			</div>


		<!--------------------------------------------------------------------------------->
		<h4 id="computing-column-measures">Computing Column Measures</h3>

			<p style="font-style: italic">
				This section will deal with the measurement of a column.

			<p class="issue">
				We mention earlier that fixed tables use a different algorithm for columns aggregation.
				We need to define it.

			<p>
				This subsection defines terms for various parameters associated with each column of a table.
				These parameters are used in the following two subsections as part of
					the rules for computing intrinsic widths of tables and
					computing the column widths of a table.

			<div class="note">
				The spanning and non-spanning intrinsic widths are intermediate values
					that are used only within this section.
				The rationale for having these separate definitions of spanning and non-spanning widths
					is to make the layout of tables invariant under reordering of the rows.
				This invariant is maintained by most, but not all, current Web browser implementations.
				<br/>
				<br/>
				<center><span class="issue">Rewrite!</span><br/></center>
				<br/>
				</div>

			<p class="issue">
				This needs to account for character-alignment of cells ('<<string>>' values of the 'text-align' property).
				This requires (based on the 9 March 2011 editor's draft of css3-text) separately tracking max-content widths
					for the part of the column before the center of the alignment string and
					the part of the column after the center of the alignment string.
				For tracking min-content widths, there are two options:
					either not track them, or track three values:
					two values as for max-content widths for any cells that do not have break points in them,
					and a fourth value for any cells that do have break points in them
					(and to which character alignment is therefore not mandatory).

			<p class="issue">
				The handling of the 'max-width' property with this algorithm is very poor.
				It ought to have an effect stronger
					than the one it has on the outer intrinsic widths of the element on which it is specified.
				It probably ought to be a separate parameter of the column
					(though how it interacts with the min-content width would need to be defined).

			<p class="issue">
				The way this describes distribution of widths from column-spanning cells is wrong.
				For min-content and max-content widths it should refer to the rules
					for distributing excess width to columns for intrinsic width calculation.
				For percentages
					it needs to ensure that it doesn't distribute widths to columns
					that do not have originating cells.

			<dl>
				<!--------------------------------------------------------------------------------->
				<dt><dfn>intermediate min-content width for span 1</dfn></dt>
				<dd>The largest of:
					<ul>
						<li>the outer min-content width of the column group, if any
						<li>the outer min-content width of the column, if any
						<li>the outer min-content width of each cell in the column whose 'column-span' property has a computed value of 1
					</ul>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>intermediate max-content width for span 1</dfn></dt>
				<dd>The largest of:
					<ul>
						<li>the outer max-content width of the column group, if any
						<li>the outer max-content width of the column, if any
						<li>the outer max-content width of each cell in the column whose 'column-span' property has a computed value of 1
					</ul>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>intermediate intrinsic percentage width for span 1</dfn></dt>
				<dd>The largest of the percentage contributions of
						each cell in the column whose 'column-span' property has a computed value of 1,
						of the column (if any), and
						of the column group (if any)

				<!--------------------------------------------------------------------------------->
				<dt><dfn>intermediate min-content width for span N (N > 1)</dfn></dt>
				<dd>the largest of the intermediate min-content width for span N-1 and the contributions
						of the cells in the column whose 'column-span' property has computed value N,
						where the contribution of a cell is the result of taking the following steps:
					<ol>
						<li>Define the baseline (min-content / max-content) width
							as the sum of the intermediate (min-content / max-content) widths
							for span N-1 of all columns that the cell spans.

						<li>Define the baseline border spacing as the sum of the and the horizontal
							border-spacing for any columns spanned by the cell,
							other than the one in which the cell originates,
							in which cells originate.

						<li>The contribution of the cell is the sum of:
							<ul>
								<li>the min-content width of the column for span N-1
								<li>the product of:
									<ul>
										<li>the ratio of:
											<ul>
												<li>the intermediate max-content width for span N-1 of the column
													minus the intermediate min-content width for span N-1 of the column, to
												<li>the baseline max-content width minus the baseline min-content width
											</ul>
											or zero if this ratio is undefined, and

										<li>the outer min-content width of the cell
											minus the baseline min-content width and the baseline border spacing,
											clamped to be at least 0 and at most the difference
											between the baseline max-content width and the baseline min-content width
									</ul>
								<li>the product of:
									<ul>
										<li>the ratio of the intermediate max-content width
											for span N-1 of the column to the baseline max-content width
										<li>the outer min-content width of the cell
											minus the baseline max-content width and baseline border spacing,
											or 0 if this is negative
									</ul>
							</ul>
					</ol>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>intermediate max-content width for span N (N > 1)</dfn></dt>
				<dd>The largest of the intermediate max-content width
					for span N-1 and the contributions of the cells in the column whose 'column-span' property has computed value N,
					where the contribution of a cell is the result of taking the following steps:
					<ol>
						<li>Define the baseline max-content width as
							the sum of the intermediate max-content widths
							for span N-1 of all columns that the cell spans.

						<li>Define the baseline border spacing as
							the sum of the and the horizontal border-spacing
							for any columns spanned by the cell,
							other than the one in which the cell originates,
							in which cells originate.

						<li>The contribution of the cell is the sum of:
							<ul>
								<li>the max-content width of the column for span N-1
								<li>the product of:
									<ul>
										<li>the ratio of the intermediate max-content width
											for span N-1 of the column to the baseline max-content width
										<li>the outer max-content width of the cell
											minus the baseline max-content width and the baseline border spacing,
											or 0 if this is negative
									</ul>
							</ul>
					</ol>


				<!--------------------------------------------------------------------------------->
				<dt><dfn>intermediate intrinsic percentage width for span N (N > 1)</dfn></dt>
				<dd>If the intermediate intrinsic percentage width for span N-1 is greater than 0%,
					then the intermediate intrinsic percentage width for span N is
					the same as the intermediate intrinsic percentage width for span N-1.<br/>
					<br/>
					Otherwise, it is the largest of the contributions of the cells in the column
					whose 'column-span' property has computed value N,
					where the contribution of a cell is the result of taking the following steps:
					<ol>
						<li>Start with the percentage contribution of the cell.
						<li>Subtract the intermediate intrinsic percentage width for span N-1 of all columns that the cell spans.
							If this gives a negative result, change it to 0%.
						<li>Multiply by the ratio of
							<ul>
								<li>the column's non-spanning max-content width to
								<li>the sum of the non-spanning max-content widths of all columns spanned by the cell
									that have an intermediate intrinsic percentage width for span N-1 equal to 0%.
							</ul>
							However, if this ratio is undefined because the denominator is zero,
							instead use the 1 divided by the number of columns spanned by the cell
							that have an intermediate intrinsic percentage width for span N-1 equal to zero.
					</ol>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>min-content width</dfn></dt>
				<dd>the intermediate min-content width for span N, where N is the number of columns in the table

				<!--------------------------------------------------------------------------------->
				<dt><dfn>max-content width</dfn></dt>
				<dd>the intermediate max-content width for span N, where N is the number of columns in the table

				<!--------------------------------------------------------------------------------->
				<dt><dfn>intrinsic percentage width</dfn></dt>
				<dd>the smaller of:
					<ul>
						<li>intermediate intrinsic percentage width for span N,
							where N is the number of columns in the table
						<li>100% minus the sum of the intrinsic percentage width of all prior columns in the table
							(further left (right) when direction is "ltr" ("rtl"))
					</ul>
					<p class="note">
						The clamping of the total of the intrinsic percentage widths of columns to a maximum of 100%
						means that the table layout algorithm is not invariant under switching of columns.
					</p>

				<!--------------------------------------------------------------------------------->
				<dt><dfn>constrainedness</dfn></dt>
				<dd>A column is constrained if
						the column group (if any),
						the column (if any),
						or any of the non-column-spanning cells in the column
					has a computed 'width' that is not "auto",
						and is not a percentage.

					<div class="issue">
						Do we need intermediate constrainedness?
						It's easier to implement that way, but does it actually make any difference?
					</div>

			</dl>

			<div class="issue">
				Is 0% really treated like 0 rather than like a percentage value?
				(e.g., if it's the only non-spanning percentage in a column that has a spanning cell with a percentage width?)
			</div>

		<!--------------------------------------------------------------------------------->
		<h4 id="computing-the-table-width">Computing the table width</h3>

			<p>
				This section will deal with the measurement of a table (width).

			<p class="issue">
				We need to choose how captions affect the sizing of a table (see Alernatives)

			<p class="advisement">
				<b>Alternative I</b>:<br/>
				This is what was specced in CSS 2.1.<br/>
			<div class="hint" style="font-size: 50%">
				Only Chrome implemented this alternative.
				<a href="http://codepen.io/anon/pen/vLXEON">Test case</a>
			</div>

			<p>
				The <dfn id="CAPMIN">caption width minimum (CAPMIN)</dfn> is determined by calculating for each caption
					the minimum caption outer width as the MCW of a hypothetical table cell that contains the caption formatted as "display: block".
				The greatest of the minimum caption outer widths is CAPMIN.
				
			<p>
				The <dfn id="MIN">MIN</dfn> width is 
					the minimum width required by all the columns 
					plus cell spacing or borders.

			<p>
				Column and caption widths influence the final table width as follows:

			<ul>
				<li>If the <a>table-root</a> element's 'width' property has a computed value (W) other than <code>auto</code>,
						the used width is the greater of
							W, 
							CAPMIN, and 
							MIN.
					If the used width is greater than MIN, 
						the extra width should be distributed over the columns.
					<span class=hint>See [[#width-distribution]].</span>

				<li>If the <a>table-root</a> element has 'width: auto',
						the used width is the greater of 
							the table's containing block width, 
							CAPMIN, and 
							MIN.
					However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX)
						is less than that of the containing block, use max(MAX, CAPMIN) instead.
			</ul>

			<div class="note">
				In this algorithm, rows (and row groups) and columns (and column groups) both constrain
				and are constrained by the dimensions of the cells they contain.
				Setting the width of a column may indirectly influence the height of a row, and vice versa.
			</div>

			<p class="advisement">
				<b>Alternative II</b>:<br/>
				This is what was specced by David Baron.

			<div class="hint" style="font-size: 50%">
				Gecko and Edge implemented this alternative.
				<a href="http://codepen.io/anon/pen/vLXEON">Test case</a><br/>
				Gecko also supports vertical-mode-captions; Edge is buggy.
				<a href="http://codepen.io/FremyCompany/pen/YwGPWw">Test case</a>
			</div>

			<p class="note">
				This specification currently defines 
					the intrinsic widths of tables (including inline-tables)
						as a parameter of the table excluding its caption, but 
					the outer intrinsic widths of tables
						as a parameter of the table including its caption.
				This distinction is needed because the intrinsic widths exclusive of the caption are critical to the final table layout algorithm.
				However, it may be better to have a separate term for these parameters
					rather than overloading these existing terms by adding this strange distinction.

			<p>
				The <b>min-content width of a table-root</b> is the sum of
					the min-content widths of the columns and
					the total horizontal border spacing of the table.

			<p>
				The <b>max-content width of a table-root</b> is the sum of
					the total horizontal border spacing of the table
					and the largest of:
				<ul>
					<li>the sum of the max-content widths of the columns
					<li>the small percentage contribution of each of the columns,
						where the small percentage contribution of a column is defined as the ratio of
						<ol>
							<li>the column's max-content width to
							<li>its intrinsic percentage width (where 100% == 1.0)
						</ol>
						<div class="note">
							This ensures that cells, columns, or column groups with small percentage widths
							have those percentage widths satisfied when possible.
						</div>
					<li>the large percentage contribution of the table, which is the ratio of
						<ol>
							<li>the sum of the max-content widths of all the columns
								whose intrinsic percentage width is zero to
							<li>100% (1.0) minus the sum of the intrinsic percentage widths of the columns,
						</ol>
						unless the denominator of that ratio is 0,
						in which case it is 0 if the numerator is also 0,
						and an infinitely large number if the numerator is nonzero
						<div class="note">
							This ensures that cells, columns, or column groups with large percentage widths
							have those percentage widths satisfied when possible.
						</div>
						<div class="issue">
							It would be nice to prove that there's no need to iterate over the columns separately.
							I think this is true because in such cases the small percentage effect would win.
						</div>
				</ul>

			<p>
				The <b>outer min-content width of the non-caption part of a <a>table-root</a></b> is defined to be
				<code>max('min-width', the min-content width of the table, min('width', 'max-width'))</code>
				adjusted by the table intrinsic offset.

			<p>
				The <b>outer min-content width of a <a>table-root</a></b> is defined to be the larger of:
				<ul>
					<li>the outer min-content width of the caption
					<li>the sum of the outer min-content width of the non-caption part of the table and
						the margin values used to compute the outer max-content/min-content width
						<div class="issue">margin values aren't used that way anymore</div>
				</ul>

			<p>
				The <b>outer max-content width of the non-caption part of a <a>table-root</a></b> is defined to be
				<code>max('min-width', min-content, min('width', 'max-width', max-content))</code>
				adjusted by the table intrinsic offset.

			<p>
				The <b>outer max-content width of a <a>table-root</a></b> is defined to be the larger of:
				<ul>
					<li>the outer max-content width of the caption
					<li>the sum of the outer max-content width of the non-caption part of the table and
						the margin values used to compute the outer max-content/min-content width
						<div class="issue">margin values aren't used that way anymore</div>
						<div class="issue">this algorithm needs to account for percentage margin and padding correctly</div>
				</ul>

		<!--------------------------------------------------------------------------------->
		<h4 id="computing-the-table-height">Computing the table height</h3>

			<p>
				This section will deal with the measurement of a table (height).

			<div class="issue">
				TODO, but this is probably done after width distribution.
			</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="width-distribution">Available Width Distribution</h3>

		<!--------------------------------------------------------------------------------->
		<h4 id="width-distribution-principles">Core principles</h3>

			<p style="font-style: italic">
				This section is not normative.

			<p class="issue">
				This section should get an editorial review to
					use the same terms as the other sections.

			<h5 id="width-distribution-principles-rN">Rules</h5>

			<p>
				Ideally, each column should get its preferred width.
				However, tableUsedWidth may not be big enough or small enough for the satisfactory result.

			<p>
				We follow three rules here when determining column used width (columnUsedWidth):

			<p id="width-distribution-principles-r1">
				<b>Rule 1: </b>
				<span>
					When assigning preferred widths, specified percent columns
					have a higher priority than specified unit value columns,
					which have a higher priority than auto columns.
				</span>

			<p id="width-distribution-principles-r2">
				<b>Rule 2: </b>
				<span>
					Columns in the same category follow the same distribution method.
					For example, they all get columnMinWidth or they all get columnPreferredWidth, etc.
					<br/>
					<span class="note" style="display: block; margin-top: 0.5em">
						There is one exception to this rule.
						When applying columnPreferredPercent on a percent column,
							the computed unit value may be smaller than columnMinWidth.
						In this case, the column will be assigned its columnMinWidth
							though the percent column group as a whole is still regarded
							as being assigned the columnPreferredWidth.
					</span>
				</span>

			<p id="width-distribution-principles-r3">
				<b>Rule 3: </b>
				<span>
					The sum of columnUsedWidth should be equal to tableUsedWidth.
				</span>

			<style>
				#width-distribution-principles-r1,
				#width-distribution-principles-r2,
				#width-distribution-principles-r3 {
					display: flex;
				}

				#width-distribution-principles-r1 > :first-child,
				#width-distribution-principles-r2 > :first-child,
				#width-distribution-principles-r3 > :first-child {
					flex-shrink: 0; flex-basis: 5em;
				}

				#width-distribution-principles-r1 > *,
				#width-distribution-principles-r2 > *,
				#width-distribution-principles-r3 > * {
					display: inline-block;
				}
			</style>

			<h5 id="width-distribution-principles-rR">Available sizings</h5>

			<p>
				All three types of columns have the following possible used widths.
				<ol>
					<li>columnMinWidth
					<li>columnMinWidth + delta: <br/>
						<span class="hint">A value between columnMinWidth and columnPreferredWidth-or-columnPreferredPercent</span>
					<li>columnPreferredWidth <span class="hint">(for auto and specified unit columns)</span> or <br/>
						columnPreferredPercent <span class="hint">(for specified percent columns)</span>
					<li>columnPreferredWidth-or-columnPreferredPercent + delta<br/>
						<span class="hint">A value larger than columnPreferredWidth-or-columnPreferredPercent</span>

		<!--------------------------------------------------------------------------------->
		<h4 id="width-distribution-algorithm">Distribution algorithm</h3>

			<p>
				When a table is laid out at a given used width,
					the used width of each column must be determined as follows.

			<p class="note">
				For the purpose of this algorithm, we clarifty that
				the <dfn>assignable table width</dfn> is
					the used width of the table
					minus the total horizontal border spacing.

			<ol>
				<li>Define the <dfn>min-content guess</dfn> as the set of column width assignments
					where each column is assigned its min-content width.

				<li>Define the <dfn>min-content-percentage guess</dfn>
					as the set of column width assignments where:
					<ul>
						<li>each column with an intrinsic percentage width greater than 0%
							is assigned the larger of:
							<ul>
								<li>its intrinsic percentage width times the assignable width and
								<li>its min-content width.
							</ul>

						<li>all other columns are assigned their min-content width.
					</ul>

				<li>Define the <dfn>min-content-specified guess</dfn>
					as the set of column width assignments where:
					<ul>
						<li>each column with an intrinsic percentage width greater than 0%
							is assigned the larger of:
							<ul>
								<li>its intrinsic percentage width times the assignable width and
								<li>its min-content width, and
							</ul>

						<li>any other column that is constrained
							is assigned its max-content width, and

						<li>all other columns are assigned their min-content width.
					</ul>

				<li>Define the <dfn>max-content guess</dfn>
					as the set of column width assignments where:
					<ul>
						<li>each column with an intrinsic percentage width greater than 0%
							is assigned the larger of:
							<ul>
								<li>its intrinsic percentage width times the assignable width and
								<li>its min-content width

						<li>all other columns are assigned their max-content width.
					</ul>

			<div class="note">
				Note that the assignable width is greater than or equal to the table width using the min-content guess,
					and that the widths for each column in the four guesses
					(min-content guess, min-content-percentage guess, min-content-specified guess, and max-content guess)
					are in nondecreasing order.
			</div>

			<p>
				If the <a>assignable table width</a> is less than or equal to the <a>max-content guess</a>,
					the used widths of the columns must be the linear combination (with weights adding to 1)
					of the two consecutive guesses whose width sums bound the available width.

			<p>
				Otherwise, the used widths of the columns are the result of starting from the <a>max-content guess</a>
					and distributing the excess width to the columns of the table
					according to the rules for <a>distributing excess width to columns</a> for used width calculation.

		<figure>
			<p class="advisement">
				The following schema describes the algorithm in a different way,
					to make it easier to understand.
			</p>
			<img src="images/CSS-Tables-Column-Width-Assignment.svg" style="width: 100%" />
			<figcaption>Overview of the width distribution algorithm. Not normative.</figcaption>
		</figure>

		<p class="issue">
			Edge and Chrome ignores "min-width: %" while Firefox applies it properly.
			Firefox continues to apply a "min-width: %" when a "width: px" is specified (the width is ignored).
			We should decide on what is the right behavior and make sure it is written in the spec.

		<h5 id="distributing-width-to-columns">Distributing excess width to columns</h5>

		<p>
			The rules for <dfn>distributing excess width to columns</dfn> can be invoked in two ways:
			<ul>
				<li>for distributing the excess width of a table to its columns
					during the computation of the used widths of those columns (for used width calculation), or

				<li>for distributing the excess max-content or min-content width of a column-spanning cell
					to the max-content or min-content widths of the columns it spans (for intrinsic width calculation).
			</ul>

		<p>
			The rules for these two cases are largely the same, but there are slight differences.

		<p>
			The remainder of this section uses the term <dfn>distributed width</dfn> to refer to the one of these widths that is being distributed,
			and the <dfn>excess width</dfn> is used to refer to the amount by which the width being distributed
			exceeds the sum of the distributed widths of the columns it is being distributed to.

		<ol>

			<li>If there are non-constrained columns that have originating cells
					with intrinsic percentage width of 0% and
					with nonzero max-content width
					<i class="hint">(aka the columns allowed to grow by this rule)</i>,
				the distributed widths of the columns allowed to grow by this rule
					are increased in proportion to max-content width
					so the total increase adds to the excess width.

			<li>Otherwise, if there are non-constrained columns that have originating cells
					with intrinsic percentage width of 0%
					<i class="hint">(aka the columns allowed to grow by this rule,
					which thanks to the previous rule must have zero max-content width)</i>,
				the distributed widths of the columns allowed to grow by this rule
					are increased by equal amounts
					so the total increase adds to the excess width.

			<li>Otherwise, if there are (constrained) columns
					with intrinsic percentage width of 0% and
					with nonzero max-content width
					<i class="hint">(aka the columns allowed to grow by this rule, which, due to other rules, must have originating cells)</i>,
				the distributed widths of the columns allowed to grow by this rule
					are increased in proportion to max-content width
					so the total increase adds to the excess width.

			<li>Otherwise, if there are columns
					with intrinsic percentage width greater than 0%
					<i class="hint">(aka the columns allowed to grow by this rule, which, due to other rules, must have originating cells)</i>,
				the distributed widths of the columns allowed to grow by this rule
					are increased in proportion to intrinsic percentage width
					so the total increase adds to the excess width.

			<li>Otherwise, the distributed widths of all columns that have originating cells
					are increased by equal amounts
					so the total increase adds to the excess width.
		</ul>

		<p class="issue">
			What if no columns have originating cells?
			Should the originating cells condition in the previous paragraph just be removed, or should, there be an additional "Otherwise" here?

	<!--------------------------------------------------------------------------------->
	<h3 id="height-distribution">Available Height Distribution</h3>

		<!--------------------------------------------------------------------------------->
		<h4 id="height-distribution-principles">Core principles</h3>

			<p class="issue">
				Decide what to do for height distribution. <br/>
				<span class="hint">Should we use the same algorithm as [[#width-distribution]] with different metrics?</span>

			<div class="note">

				<p style="font-weight: bold; font-size: 120%;">
					Investigations on height distribution

				<p>
					Initial analysis shows that there are indeed similarities between width and height distribution.
					There are also differences which I described here below:

				<p>
					In many case, all browsers apply a distribution algorithm that favors percentages over pixels over auto.
					<span class="hint"><a href="https://jsfiddle.net/xg2ss965/2/">Case 6</a></span>.

				<p>
					A difference with the width distribution algorithm is that
						if the sum of all rows' heights is higher than 100%,
						then all browsers enter a completely different mode.
						<a href="https://jsfiddle.net/6ec0hxgx/">Case 7</a>.
						<span class="hint">
							NOTE: The sum counts as well percentage heights and pixels heights,
							since at this point you can safely resolve percentages.
						</span>
						<br/>

					In this case, pixel-tracks are sized properly first.
					Then, percentage tracks get the remaining space proportionally to their height percentage up to their height percentage.
					Finally, auto tracks get to fill the remaining space, if there is any auto track.
					If there is none, percentage tracks continue growing above their height percentage until all the space is filled.
					<a href="https://jsfiddle.net/xg2ss965/1/">Case 9</a>.

				<p>
					The height distribution algorithm also caps the sum of percentage heights to 100% in all browsers but Edge.
					That means that some rows get an arbitrary 0% height.
					<a href="https://jsfiddle.net/xg2ss965/">Case 8</a>.

				<p>
					In Edge and Firefox, empty tracks do not get an increased size by this distribution if there are filled auto tracks.
					In Chrome, empty tracks count as distributable tracks as well even if there are other auto tracks.

					<ul class="inline hint">
					<li>Case 1: <a href="https://jsfiddle.net/Lh9shm8p/">height</a> vs <a href="https://jsfiddle.net/wza8huh7/">width</a>
					<li>Case 2: <a href="https://jsfiddle.net/Lh9shm8p/1/">height</a> vs <a href="https://jsfiddle.net/wza8huh7/1/">width</a>
					<li>Case 3: <a href="https://jsfiddle.net/Lh9shm8p/2/">height</a> vs <a href="https://jsfiddle.net/wza8huh7/2/">width</a>
					<li>Case 4: <a href="https://jsfiddle.net/Lh9shm8p/3/">height</a> vs <a href="https://jsfiddle.net/wza8huh7/3/">width</a>
					<li>Case 5: <a href="https://jsfiddle.net/Lh9shm8p/4/">height</a> vs <a href="https://jsfiddle.net/wza8huh7/4/">width</a>
					</ul>

					<style>
						ul.inline { display: inline; margin: 0; padding: 0; }
						--ul.inline::before { content:"("; display: inline; }
						--ul.inline::after { content:")"; display: inline; }
						ul.inline > li { display: inline; margin: 0; padding: 0; }
						ul.inline > li::after { content:", "; display: inline; }
						ul.inline > li:last-of-type::after { content:""; display: none; }
					</style>

				<p id="min-content-and-percentages">
					Intersting test cases about min-content and content using percentage sizes:
					<ul class="compact">
						<li><a href="https://jsfiddle.net/gzapbyeg/1/">Case 10</a>.
						<li><a href="https://jsfiddle.net/gzapbyeg/2/">Case 11</a>.
					</ul>
					<br/>
					Chrome and Edge apply percentages on the final layout.
					All browsers work around them during the first pass
						by considering them 0% (Chrome) or
						by ignoring the declaration (Edge, Firefox).
					The difference of choice is visible in
					<a href="https://jsfiddle.net/vmfrLzke/1/">Case 12</a>.
					<a href="http://codepen.io/FremyCompany/pen/obdYjv?editors=1100">Case 13</a>.
			</div>

		<!--------------------------------------------------------------------------------->
		<h4 id="height-distribution-algorithm">Distribution algorithm</h3>

			<p>
				TODO

	<!--------------------------------------------------------------------------------->
	<h3 id="layout-algorithm">Position of cells and captions</h3>

		<p style="font-style: italic">
			This section will explain where cells and captions should be rendered.

		<div class="issue">
			We have to decide whether we want captions to act like a row, or be independant.
			Right now their existence is eluded to avoid answering the question.
			<a class="hint" href="https://jsfiddle.net/q1qwo6j6/1/">!!Testcase</a>
		</div>

		<div class="issue">
			We have to decide what visibility:collapse does.
			My proposal is to do like "hidden" but in addition
				use the following formula to shift back the following rows/columns.
			The total width/height of the table would not be affected, only the cells position would.
			<a href="http://codepen.io/FremyCompany/pen/KVRzWe?editors=1100">!!Testcase</a>.
			<a href="http://codepen.io/FremyCompany/pen/KVRzQx?editors=1100">!!Testcase</a>.
			<a href="http://codepen.io/FremyCompany/pen/MKGyBx?editors=1100">!!Testcase</a>.
		</div>

		<p>
			Once the width of each column, and height of each row has been determined,
				the position of any table cell C is defined as the rectangle whose:
			<ul class="compact">
				<li>width/height is the sum of:
					<ul><li>the widths/heights of all spanned columns/rows
						<li>the horizontal/vertical 'border-spacing' times the amount of spanned columns/rows minus one
					</ul>
				<li>left/top location is the sum of:
					<ul><li>the widths/heights of all previous columns/rows
						<li>the horizontal/vertical 'border-spacing' times the amount of previous columns/rows plus one
					</ul>
			</ul>
			<a id="spanning-ghost-rows" href="https://jsfiddle.net/3pox7b4f/">~Testcase</a>
			<a href="https://jsfiddle.net/3pox7b4f/1/">!!Testcase</a>
			<a href="https://jsfiddle.net/3pox7b4f/3/">!!Testcase</a>
			<a href="https://jsfiddle.net/3pox7b4f/4/">!!Testcase</a>
			<a href="https://jsfiddle.net/3pox7b4f/5/">Testcase</a>

		<p>
			If the table layout mode is "fixed",
				the content of some cells may exceed the available horizontal space,
				and cause an overflow.
			Such overflow should behave exactly
				like if the cell was an absolutely positioned display:block box.
			<a class="hint" href="https://jsfiddle.net/24bz3Lp1/">!Testcase</a>
			<a class="hint" href="https://jsfiddle.net/24bz3Lp1/1/">!Testcase</a>
			<a class="hint" href="https://jsfiddle.net/24bz3Lp1/3/">Testcase</a>

<!--------------------------------------------------------------------------------->
<h2 id="rendering">Rendering</h2>

	<!--------------------------------------------------------------------------------->
	<h3 id="paint-order">Paint order of cells</h3>

		<p>
			Table cells are painted in a table-root in DOM order as usual,
				independently of where cells end up actually being drawn.

	<!--------------------------------------------------------------------------------->
	<h3 id="empty-cell-rendering">Empty cell rendering (separated mode)</h3>

		<p>
			Cells are <dfn id="empty-cell">empty</dfn> unless they contain one or more of the following:
			<ul><li>floating content, or
				<li>in-flow content (other than white space that has been collapsed away by the 'white-space' property handling).</ul>

		<div class="issue">
			Chrome simplified this to just matching :empty.
			Should we match?
		</div>

		<pre class="propdef">
			Name: empty-cells
			Value: show | hide
			Initial: show
			Applies to: <code>table-cell</code> elements
			Inherited: yes
			Media: visual
		</pre>

		<p>
			<a>In collapsed mode</a>,
				this property has no effect.

		<p>
			<a>In separated mode</a>,
				this property controls the rendering of borders and backgrounds
				around cells that have no visible content.

		<p>
			When this property has the value <code>hide</code>,
				no borders or backgrounds are drawn around/behind empty cells.

		<div class="issue">
			Why not just say that the cell has "visibility: hidden"?
		</div>

		<p>
			Furthermore, if all the cells in a row have a value of <code>hide</code> and have no visible content,
				then the row has zero height and the vertical border-spacing applies to one side of the row only.

		<div class="issue">
			Why not just say that the row has "display: none"?
		</div>
		<div class="issue">
			Moreover, do we even need this behavior? <a href="https://jsfiddle.net/2oy2qt2q/3/">!!Testcase</a>
		</div>

		<div class="example">
			<p>For example, take the following markup and css:
			<pre class="lang-markup">
				&lt;table>
					&lt;td>&lt;span>&lt;/span>&lt;/td>
					&lt;td>&lt;/td>
					&lt;td>&lt;span>&lt;/span>&lt;/td>
				&lt;/table>
			</pre>
			<pre class="lang-css">
				table {
				  width: 500px; height: 300px;
				  empty-cells: hide;
				}

				table { background: black; border: 10px solid black; }
				td { background: white; }

				table { border-spacing: 0px; }
				td { padding: 0; }
			</pre>
			<p>The correct rendering of this code snippet is depicted here:
			<figure>
				<img src="images/empty-cells-example.gif" width=500 height=300 />
				<figcaption>Rendering of three columns whose middle one is hidden by empty-cells:hide</figcaption>
			</figure>
		</div>

	<!--------------------------------------------------------------------------------->
	<h3 id="drawing-cell-backgrounds">Drawing cell backgrounds</h3>

		<p>
			In addition to its own 'background', <a>table-cell</a> elements also 
				render the backgrounds of the <a>table-track</a> and <a>table-track-grouping</a> elements in which they belong.
			This is actually different from simply inheriting their background
				because the 'background-origin' and 'background-size' computations will actually be done
				on the bounds of the grouping elements, and not on those of the cell.

		<p>
			For the purposes of finding the background of each table cell,
				the different table elements may be thought of as being on six superimposed layers.
			The background set on an element in one of the layers will only be visible
				if the layers above it have a transparent background.

		<p><figure>
			<img src="https://www.w3.org/TR/CSS2/images/tbl-layers.png">
			<figcaption>Schema of table layers.</figcaption>
			</figure></p>

		<ol start="0">
			<li>The table background is being rendered by the table,
				and does not affect the cell background.

			<li>The first background drawn by a cell is the background of its originating column group.
				For the purpose of background-positioning, 
					it is expected that a column group occupies 
					the largest possible area a single cell could occupy in the row/column grid
					while originating in the column group and not entering any column not part of the column group.

			<li>The second background drawn by a cell is the background of its originating column.
				For the purpose of background-positioning, 
					it is expected that a column occupies 
					the largest possible area a single cell could occupy in the row/column grid
					while originating in the column and not entering any other column.

			<li>The third background drawn by a cell is the background of its originating row group.
				For the purpose of background-positioning, 
					it is expected that a row group occupies 
					the largest possible area a single cell could occupy in the row/column grid
					while originating in the row group and not entering any row not part of the row group.

			<li>The fourth background drawn by a cell is the background of its originating row.
				For the purpose of background-positioning, 
					it is expected that a row occupies 
					the largest possible area a single cell could occupy in the row/column grid
					while originating in the row and not entering any other row.

			<li>The fifth background drawn by a cell is its own background.
				This is the one that appears on top once all backgrounds have been rendered.
		</ol>

		<p>
			As the figure above shows, although all rows contain the same number of cells,
				not every cell may have specified content.
			<a>In separated mode</a>, if the value of their 'empty-cells' property is <code>hide</code>, these "empty" cells are not rendered at all,
				as if <code>visibility: hidden</code> was specified on them,
				letting the table background show through.

	<!--------------------------------------------------------------------------------->
	<h3 id="drawing-collapsed-borders">Drawing borders (collapsed mode)</h3>

		<p>
			When a table is <a>rendered in collapsed mode</a>,
				the rendering of its borders on and those of its table-cells is modified.
			The following rules describe in which way.

		<!--------------------------------------------------------------------------------->
		<h4 id="drawing-collapsed-table-root-borders">Drawing table-root elements borders (collapsed mode)</h4>

			<p>
				Borders of a <a>table-root</a> element are not rendered <a>in collapsed mode</a>,
					except if the 'border-image' property is set.

			<p>
				In this case, the border is drawn as if the table border was twice as big as its used value specify,
					and as if that excess was rendered inside the padding area of the <a>table-root</a> element.

		<!--------------------------------------------------------------------------------->
		<h4 id="drawing-collapsed-table-cell-borders">Drawing table-cell elements borders (collapsed mode)</h4>

			<p>
				Borders of a <a>table-cell</a> element are rendered <a>in collapsed mode</a>\
					as if the cell border was twice as big as its used value specify,
					and as if that excess was rendered in the margin area of the cell,
					with the added constraint that
						for each side of the border which isn’t located at one of the the table edges,
						the border is actually clipped to the border-box drawing area as its real used value define
						except if the 'border-image' property is set.

			<p>
				If applying the previously-mentioned clipping behavior results in clipping a border over a non-integer amount of device pixels,
					browsers may decide to snap the clipping area to a device pixel instead by ceiling the x- and y-values of the clipping area.
				Ceiling the values ensures that in a normal writing mode,
					the cell which gets the contested pixels between multiple cells is actually the most top left one,
					which has a greater specificity than the other ones according to this spec.
					<span class="hint">See [[#paint-order]] and [[#border-conflict-resolution-algorithm]].</span>

		<!--------------------------------------------------------------------------------->
		<h4 id="border-style-overrides">Border styles (collapsed mode)</h4>

			<p>
				Some of the values of the 'border-style' have different meanings in tables <a>in collapsed mode</a> than for other elements.
				Those definitions override the default behavior for 'border-style' values.

				: hidden
				:: Same as <code>none</code>, but also inhibits any other border (see [[#border-specificity]]).
				: inset
				:: Same as <code>ridge</code>.
				: outset
				:: Same as <code>groove</code>.


<!--------------------------------------------------------------------------------->
<h2 id="bug-list">List of bugs being tracked</h2>

<p style="font-size: italic">
	This section is not normative.

<ul class="bug-list">

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/jWzpjq?editors=1100">
				Align=center attribute overrides css margins in Edge
			</a>
			<details>
				Chrome and Firefox let CSS win.<br/>
				Edge hides every border + table/row-group/row background.<br/>
				<br/>
				This specification says that Chrome and Firefox are right.<br/>
				[[#mapping]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/ZQxVMo?editors=1100">
				Chrome applies nowrap quirks mode fix in DOCTYPE documents too
			</a>
			<details>
				Edge and Firefox do not apply the fix in normal mode.<br/>
				Chrome also applies it for css widths, which is not what the spec says to do.<br/>
				<br/>
				The WHATWG spec says that Chrome is wrong.<br/>
				This spec is aiming to state the same thing.<br/>
				[[#mapping]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/RrMvPR?editors=1100">
				Edge does not account for widths of spanned cells
			</a>
			<details>
				Chrome and Firefox merge the two columns so are not affected.<br/>
				Edge does not then is confused about what to do.<br/>
				<br/>
				The specs says that Edge is wrong.<br/>
				[[#dimensioning-the-row-column-grid]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/xZWmXy?editors=1100">
				Align=center attribute overrides css margins in Edge
			</a>
			<details>
				Edge has issues with percentage widths.<br/>
				<br/>
				This specification should say that Chrome and Firefox are right, I guess.<br/>
				[[#computing-cell-measures]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/PZRdzo?editors=1100">
				Table boxes should be wide enough to contain the caption
			</a>
			<details>
				Chrome uses the CSS21 algorithm that fulfill this.<br/>
				Firefox and Edge use David Baron's algorithm that doesn't.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				Chrome behavior is simpler to spec but not intuitive.<br/>
				[[#computing-the-table-width]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/VeXVwz?editors=1100">
				Tables containing no row cannot have height in Chrome, but can in Edge/Firefox
			</a>
			<details>
				Chrome has table height = 0px.<br/>
				Firefox and Edge have table height = specified height.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				Firefox and Edge match author intentions better.<br/>
				[[#computing-the-table-height]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/yeKRGW?editors=1100">
				Table-layout:fixed causes different width distribution in Chrome
			</a>
			<details>
				Chrome starts to value px then percentages.<br/>
				Others continue to value percentage then px.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				It is intended to specify the Edge/Firefox behavior.<br/>
				[[#width-distribution]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/XXEoWe?editors=1100">
				Chrome distributes the height to each row differently then IE and firefox
			</a>
			<details>
				Chrome distributes rather equally.<br/>
				Edge and Firefox work more similarly to width distribution.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				I think it makes sense to behave similarly for width and height, though.<br/>
				[[#height-distribution]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/PZRdOP?editors=1100">
				Height of rows which can overflow varies in Chrome vs Edge
				(percentage heights during min-height computation)
			</a>
			<details>
				Chrome chooses table constraints over the no-scroll constraint.<br/>
				Edge and Firefox do the opposite.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				Edge's behavior is right by default due to CSS Sizing, though.<br/>
				It would make sense to do what Chrome is doing when elements have non-visible overflow-y.<br/>
				[[#height-distribution]] <a href="#min-content-and-percentages">#REF</a>
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/MKVPGR?editors=1100">
				Height specified on row groups is not interoperable
			</a>
			<details>
				Chrome ignores the height.<br/>
				Firefox respects the height.<br/>
				IE applies the height to each cell.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				An author would expect the Firefox behavior.<br/>
				[[#height-distribution]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/MKVPGR?editors=1100">
				Min-Height specified on rows is not interoperable
			</a>
			<details>
				Chrome and Firefox ignore the height.<br/>
				Edge applies the height.<br/>
				<br/>
				This specification has no opinion yet on the matter.<br/>
				An author would expect the Edge behavior.<br/>
				[[#height-distribution]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://jsfiddle.net/ArtyomShegeda/Ffjhn/1/">
				Table with interleaved td[rowspan] rendered wrong in IE (145069)
			</a>
			<details>
				Edge height-sizing has issues with this crossed-rowspan table.<br/>
				<br/>
				There is no doubt this is a bug, but it is a good test case for the algorithm.<br/><br/>
				[[#height-distribution]]
			</details>
		</summary>
	</li>

	<li>
		<summary>
			<a href="http://codepen.io/FremyCompany/pen/MKVqXQ?editors=1100">
				Row with explicit 'visibility:visible' lose background color
				when parent table has 'visibility: hidden'
			</a>
			<details>
				Chrome only hides table background + border.<br/>
				Firefox hides table background + border, and row-group background.<br/>
				Edge hides every border + table/row-group/row background.<br/>
				<br/>
				This specification currently says that Chrome is right.<br/>
				[[#drawing-cell-backgrounds]]<br/>
				<div class="issue">
					Should we hide the row-group background
						by saying cells only draw the backgrounds
						of visibility:visible grouping elements?
				</div>
			</details>
		</summary>
	</li>

</ul>

<style>

	ul.bug-list {
		list-style-type: none;
		padding: 0;
		font-size: 80%;
	}
	ul.bug-list > li {
		margin: 0; margin-bottom: 10px;
	}
	ul.bug-list > li > summary {
		background: #efefef;
		padding: 10px;
	}
	ul.bug-list > li > summary > details {
		background: #f7f7f7;
		padding: 10px; font-weight: normal;
	}

</style>

<!--------------------------------------------------------------------------------->
<h2 id="fragmentation">Fragmentation</h2>

	<p style="font-style: italic">
		This section overrides any other behavior defined in the fragmentation specification.
	
	<!--------------------------------------------------------------------------------->
	<h3 id="breaking-rules">Breaking across fragmentainers</h3>
	
		<p>
			When fragmenting a table, user agents must attempt 
				to preserve table cells unfragmented.
				
		<p>
			When a table doesn't fit entirely in a fragmentainer,
				the user agent has to insert some horizontal gap 
				between the rows located before and at the overflow point
				such that the two rows end up separated in sibling fragmentainers.
		<p>
			When there is no row fitting entirely the current fragmentainer,
				user agents must split each cell of the row among the two fragmentainers
				so that all fragments preserve the same height.
			Then, the user agent must fragment the content of each cell 
				among its two fragments in parallel. 
	
		<p>
			When 'break-before' or 'break-after' is applied 
			to a <a>table-row-grouping</a> or a <a>table-row</a> box,
				the user agent has to insert some horizontal gap 
				between the rows located before and after the breaking point
				such that the two rows end up separated in sibling fragmentainers 
				as required by the property value.
		
	<!--------------------------------------------------------------------------------->
	<h3 id="repeated-headers">Repeating headers across pages</h3>

		<p>
			When rendering the document into a paged media, 
				user agents should repeat 
					<a href="#table-header-group">header rows</a> and 
					<a href="#table-footer-group">footer rows</a>  
				on each page spanned by a table.
			
		<p>
			When doing so doesn't leave enough space to insert at least one content row,
				users agents must drop the repeated footer.
			
		<p>
			When doing so still doesn't leave enough space to insert at least one content row,
				users agents must drop the repeated header.
				
<!--------------------------------------------------------------------------------->
<h2 id="TODO">(link here for missing sections)</h2>
<style>

	.hint { opacity: 0.5; transition: opacity 0.25s; }
	.hint:hover { opacity: 1; }

	.highligth { background: yellow; }

	/* fallback for summary/details */
	summary { display: block; }
	summary:not([open]) > details { display: none; }
	summary:not([open]):hover > details { display: block; }
	#if-css-supports summary::-webkit-details-marker, summary:not([open]) > details { display: block; }
	#if-css-supports summary::-moz-details-marker, summary:not([open]) > details { display: block; }
	#if-css-supports summary::-ms-details-marker, summary:not([open]) > details { display: block; }
	#if-css-supports summary::details-marker, summary:not([open]) > details { display: block; }

</style>
